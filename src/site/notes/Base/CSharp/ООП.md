---
{"dg-publish":true,"permalink":"/base/c-sharp/oop/"}
---

ООП — это подход, при котором программа рассматривается как набор объектов, взаимодействующих друг с другом. ООП фокусируется на использовании объектов для моделирования реальных или абстрактных сущностей


Алан Кэй — один из создателей языка **Smalltalk**





```ad-note
title:Smalltalk
collapse:
По мнению Апана Кея, создателя языка Smalltalk, которого считают одним из «отцов-основателей» ООП, объектно-ориентированный подход заключается в следующем наборе основных принципов (цитируется по вышеупомянутой книге Т. Бадда).
1. Всё является объектом.
2. Вычисления осуществляются путём взаимодействия (обмена данными) между объектами, при котором один объект требует, чтобы другой объект выполнил некоторое действие. Объекты взаимодействуют, посылая и получая сообщения. Сообщение - это запрос на выполнение действия, дополненный набором аргументов, которые могут понадобиться при выполнении действия.
3. Каждый объект имеет независимую память, которая состоит из других объектов.
4. Каждый объект является представителем класса, который выражает общие свойства объектов (таких, как целые числа или списки).
5. В классе задаётся поведение (функциональность) объекта. Тем самым все объекты, которые являются экземплярами одного класса, могут выполнять одни и те же действия.
6. Классы организованы в единую древовидную структуру с общим корнем, называемую иерархией наследования. Память и поведение, связанное с экземплярами определённого класса, автоматически доступны любому классу, расположенному ниже в иерархическом дереве.
```

Базовые принципы ООП сформулированные Аланом Кэйом:

1. Всё объект(вообще всё: числа, строки, конструкции, циклы)
2. Объект это базовая единица объектно-ориентированной системы
3. Посылка сообщений единственный способ обмена информацией между объектами
4. Каждый объект относиться к какому-то классу
5. Поведение объекта определяется его классом
6. Классы наследуют функциональность от предка

### Принципы ООП:

#### Инкапсуляция
Трактовка №1.
Инкапсуляция — это механизм языка объединяющий данные и функции которые управляют этими данными, в единый компонент.

Трактовка №2.
Инкапсуляция — это механизм языка, позволяющий ограничить доступ одних компонентов программы к другим.

Инкапсуляция обеспечивает сокрытие, но не является сокрытием.
Инкапсуляция предоставляет **возможность** скрыть данные, но для реализации сокрытия необходимо использовать модификаторы доступа.

**Инкапсуляция** создаёт механизм объединения данных и методов, но сама по себе не ограничивает доступ к этим данным.

Этот пример соответствует трактовке №1 и №2
```csharp
class Phone
{
	private string phone = "8 (800) 555 3 555";//Данные

	public void ShowPhone()//Метод управляющий данными
	{
        Console.WriteLine(this.phone);
	}
}
```


Инкапсуляция это по сути создание черного ящика. Внутри есть данные, снаружи есть  методы/события/свойства, к которым можно обратиться для взаимодействия с этим ЧЯ. Основная идея - исключить вмешательство во внутреннее состояние извне незапланированным способом и исключить неправильное использование внутренних данных.
Возможности инкапсуляции поддерживаются с помощью [классов](https://en.m.wikipedia.org/wiki/Class_(computer_programming))

Encapsulation (от лат. in capsula) это объединения методов и данных в одну сущность для сокрытия реализации.

Для меня инкапсуляция – это сокрытие реализации с помощью объединения (помещения в капсулу) методов и свойств.
Сокрытие в виде модификаторов доступа – это не определение, это механизм языков, которые помогают делать капсулу ещё безопасней.
В C# при создании класса модификаторы доступа идут паровозом.

Скорее модификаторы доступа, являются приятным дополнением чем основой инкапсуляции.

```ad-note
title:Подробно
collapse:

Метод сам по себе не обеспечивает суть инкапсуляции, нам нужно взять какой-то объект, например класс, у которого будет свое состояние. Какие-то внутренние вещи, которые используются для выполнения нужной логики. И твой метод будет предоставлять способ этого взаимодействия

Инкапсуляция обеспечивает сокрытие посредством объединения данных и функций которые управляют этими данными, в единый компонент 

Инкапсуляция в C# достигается посредством методов, классов (и т.д.) и посредством модификаторов доступа. Но стоит учесть что, как только мы объединяем методы и данные в одну капсулу мы получаете модификаторы паровозом.



В объектно-ориентированных языках программирования инкапсуляция ссылается на один из двух связанных между собой, но все же различных понятия и иногда даже их комбинацию:
- механизм языка для ограничения прямого доступа к каким-то компонентам объекта
**И/ИЛИ**
- конструкция языка, которая позволяет объединять данные и методы (или другие функции) оперирующие над данными в единый компонент(к примеру в класс)



Encapsulation (от лат. in capsula) это объединения методов и данных в одну сущность для сокрытия реализации. Пользователям этой сущности должно быть пофиг, как реализован функционал внутри, это скрыто от них. И тут никакой речи о модификаторах доступа, хотя они являются приятным дополнением в языках, если они присутствуют.

В языках, которых нет модификаторов доступа(Python) инкапсуляция это чисто механизм языка, который позволяет объединить данные и методы, работающие с этими данными в единый класс

https://www.flenov.info/story/show/Inkapsulyaciya-eto-sokrytie-ili-net
```



#### Наследование
Наследование — это механизм языка который позволяет описывать новый класс на основе существующего.
Наследование нужно для повторного использования кода и для формирования иерархий родственных объектов и открывать дорогу полиморфизму.




Касательно повторно используемого кода наследование является причиной сильного связывания. К примеру у нас может быть родительский класс у которого сотни наследников и изменение базового класса может отрицательно повлиять на наследников

```csharp
class A // Родитель
{
	public void ShowMessage()// Метод родителя
	{
		Console.WriteLine("message");
	}
}
class B : A // Наследуемся
{
}

public static class Program
{
	public static void Main()
	{
		B b = new B(); //Создаём экземпляр наследника
		b.ShowMessage();//Вызываем унаследованный метод
	}
}
```

#### Полиморфизм
Возможность объектов с одинаковой спецификацией иметь различную реализацию

**Полиморфизм** (polymorphism) – возможность одной и той же переменной в различные моменты выполнения программы обозначать объекты различных типов (классов), относящихся к одному базовому типу (классу или интерфейсу).

Полиморфизм обеспечивает сокрытие
```ad-note
title:Сокрытие посрведством полиморфизма
collapse:
```csharp
class Parent
{ // Родитель
	public virtual void Test2()
	{
		Console.WriteLine("parent test2 method");
	}
}
class A : Parent // Наследуемся
{ 
	public void Test()
	{
		Console.WriteLine("test method");
	}
	public override void Test2()
	{
		// Переопределяем 
		this.Test();
	}
}
public static class Program
{
	public static void Main()
	{
		Parent obj = new A(); // Апкаст
		obj.Test2(); // Выведет: test method
		obj.Test(); // Даже не скомпилируется, хотя метод public
	}
}

```

##### Специальный полиморфизм(Ad Hoc)
В C# он представлен механизмом перегрузки методов

```csharp
class A 
{
	public void ShowMessage()//Метод
	{
		Console.WriteLine("message");
	}
	public void ShowMessage(string message)//Перегрузка метода
	{
		Console.WriteLine(message);
	}
}
public static class Program
{
	public static void Main()
	{
		A a = new A();
		a.ShowMessage();// Выведет "message"
		a.ShowMessage("another message");// Выведетanother message
	}
}
```
##### Параметрический полиморфизм
В C# он представлен дженериками

Явным примером параметрического полиморфизма является универсальный класс `List<T>`
##### Полиморфизм подтипов(действительный полиморфизм)
В C# он представлен механизмами наследования, переопределения(`override`) и апкаста.


```csharp
class A //Родитель
{
	public virtual void ShowMessage() // Виртуальный метод
	{
        Console.WriteLine("message");
	}
}
class B:A //Наследуемся
{
	public override void ShowMessage() // Переопределение виртуального метода
	{
		Console.WriteLine("override message");
	}
}

public static class Program
{
	public static void Main()
	{
		A a = new A();
		A b = new B();
		a.ShowMessage();//Выведет message
		b.ShowMessage();//Выведет override message
	}
}
```

```ad-note
title:Пример
collapse:
```csharp
abstract class Logger
{ 
	// Родитель
	public abstract void Log(string text);
}
class ConsoleLogger : Logger
{	// Консольный логгер
	public override void Log(string text)
	{
		Console.WriteLine(text);
	}
}
class FileLogger : Logger
{	// Файловый логгер
	public override void Log(string text) 
	{ 
		File.WriteAllText("log.txt", text);
	}
}
class HttpLogger : Logger
{	
	// http логгер
	public override void Log(string text)
	{
		new HttpClient().GetAsync("http://какой-то-сайт.ru?log=" + text);
	}
}
```





#### Абстракция
Основная идея состоит в том, чтобы представить объект минимальным напором полей и методов и при этом с достаточной точностью для решаемой задачи.

#### Посылка сообщений
Это то же самое когда мы или объект вызываем метод у другого объекта

```csharp
class A
{
	public void Method()
	{
        Console.WriteLine("method");
	}
}

public static class Program
{
	public static void Main()
	{
		A a = new A();
		a.Method();//Произошла посылка сообщений
	}
}
```

#### Повторное использование
Все предыдущие парадигмы должны быть направлены на повторное использование кода