Быстрая сортировка основа на стратегии разделяй и властвуй

Решение задачи методом "разделяй и властвуй" состоит из двух шагов:
1. Сначала определяется базовый случай. Это должен быть простейший случай из всех возможных. На нём и завершиться выполнение по стратегии "разделяй и властвуй".
2. Задача делиться и сокращается до тех пор, пока не будет сведена к базовому случаю.

Фермер владеет земельным участок (прямоугольным) размером 1680x640. Задача стоит в том, чтобы разделить данный участок на равные квадраты максимального размера, так, чтобы не осталось лишней земли.

При делёжке прямоугольника на квадраты, стороной квадрата будет являться наименьшая сторона прямоугольника, но при делении всё равно будет оставаться нераспределенная земля. Её мы будем делить по такому же принципу.

![Pasted image 20230102183731.png](/img/user/Files/Image/Pasted%20image%2020230102183731.png)
Делим 1680x640 по описанному принципу.

Длинна: 1680
Ширина
 1680x640 -> 640x640. Получается два квадрата по 640x640 и остаток 400x640 -> 400x400 Один квадрат 400x400 и остаток 400x240 -> Один квадрат 240x240 и остаток 160x240 -> 160x160 и остаток 160x80 -> **Два квадрата** по 80x80 и остаток 0

> \- Алгоритм Евклида
> Если вы найдёте самый большой участок, подходящий для этого размера, это будет самый большой участок, подходящий для всей фермы.


Сумма чисел в массиве через стратегию "разделяй и властвуй"

1. Базовый случай:
Самый просто случай это пустой массив или массив с 1 элементом, он суммируется достаточно просто
2. Сумма первого числа в массиве и суммы остальных чисел в массиве
![Pasted image 20230102193608.png|400](/img/user/Files/Image/Pasted%20image%2020230102193608.png)

То есть ка каждый шаг мы должны уменьшать задачу, чтобы свести её к базовому случаю.
В примере с полем это был размер земельного участка, в примере с массивом это размер массива.
![Pasted image 20230102193814.png|500](/img/user/Files/Image/Pasted%20image%2020230102193814.png)


 > #### В рекурсии связанной с массивом базовым случаем часто является пустой массив либо массив состоящий из одного элемента.


Для быстрой сортировки необходимо выбрать опорный элемент. В итоге исходный массив делиться на два массива:
1. элементы которого меньше опорного 
2. элементы больше опорного

Схема быстрой сортировки
![Pasted image 20230103160443.png](/img/user/Files/Image/Pasted%20image%2020230103160443.png)

<details>
<summary>Быстрая сортировка с помощью рекурсии</summary>

```csharp
    public static List<int> quickSort(List<int> array)
    {
        if (array.Count < 2) return array; //базовый случай

        List<int> less = new List<int>();
        List<int> greater = new List<int>();

        int pivot = array[array.Count - 1]; //опорный элемент

        for (int i = 0; i < array.Count - 1; i++)
        {
            if (array[i] < pivot) less.Add(array[i]);
            if (array[i] > pivot) greater.Add(array[i]);
        }  
        return quickSort(less).ToList() 
        .Concat(new List<int>() { pivot })
        .Concat(quickSort(greater)).ToList();//Индукционный переход
    }

```
</details>

<details>
<summary>Быстрая сортировка с  помощью цикла</summary>

```csharp
    public static void QuickSortIterative(ref int[] data)
    {
        int startIndex = 0;
        int endIndex = data.Length - 1;
        int top = -1;
        int[] stack = new int[data.Length];

        stack[++top] = startIndex;
        stack[++top] = endIndex;

        while (top >= 0)
        {
            endIndex = stack[top--];
            startIndex = stack[top--];

            int p = Partition(ref data, startIndex, endIndex);

            if (p - 1 > startIndex)
            {
                stack[++top] = startIndex;
                stack[++top] = p - 1;
            }

            if (p + 1 < endIndex)
            {
                stack[++top] = p + 1;
                stack[++top] = endIndex;
            }
        }
    }

    private static int Partition(ref int[] data, int left, int right)
    {
        int pivot = data[right];
        int i = (left - 1);

        for (int j = left; j <= right - 1; ++j)
        {
            if (data[j] <= pivot) //Смотри какие элементы меньше последнего
            {                              //а потом через Swap(ref data[i + 1], ref data[right]) 
                ++i;                    //делаем его центральным
                Swap(ref data[i], ref data[j]);
            }
        }

        Swap(ref data[i + 1], ref data[right]);

        return (i + 1);
    }

    private static void Swap(ref int a, ref int b)
    {
        int temp = a;
        a = b;
        b = temp;
    }
```
</details>

1. Пустые массивы и массивы из одного элемента сортировать не надо. (это базовый случай)
2. В массиве из двух элементов достаточно сравнить два элемента и если первый больше второго, то переставить местами
3. В массиве из трёх элементов выбираем опорный элемент и находим элементы меньше и больше опорного. У нас получается два массива 
![Pasted image 20230103204022.png](/img/user/Files/Image/Pasted%20image%2020230103204022.png)
Оба массива состоят из одного элемента, как сортировать такие массивы мы уже знаем (p.s. их сортировать не надо, они уже отсортированы)
4. В массиве из четырёх элементов
![Pasted image 20230103204338.png|400](/img/user/Files/Image/Pasted%20image%2020230103204338.png)
Левый массив состоит из трёх элементов, как сортировать массивы из трёх элементов мы уже знаем
5. Если можем отсортировать массив из четырёх, то можем и из пяти.
6. По этой же логике мы можем отсортировать массив из 6,7,8 и т.д. элементов.
7. Массив будет разделяться до тех пор, пока мы не прейдём к базовому случаю. К каждому массиву состоящему более чем из двух элементов применяется рекурсивная сортировка.

Данное доказательство называется [[Base/Алгоритмы/Метод математической индукции\|доказательством с помощью метода математической индукции]]

В худшем случае высота стека вызова равна **O(n)**. Он наступает тогда, когда массив уже отсортирован
![Pasted image 20230104141547.png|500](/img/user/Files/Image/Pasted%20image%2020230104141547.png)

В лучшем случае массив всегда делиться надвое. Высота стека вызова равна **O($log_2  n$)**
![Pasted image 20230104141842.png|500](/img/user/Files/Image/Pasted%20image%2020230104141842.png)

На каждом шаге сортировки мы будем обращаться к O(n) элементам независимо от размера стека
![Pasted image 20230104142618.png|550](/img/user/Files/Image/Pasted%20image%2020230104142618.png)

#Сложность_алгоритма 
Для лучшего случая:
$O(n) \times  O(log_2 n)=O(n \times log_2 \text{  } n)$

Для худшего случая:
$O(n) \times O(n)=O(n^{2})$

Для среднего случая:
Лучший случай является средним случаем
$O(n \times log_2 \text{  }n)$



