---
{"dg-publish":true,"permalink":"/base/algoritmy/stek-vyzova/"}
---


Стек (англ. stack — стопка; читается стэк) — **абстрактный тип данных, представляющий собой список элементов, организованных по принципу LIFO (англ.** **last in — first out, «последним пришёл — первым вышел»)**.

Примером стека в реальной жизни может являться стопка тарелок: когда мы хотим вытащить тарелку, мы должны снять все тарелки выше. Стопка с тарелками наполняется снизу в верх. Каждый вызов в функции помещается в стек вызова.
![1_lb-0r80YYhcnoVcQ3HY-1g.gif|450](/img/user/Files/Image/1_lb-0r80YYhcnoVcQ3HY-1g.gif)
Пример:
Стек вызова функций:
```csharp
void func2() 
{ 
	foo3(5 / 0); 
} 
void func1() 
{ 
	foo2(); 
} 
void main() 
{ 
	foo1(); 
}
```
Call stack:
1. func2
2. func
3. main

Соответственно сначала закончит выполнение функция func2, отдаст управление функции func1, а та затем отдаст управление функции main
``Во время отладки в меню **Отладка** выберите **Окна > Стек вызовов** или нажмите клавиши `ctrl`+`alt`+`C``


```csharp
        public static void greet(string name)
        {
            Console.WriteLine("hello," + name + "!");
            greet2(name);
            Console.WriteLine("getting ready to say Ьуе... ");
            bye();
        }

        public static void greet2(string name)
        {
            Console.WriteLine( "how are you, " + name + "?");
        }

        public static void bye()
        {
            Console.WriteLine("ok bye!");
        }
```

Предположим, в программе используется вызов **greet("maggie").** Сначала компьютер выделяет блок памяти для этого вызова функции.
![Pasted image 20221227175543.png](/img/user/Files/Image/Pasted%20image%2020221227175543.png)

Затем эта память используется. Переменной name присваивается значение "maggie"; оно должно быть сохранено в памяти
![Pasted image 20221227175638.png](/img/user/Files/Image/Pasted%20image%2020221227175638.png)

Каждый раз, когда вы вызываете функцию, компьютер сохраняет в памяти значение всех переменных для этого вызова. Далее выводиться приветствие **hello, maggie**, после чего следует второй вызов **greet2("maggie")**. И снова компьютер выделяет блок памяти для вызова функции.
![Pasted image 20221227175920.png](/img/user/Files/Image/Pasted%20image%2020221227175920.png)

Второй блок создаётся над первым. Вы выводите сообщение **how are you, maggie?**, после чего возвращаете управление из вызова функции. Когда это происходит, блок на вершине стека извлекается из него.
![Pasted image 20221227180112.png](/img/user/Files/Image/Pasted%20image%2020221227180112.png)

Теперь верхний блок в стеке относится к функции **greet**; это означает, что вы вернулись к функции greet. При вызове функции **greet2** функция greet ещё не бела завершена. Здесь-то и скрывается истинный смысл этого раздела:
> Когда вы вызываете функцию из другой функции, вызывающая функция приостанавливается в частично завершенном состоянии.

Все значения переменных этой функции остаются в памяти. А когда выполнение функции **greet2** будет завершено, вы вернетесь к функции greet и продолжите её выполнение с того места, где оно прервалось. Сначала выводится сообщение **geeting ready to say bye...** после чего вызывается функция bye.

![Pasted image 20221227180903.png](/img/user/Files/Image/Pasted%20image%2020221227180903.png)

Блок для этой функции добавляется на вершину стека. Далее выводится сообщение **ok bye!** с выходом из вызова функции.

![Pasted image 20221227180956.png](/img/user/Files/Image/Pasted%20image%2020221227180956.png)

Управление снова возвращается функции greet. Делать больше нечего, так что управление возвращается и из функции greet. Этот стек, в котором хранились переменные разных функций, называется стеком вызова.

Стек удобен, но у него есть своя цена: сохранение всей промежуточной информации может привести к значительным затратам памяти. Каждый вызов функции занимает немного памяти,   но если стек станет слишком высоким, это будет означать, что ваш компьютер сохраняет информацию по очень многим вызовам. Но на этой стадии есть два варианта:
1. Переписать код с использованием цикла.  
2. Иногда можно воспользоваться так называемой хвостовой рекурсией.



