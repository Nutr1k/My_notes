---
dg-publish: true
---

Поиск в ширину работает с невзвешенным графом, а алгоритм дейкстры с взвешенным.

Алгоритм дейкстры работает с _ориентированными_ (с некоторыми дополнениями и с _неориентированными_) взвешенными графами.(С положительными весовыми циклами  он тоже работает, пример 1) (Ребро ненаправленного графа тоже самое что и цикл), без отрицательных рёбер (без рёбер с отрицательным весом)

Алгоритм Дейкстры:
1. Найти узел с наименьшей стоимостью(то есть узел, до которого можно добраться за минимальное время)
2. Проверить, существует ли более дешевый путь к соседям этого узла, и если существует, обновить их стоимости и их родителя.
3. Повторить, пока это не будет сделано для всех узлов графа
4. Вычислить итоговый путь

Пример решения задачи:
Как потратить наименьшую сумму на обмены и получить пианино?
![Pasted image 20230114140222.png](/img/user/Files/Image/Pasted%20image%2020230114140222.png)

Шаг 1. Ищем узел с наименьшей стоимостью (!)

| Родитель | Узел       | Стоимость |
| -------- | ---------- | --------- |
| Книга    | Пластинка  | 5         |
| Книга    | !Постер    | 0         |
|          | Бас-гитара | ∞         |
|          | Барабан    | ∞         |
|          | Пианино    | ∞         |

Шаг 2. Вычисляем сколько времени потребуется, чтобы добраться до его соседей (?). Записываем стоимость пути только в том случае если стоимость меньше уже существующей(30 < ∞  и 35 < ∞). Записываем родителей. Назначаем Постер уже как отработанным(^)

| Родитель | Узел        | Стоимость |
| -------- | ----------- | --------- |
| Книга    | Пластинка   | 5         |
| Книга    | ^Постер     | 0         |
| Постер   | ?Бас-гитара | 0+30=30   |
| Постер   | ?Барабан    | 0+35=35   |
|          | Пианино     | ∞         |

Шаг 1. Ищем узел с наименьшей стоимостью (!). Обходя при этом уже отработанные

| Родитель | Узел       | Стоимость |
| -------- | ---------- | --------- |
| Книга    | !Пластинка | 5         |
| Книга    | ^Постер    | 0         |
| Постер   | Бас-гитара | 30        |
| Постер   | Барабан    | 35        |
|          | Пианино    | ∞         |

Шаг 2. Вычисляем сколько времени потребуется, чтобы добраться до его соседей (?). 
!Пластинка+Бас-гитара=5+15=20     20<30 => обновляем стоимость
!Пластинка+Барабан=5+2=25           25<35 => обновляем стоимость
Назначаем Пластинку уже как отработанную(^)

| Родитель  | Узел        | Стоимость |
| --------- | ----------- | --------- |
| Книга     | ^Пластинка  | 5         |
| Книга     | ^Постер     | 0         |
| Пластинка | ?Бас-гитара | 20        |
| Пластинка | ?Барабан    | 25        |
|           | Пианино     | ∞         |

Шаг 1. Ищем узел с наименьшей стоимостью (!)

| Родитель  | Узел        | Стоимость |
| --------- | ----------- | --------- |
| Книга     | ^Пластинка  | 5         |
| Книга     | ^Постер     | 0         |
| Пластинка | !Бас-гитара | 20        |
| Пластинка | Барабан     | 25        |
|           | Пианино     | ∞         |

Шаг 2. Вычисляем сколько времени потребуется, чтобы добраться до его соседей (?). 
20+20=40  40 < ∞ => обновляем стоимость
Назначаем Бас-гитару уже как отработанную(^)

| Родитель   | Узел        | Стоимость |
| ---------- | ----------- | --------- |
| Книга      | ^Пластинка  | 5         |
| Книга      | ^Постер     | 0         |
| Пластинка  | ^Бас-гитара | 20        |
| Пластинка  | ?Барабан    | 25        |
| Бас-гитара | ?Пианино    | 40        |

Шаг 1. Ищем узел с наименьшей стоимостью (!)

| Родитель   | Узел        | Стоимость |
| ---------- | ----------- | --------- |
| Книга      | ^Пластинка  | 5         |
| Книга      | ^Постер     | 0         |
| Пластинка  | ^Бас-гитара | 20        |
| Пластинка  | !Барабан    | 25        |
| Бас-гитара | Пианино     | 40        |

Шаг 2. Вычисляем сколько времени потребуется, чтобы добраться до его соседей (?). 
25+10=35  35 < 40  => обновляем стоимость

| Родитель  | Узел        | Стоимость |
| --------- | ----------- | --------- |
| Книга     | ^Пластинка  | 5         |
| Книга     | ^Постер     | 0         |
| Пластинка | ^Бас-гитара | 20        |
| Пластинка | ^Барабан    | 25        |
| Барабан   | Пианино     | 35        |

Шаг 1. Ищем узел с наименьшей стоимостью (!)

| Родитель  | Узел        | Стоимость |
| --------- | ----------- | --------- |
| Книга     | ^Пластинка  | 5         |
| Книга     | ^Постер     | 0         |
| Пластинка | ^Бас-гитара | 20        |
| Пластинка | ^Барабан    | 25        |
| Барабан   | !Пианино    | 35        |

Шаг 2. Вычисляем сколько времени потребуется, чтобы добраться до его соседей (?). 
Т.к. у Пианино нет соседей назначим его уже как отработанное

| Родитель  | Узел        | Стоимость |
| --------- | ----------- | --------- |
| Книга     | ^Пластинка  | 5         |
| Книга     | ^Постер     | 0         |
| Пластинка | ^Бас-гитара | 20        |
| Пластинка | ^Барабан    | 25        |
| Барабан   | ^Пианино    | 35        |

Цифра стоящая напротив узла Пианино и будет стоимостью самого короткого пути 35

![Pasted image 20230125200930.png](/img/user/Files/Image/Pasted%20image%2020230125200930.png)

В Пианино мы пришли из Барабана, в Барабан из Пластинки, в Пластинку из Книги.

```csharp
	public static string find_lowest_cost_node(Dictionary<string, double> costs, List<string> processed)// узел с наименьшей стоимостью
	{
		string lowest_cost_node=null;

		double lowest_cost = Double.PositiveInfinity;

		foreach(string node in costs.Keys)
		{
			double cost = costs[node];

			if(cost<lowest_cost && !processed.Contains(node))
			{
				lowest_cost = cost;
				lowest_cost_node = node;
			}
		}
		return lowest_cost_node;
	}

	public static Tuple<List<string>,double> Dijkstra(Dictionary<string, Dictionary<string, int>> graph, Dictionary<string, double> costs, Dictionary<string, string> parents,string start,string end)
	{
		List<string> processed = new List<string>();//Обработанные узлы

		string node = find_lowest_cost_node(costs, processed);

		while (!node.Equals(end))
		{
			double cost = costs[node];
			Dictionary<string, int> neighbors = graph[node];

			foreach (string n in neighbors.Keys)
			{
				double new_cost = cost + neighbors[n];
				if (costs[n] > new_cost)
				{
					costs[n] = new_cost;
					parents[n] = node;
				}
			}
			processed.Add(node);
			node = find_lowest_cost_node(costs, processed);
		}

		List<string> shortPath = new List<string>();

		string current = end;

		while (!current.Equals(start))
		{
			shortPath.Add(current);
			current = parents[current];
		}
		
		shortPath.Add(start);

		shortPath.Reverse();

		return Tuple.Create(shortPath,costs[end]);
	}
```

Использование
```csharp
	Dictionary<string, Dictionary<string, int>> graph2 = new Dictionary<string, Dictionary<string, int>>();//Граф

	graph2["Книга"] = new Dictionary<string, int> { { "Редкая пластинка", 5 }, { "Постер", 0 } };
	
	graph2["Редкая пластинка"] = new Dictionary<string, int> { { "Бас-гитара", 15 },{ "Барабан",20 } };
	
	graph2["Постер"] = new Dictionary<string, int> { { "Бас-гитара", 30 }, { "Барабан", 35 } };
	
	graph2["Бас-гитара"] = new Dictionary<string, int> { { "Пианино", 20 } };
	graph2["Барабан"] = new Dictionary<string, int> { { "Пианино", 10 } };
	graph2["Пианино"] = new Dictionary<string, int> { };

	
	Dictionary<string, double> costs2 = new Dictionary<string, double>();//Стоимость

	costs2["Редкая пластинка"] = 5;
	costs2["Постер"] = 0;
	costs2["Бас-гитара"] = Double.PositiveInfinity; ;
	costs2["Барабан"] = Double.PositiveInfinity; ;
	costs2["Пианино"] = Double.PositiveInfinity; ;

	Dictionary<string, string> parents2 = new Dictionary<string, string>();//Родители

	parents2["Редкая пластинка"] = "Книга";
	parents2["Постер"] = "Книга";
	parents2["Бас-гитара"] = "" ;
	parents2["Барабан"] = "";
	parents2["Пианино"] = "";


	var res=Dijkstra(graph2, costs2, parents2,"Книга","Барабан");
```


Пример 1. Алгоритм дейкстры будет работать с графом в котором есть цикл
![Pasted image 20230114165743.png](/img/user/Files/Image/Pasted%20image%2020230114165743.png)



### Ребра с отрицательным весом

![Pasted image 20230114171257.png](/img/user/Files/Image/Pasted%20image%2020230114171257.png)

Шаг 1. Ищем узел с наименьшей стоимостью (!)

| Родитель | Узел       | Стоимость |
| -------- | ---------- | --------- |
| Книга    | Пластинка  | 5         |
| Книга    | !Постер    | 0         |
|          | Барабан    | ∞         |

Шаг 2. Вычисляем сколько времени потребуется, чтобы добраться до его соседей (?). 
!Постер+Барабан=0+35=35     35<∞ => обновляем стоимость

Назначаем Постер уже как отработанный(^)

| Родитель | Узел      | Стоимость |
| -------- | --------- | --------- |
| Книга    | Пластинка | 5         |
| Книга    | ^Постер   | 0         |
| Постер   | ?Барабан  | 0+35=35   |

Шаг 1. Ищем узел с наименьшей стоимостью (!)

| Родитель | Узел       | Стоимость |
| -------- | ---------- | --------- |
| Книга    | !Пластинка | 5         |
| Книга    | ^Постер    | 0         |
| Постер   | Барабан    | 35        |

Шаг 2. Вычисляем сколько времени потребуется, чтобы добраться до его соседей (?). 
!Пластинка+Постер=5-7=-2     -2 <∞ => обновляем стоимость. 

>Однако узел Постер уже был обработать(^), однако мы обновляем его стоимость. Это очень тревожный знак

**Обработка узла означает, что к нему невозможно добраться с меньшими затратами**

| Родитель | Узел       | Стоимость |
| -------- | ---------- | --------- |
| Книга    | !Пластинка | 5         |
| Книга    | ^Постер    | 5-7=-2    |
| Постер   | Барабан    | 35        |

Алгоритм дейкстры завершает работу и выдаёт ответ 35, хотя мы знаем что к Барабану можно добраться за 33 (Книга->Пластинка->Постер->Барабан)

**Алгоритм Дейкстры не предназначен для графов с отрицательными весами рёбер**

#Сложность_алгоритма 
В этом реализации алгоритма Дейкстры, сложность функции find_lowest_cost_node() составляет O(V) по проходу по всем вершинам графа. И в цикле while, который выполняется V раз, сложность в сумме составляет O(V^2). Кроме того, сложность обновления стоимости ребер и сложность добавления родителя к каждому соседнему узлу составляет O(E) по количеству ребер в графе.

В целом, сложность алгоритма составляет O(E + V^2)

### Почему он жадный?
Алгоритм Дейкстры поддерживает приоритетную очередь вершин, чьи веса кратчайшего пути из исходной вершины находятся в постоянном движении. На каждом шаге он выбирает и удаляет из приоритетной очереди вершину с наименьшим весом. Теперь вес кратчайшего пути этой вершины является окончательным, а ребра, выходящие из этой вершины, расслаблены. Ослабления могут изменить веса кратчайшего пути соседей, которые все еще находятся в очереди приоритетов. Любые соседи, не находящиеся в приоритетной очереди, имеют свои окончательные веса кратчайшего пути, и входящие в них расслабляющие ребра не изменят их веса.

Таким образом, жадный аспект возникает из-за того, что всегда выбирается вершина в очереди приоритетов с наименьшим весом кратчайшего пути.

Это жадно, потому что вы всегда отмечаете ближайшую вершину. Он динамичен, потому что расстояния обновляются с использованием ранее рассчитанных значений.