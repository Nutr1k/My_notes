---
{"dg-publish":true,"permalink":"/base/algoritmy/struktury-dannyh/"}
---


### 1. Массив
Поддерживают произвольный доступ
При использовании массива все значения хранятся в памяти друг за другом, при чём они должны быть одного типа. Массив заранее резервирует область памяти(подобна клетка на тетрадном листе).
```csharp
int[] mass=new int[3];
```

**Вставка.**
Если вы захотели в массив размером 3 вставить 4 элемент, а в массиве по правилу все элементы идут друг за другом, то прийдётся искать новую область памяти где свободны 4 ячейки. И вставлять их туда. 
![Pasted image 20221221171642.png](/img/user/Files/Image/Pasted%20image%2020221221171642.png)

Вот так вот получиться при вставке нового элемента в массив с размером 3
![Pasted image 20221221172112.png](/img/user/Files/Image/Pasted%20image%2020221221172112.png)

Может повести если после массива есть свободные ячейки и мы обойдёмся лишь сдвигом

**Удаление.**
В массиве при удалении все последующие элементы нужно будет сдвинуть вверх. По сути область памяти правильно рассматривать не как горизонталь, а как вертикаль.

**Чтение.**
Т.к. каждый элемент расположен друг за другом, то без проблем можно обращаться напрямую к любому элементу массива. Если адрес первого элемента 00, то адрес пятого элемента 04, обычная математика.
Массивы прекрасно подходят для чтения в произвольном порядке
![Pasted image 20221221202344.png](/img/user/Files/Image/Pasted%20image%2020221221202344.png)

### 2. Связанные списки
Поддерживают только последовательный доступ
При использовании связанного списка элементы могут размещаться где угодно(порядок не важен). Каждый элемент хранит адрес следующего элемента.
```csharp
LinkedList<int> link = new LinkedList<int>();
```

![Pasted image 20221221173102.png](/img/user/Files/Image/Pasted%20image%2020221221173102.png)

![Pasted image 20221221173121.png](/img/user/Files/Image/Pasted%20image%2020221221173121.png)

**Вставка.**
Для вставки нужно всего лишь изменить указатель в предыдущем элементе.
![Pasted image 20221221202902.png](/img/user/Files/Image/Pasted%20image%2020221221202902.png)

**Удаление.**
Для удаления нужно всего лишь изменить указатель в предыдущем элементе.

Как в кино(5 человек):
Если вы были бы массивом, то могли занимать свободные места идущие только подряд и если бы вы к примеру не нашли 5 идущих мест подряд, то вам бы пришло уйти с кинотеатра, а были бы вы связанным списком вы бы могли занимать абсолютно любые свободные места, с условием чтобы каждый человек знал где сидит следующий 1 его друг.

**Чтение.**
Чтобы, получить какой-либо элемент связанного списка нужно, пройти всю цепочку от начала до этого самого элемента. К примеру, что бы получить "Тренировки" надо получить "Обед" и в нём будет храниться адрес следующего элемента, в нашем случае "Тренировки".
То есть, чтобы получить последний элемент связанного списка, вы должны обратиться к 1, от него узнать адрес 2, от него 3 и т.д. пока не дойдёте до последнего.

Быстродействие

|            | Массивы   | Связанные Списки   |
|:----------:|:---------:|:------------------:|
| Чтение     | O(1)      | O(n)               |
| Вставка    | O(n)      | O(1)               |
| Удаление   | O(n)      | O(1)               |

### 3. Хеш-таблицы 
**Хеш-таблица** — это структура данных, в которой все элементы хранятся в виде пары ключ-значение, где ключ задаётся хеш-функцие. Хеш-таблицы используют массив для хранения данных. 
Хеш-таблица=хеш-функция+массив
Хеш-функция для хеш-таблиц преобразует сроку в индекс массива.
Хеш-таблицы нашли своё применение в: телефонных книгах, кэширование(веб страниц), DNS
```csharp
        Hashtable ht = new Hashtable();
        ht.Add("milk", 32.5);

        Dictionary<string, double> dt = new Dictionary<string, double>();
        dt.Add("milk", 32.5);
```
Hashtable - необобщенная хеш-таблица
Dictionary - обобщённая хеш-таблица основанная на Hashtable
[Различия Hashtable и Dictionary 1](https://ru.stackoverflow.com/questions/894695/%D0%A5%D0%B5%D1%88-%D1%82%D0%B0%D0%B1%D0%BB%D0%B8%D1%86%D0%B0-hashtable-%D0%BD%D0%B0-%D1%8F%D0%B7%D1%8B%D0%BA%D0%B5-c-%D0%94%D0%BB%D1%8F-%D1%87%D0%B5%D0%B3%D0%BE-%D0%BE%D0%BD%D0%B0)
[Различия Hashtable и Dictionary 2](https://stackoverflow.com/questions/301371/why-is-dictionary-preferred-over-hashtable-in-c)

Хеш-таблицы основа на хеш-функциях

Хеш-функция представляет собой функцию которая на вход получает строк(последовательность байтов) и возвращает уникальную строку фиксированной длины состоящую из букв и цифр.

Результат, производимый хеш-функцией, называется «хеш-суммой» или же просто «хешем», а входные данные часто называют «сообщением».

Хеш-функция должна быть последовательной. К примеру мы передаём её строку "апельсины" и получили "c67aa0". Это значит, что каждый раз в будущем, передавая её строку "апельсины" мы будем получать "c67aa0".

Но бывают случаю что двум разных входным сообщениям выдаются одинаковые хешы. Это называется Коллизией.

>Коллизия хеш-функции — это **когда у двух разных входных элементов таблицы hash будет одинаковым**

Хорошая хеш-функция создаёт малое число колизий.
Размер массива влияет на хеш-функцию, точнее сначала хеш-функция выдаёт результат, а потом в дело вступает метод преобразовывающий этот результат до размера массива

Хеширование состоит из двух частей: хеш-функции и функции сжатия. Изменение размера хеш-таблицы изменит функцию сжатия, что приведет к тому, что ключи будут распределены по разным сегментам.

<details>
<summary>Java</summary>

Например, в HashMap до Java 8 использовался вот такой дополнительный метод для нахождения нужной ячейки:

Стоит отметить, что полученный хеш-код может быть огромным числовым значением, а исходный массив условно рассчитан только на 16 элементов. Не создавать же массив на миллиард элементов, чтобы добавить туда всего десять? Поэтому мы этот хеш-код должны как-то трансформировать в значения от 0 до 15 (если размер массива 16). И вот для этого используются дополнительные преобразования. Таким образом, мы генерируем индекс для минимизации размера массива.

```java
static int indexFor(int h, int length) 
{         
	return h & (length-1);
}
```

Пример хеш-функции DJB2(python)
```py
def _hash_djb2(size, s):
        hash = 5381
        for x in s:
            hash = ((hash << 5) + hash) + ord(x)
            print(hash)
            print(hash % size)
        return hash % size
```

**В функции сжатия часто используется принцип того, что остаток от деления не может быть больше делителя**=> **мы можем любой хеш делить на размер массива и быть уверенными, что результирующий индекс будет лежать в границах нашего массива**

</details>
На вход он принимал хеш-код полученный в результате работы `hashCode()` и длину внутреннего массива (количество ячеек). А возвращал результат «хеш-код» –> побитовое «И» –> (длина массива – 1).

[java](https://javarush.com/groups/posts/2496-podrobnihy-razbor-klassa-hashmap)

Хеширование состоит из двух частей: хеш-функции и функции сжатия. Изменение размера хеш-таблицы изменит функцию сжатия, что приведет к тому, что ключи будут распределены по разным сегментам.

Способы борьбы с коллизией бывают разными. К примеру если несколько ключей отображаются на один элемент, то в этом элементе создаётся связанных список.

Пример: Апельсинам и авокадо хеш-функция назначила один ключ. Создался связанный список
![Pasted image 20230105173448.png](/img/user/Files/Image/Pasted%20image%2020230105173448.png)

Быстродействие Хеш-таблиц

|            | Средний случай   | Худший случай      |
|:----------:|:----------------:|:------------------:|
|  Поиск     | O(1)             | O(n)               |
| Вставка    | O(1)             | O(n)               |
| Удаление   | O(1)             | O(n)               |

Время O(1) называется постоянным. Оно не означает, что операция выполняются мгновенно, просто время остается постоянным независимо от размера хеш-таблицы.
В худшем случае все операции с хеш-таблицей выполняются за время O(n) (линейное время), а это очень медленно.

Сравним хеш-таблицы с массивами и свящанными списками.

|          | Хеш-таблицы<br>(Средний случай) | Хеш-таблицы<br>(Худший случай) | Массивы | Связанные<br>Списки |
|:--------:|:-------------------------------:|:------------------------------:|:-------:|:-------------------:|
|   Поиск  |               O(1)              |              O(n)              |   O(1)  |         O(n)        |
|  Вставка |               O(1)              |              O(n)              |   O(n)  |         O(1)        |
| Удаление |               O(1)              |              O(n)              |   O(n)  |         O(1)        |

Взгляните на средний случай для хеш-таблиц. При поиске хеш-таблицы не уступают в скорости массивам (получение значения по индексу). А при вставке и удалении они так же быстры, как и связанные списки. Получается, что они взяли лучшее от обеих структур! Но в худшем случае хеш таблицы медленно выполняют все эти операции, поэтому очень важно избегать худшего случая быстродействия при работе с хеш-таблицами. А для этого следует избегать коллизий. Для предотвращения коллизий необходимы: 
1. низкий коэффициент заполнения; 
2. хорошая хеш-функция.

На вопрос почему в худшем случае вставка и удаление выполняются за время O(n), хотя в худшем случае создаётся связанных список, а в нём вставка и удаление выполняются за O(1).

Ответ таков:

При вставке элемента в связанный список будет сначала совершён поиск по существующим элементам в списке, если значение найдено то оно обновляется, если нет, к списку добавляется новый узел. Поиск как мы знаем занимает времени **O(n)**. Если мы хотим линейное время вставки O(1), то можно разрешить дубликаты.

В обоих случаях вставка все еще может быть реализована как `Θ(1)`, так как вы можете просто вставить в начало цепочки. То есть, если мы разрешаем дубликаты, потому что, если нет, мы сначала должны проверить, есть ли они уже (т.е. выполнить поиск).

Худший случай происходит, когда все элементы хешируются до одного и того же значения, поэтому у вас будет одна очень длинная цепочка, по сути превращающая вашу структуру данных в связанный список.

Удаление: просматривается весь список, и в худшем случае удаляемый элемент находится в самом последнем узле последнего.

[StackOverflow](https://stackoverflow.com/questions/20251023/whats-the-worst-case-running-time-of-hashing-with-chaining)
[Opengenus](https://iq.opengenus.org/time-complexity-of-hash-table/)

**Коэффициент заполнения**

Коэффициент заполнения хеш-таблицы вычисляется по простой формуле: 
##### $$\frac{число \text{ } хранимых \text{ } элементов}{размер массива \text{ } (число\text{ } возможных \text{ } значений \text{ }хеш-функции)}$$
$$или$$

##### $$\frac{количество \text{ } элементов \text{ } в \text{ } хеш-таблице}{общее \text{ } количество \text{ } элементов }$$

В данной хеш-таблице коэффициент заполнения равен 0,4
![Pasted image 20230106191226.png](/img/user/Files/Image/Pasted%20image%2020230106191226.png)

К примеру в хеш-таблице нужно сохранить цены 100 товаров и хеш-таблица состоит из 100 элементов. В лучшем случае каждому товару будет выделен отдельный элемент. Коэффициент заполнения равен 1.

Если хеш-таблица состоит из 50 элементов, а в неё добавляют 100, то тогда коэффициент заполнения будет равен 2. Выделить под каждый товар отдельный элемент ни при каких условиях не удастся.

С ростом коэффициента заполнения в хеш-таблицу приходиться добавлять новые элементы, то есть изменять её размер(расширять). Когда коэффициент заполнения больше 0,7 создаётся массив в двое большего размера. Теперь все старые элементы необходимо перехешировать и вставить в новую хеш-таблицу.

На изменение размеров хеш-таблицы уходит много времени и ресурсов и оно не должно происходить очень часто.


### 4. Множество
{ #ee8cf6}


Множество C# — Set C# — это структура данных, представляющая собой не организованный набор уникальных элементов одного типа.
{ #f68b4e}


```csharp
HashSet<int> set = new HashSet<int> { 1,2,2,3,3,4};
//Console.WriteLine()
//1,2,3,4
```

