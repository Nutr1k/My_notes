---
{"dg-publish":true,"permalink":"/base/clr-via-c-sharp/osnovy-clr/jit-kompilyator/"}
---


JIT-компилятор(Just-In-Time) - преобразование IL кода в машинные команды(в собственные команды процессора) непосредственно во время работы программы.

Вместо компиляции всего приложения , **JIT** (Just-In-Time) компилятор просто компилирует каждую порцию кода при вызове. Если промежуточный код однажды скомпилирован, то результирующий машинный исполняемый код сохраняется до момента завершения работы приложения, поэтому его перекомпиляция при повторных обращениях к нему не требуется.

Первый вызов метода
![Pasted image 20230131173615.png](/img/user/Files/Image/Pasted%20image%2020230131173615.png)

#### Работа JIT-компилятора:
{ #6f054d}


Функции JITCompiler известен вызываемый метод и тип, в котором он определен. JITCompiler ищет в метаданных соответствующей сборки IL-код вызываемого метода. Затем JITCompiler проверяет и компилирует IL-код в машинные команды, которые сохраняются в динамически выделенном блоке памяти. После этого JITCompiler возвращается к структуре внутренних данных типа, созданной средой _CLR_, и заменяет адрес вызываемого метода адресом блока памяти, содержащего готовые машинные команды. В завершение JITCompiler передает управление коду в этом блоке памяти. Этот программный код является реализацией метода WriteLine (вариант этого метода с параметром String). Из этого метода управление возвращается в метод Main, который продолжает выполнение в обычном порядке.

Повторный вызов:
![Pasted image 20230131174644.png](/img/user/Files/Image/Pasted%20image%2020230131174644.png)

При повторном обращении метода Main к WriteLine не происходит вызова JITCompiler т.к. код метода WriteLine уже проверен и скомпилирован, так что обращение к блоку памяти производится напрямую.

>Снижение производительности наблюдается только при первом вызове метода. Все последующие обращения выполняются «на максимальной скорости», потому что повторная верификация и компиляция не производятся.


Если JIT-компилятор не обеспечивает вашему приложению необходимого уровня производительности, можно воспользоваться NGen.exe из пакета .NET Framework SDK. Эта утилита компилирует весь IL-код сборки в машинный код и сохраняет его в файле на диске. В момент выполнения при загрузке сборки CLR автоматически проверяет, существует ли заранее откомпилированная версия сборки, и если существует — загружает ее, так что компиляция во время выполнения уже не требуется.

Компиляция исходно кода высокоуровневого языка программирования в IL код - Компиляция IL кода во время выполнения JIT-компилятором в машинный код(собственные команды процессора).


### Возможности повышения проиводительности упр. кода по сравнению с неуправляемым:

1.  JIT-компилятор может определить на каком процессоре выполянется приложение и использовать его специальные команды для повышения эффективности
2.  JIT-компилятор может определить, что некоторое условие на том компьютере, на котором он выполняется, всегда оказывается ложным
3.  CLR может профилировать выполняемую программу и перекомпилировать IL в машинный код в процессе выполнения. Перекомпилированный код реорганизуется для сокращения ошибочного прогнозирования переходов на основании наблюдаемых закономерностей выполнения.


### Java
JVM использует специализированный JIT-компилятор HotSpot для компиляции байт-кода (аналог IL кода) Java в машинный код. Этот метод компилирует «горячие точки» в коде, который фактически будет использоваться, чтобы предотвратить длительное время компиляции во время выполнения.

[Java](https://www.overops.com/blog/clr-vs-jvm-how-the-battle-between-net-and-java-extends-to-the-vm-level/)