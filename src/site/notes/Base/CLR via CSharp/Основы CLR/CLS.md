---
dg-publish: true
---

CLS (Common Language Specification, Общеязыковые спецификации) - спецификация, в которой перечислен минимальный набор возможностей, которые должны поддерживаться компиляторами для генерирования типов, совместимх с другими компонентами, написанными на CLS-совместимых языках на базе CLR. Во многих отношениях CLS может считаться просто подмножеством всех функциональных возможностей, определенных в CTS.

> То есть CLS определяет правила, которым должны соответствовать типы и методы с внешней видимостью (приватная реализация может использовать все возможности языка, даже те, которые не поддерживает CLS совместимый язык), для того чтобы они могли использоваться в любом CLS-совместимом языке программирования. То есть это тот минимум который должен быть реализовать в любом CLR совместимом компиляторе.

 \- правила CLS не распространяются на код, доступный только в определяющей сборке

Спецификация CLS является подмножеством системы CTS.В спецификации CLS определён набор правил и ограничений, которым должен следовать каждый язык, который выполняется в рамках . NET.
1. Правило CLS 1. Правила CLS применяются только к тем частям типа, которые доступны или видны снаружи определяющей сборки.
2. CLS Правило 2: Члены типов, несовместимых с CLS, не должны быть помечены как совместимые с CLS.
3. CLS Правило 3: Boxed value types не совместимы с CLS.
4. Правило CLS 48: Если два или более CLS-совместимых метода, объявленных в типе, имеют одинаковое имя и для определенного набора экземпляров типа они имеют одинаковые параметры и возвращаемые типы, то все эти методы должны быть семантически эквивалентны в этих экземплярах типа.
5. Правило 5 CLS: все имена, представленные в области, совместимой с CLS, должны различаться независимо от типа, за исключением случаев, когда имена идентичны и разрешаются путем перегрузки. То есть, в, то время как CTS позволяет одному типу использовать одно и то же имя для метода и поля, CLS этого не делает.
6. Правило 6 CLS: Поля и вложенные типы должны различаться только сравнением идентификаторов, даже если CTS позволяет различать отдельные подписи. Методы, свойства и события с одинаковыми именами (при сравнении идентификаторов) должны различаться не только типом возвращаемого значения, за исключением случаев, указанных в правиле CLS 39.

### Упрощённый вид правил CLS
В CLR каждый член типа является либо полем (данные), либо методом (поведение).Это означает, что каждый язык программирования должен уметь обращаться к полям и вызывать методы.

Для упрощения программирование сделана некая абстракция в виде массива, свойств, индексаторов, делегатов, событий, конструкторов, финализаторов, перегрузок операторов и т.д. В конечном итоге когда компилятор встречает эти абстракции, он должен преобразовать их в поля и методы, чтобы сделать их доступными для CLR и любых других языков программирования.

Вот во что преобразуется публичное свойство result:
```csharp
    class Calculator
    {
        public int result { get; set; }
    }
```

![Pasted image 20230201194601.png](/img/user/Files/Image/Pasted%20image%2020230201194601.png)
Оно преобразуется в приватное поле и в два метода get_result и set_result
Реализация приватного поля и двух методов на IL:
![Pasted image 20230201195914.png](/img/user/Files/Image/Pasted%20image%2020230201195914.png)

Как C# интерпретирует IL код:
![Pasted image 20230201200032.png](/img/user/Files/Image/Pasted%20image%2020230201200032.png)

Пример компиляции кода содержащего: конструктор, финализатор, перегруженные операторы, свойство, индексатор и событие.

```csharp
internal sealed class Test
{
	// Конструктор
	public Test() { }

	// Финализатор
	~Test() { }

	// Перегрузка оператора
	public static Boolean operator ==(Test t1, Test t2)
	{
		return true;
	}
	public static Boolean operator !=(Test t1, Test t2)
	{
		return false;
	}

	// Перегрузка оператора
	public static Test operator +(Test t1, Test t2) { return null; }
	// Свойство
	public String AProperty
	{
		get { return null; }
		set { }
	}

	// Индексатор
	public String this[Int32 x]
	{
		get { return null; }
		set { }
	}

	// Событие
	public event EventHandler AnEvent;
}
```
Результатом компиляции этого кода явяется тип, содержащий набор полей и методов:
![Pasted image 20230201201456.png](/img/user/Files/Image/Pasted%20image%2020230201201456.png)

Соответствие между конструкциями языка программирования и эквивалентными полями/методами CLR:
![Pasted image 20230201201831.png](/img/user/Files/Image/Pasted%20image%2020230201201831.png)


Значение иконок:
![Pasted image 20230201200111.png](/img/user/Files/Image/Pasted%20image%2020230201200111.png)




![Pasted image 20230201193645.png](/img/user/Files/Image/Pasted%20image%2020230201193645.png)

