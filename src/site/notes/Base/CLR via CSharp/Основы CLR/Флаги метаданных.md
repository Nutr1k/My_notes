---
dg-publish: true
---

### Hidebysig

CTS обеспечивает независимый контроль как над именами, видимыми из базового типа (скрытие, hiding), так и над совместным использованием слотов макета в производном классе (переопределение, overriding). Скрытие управляется путем пометки члена в производном классе либо как <span class="R">скрытого по имени</span>, либо как <span class="G"> скрытого по имени и сигнатуре</span>.Скрытие всегда выполняется на основе типа члена, то есть производные имена полей могут скрывать имена базовых полей, но не имена методов, имена свойств или имена событий. 

Если производный член помечен как <span class="R">скрытый по имени</span>, то члены того же типа в базовом классе с тем же именем не видны в производном классе;

Если член помечен как <span class="G">скрытый по имени и сигнатуре</span>, то только член того же типа с точно таким же именем и типом (для полей) или сигнатурой метода (для методов) скрыт от производного класса.

Реализация различия между этими двумя формами сокрытия полностью обеспечивается компиляторами исходного языка и библиотекой отражения; это не имеет прямого влияния на саму VES.

Hidebysig - означает <span class="G">«скрыть по имени и сигнатуре»</span>

hidebysig предоставляется для использования инструментов и игнорируется VES. Он указывает, что объявленный метод скрывает все методы типов базового класса, которые имеют совпадающую сигнатуру метода; если он опущен, метод должен скрывать все методы с тем же именем, независимо от сигнатуре.

HideBySig 0x0080 Метод <span class="G">скрывает по имени+сиг</span>, иначе только <span class="R">по имени</span>.


```csharp
public class Base
{
    public void Bar()
    {
    }
}

public class Derived : Base
{
    public void Bar(string x)
    {
    }
}

...

Derived d = new Derived();
d.Bar();
```

Это верно, потому `Bar(string)` _ не_ скрывает `Bar()`, потому что компилятор C# использует `hidebysig`. Если бы он использовал семантику <span class="R">«скрыть по имени»</span>, вы бы вообще не смогли вызвать метод `Bar()` ссылку типа `Derived`, хотя вы все равно могли бы привести ее к Base и назвать ее таким образом.


Удалим Флаг `hidebysig` и скомпилируем с помощью [[Base/CLR via CSharp/Основы CLR/Изменение IL кода\|инструкции]]
![Pasted image 20230203163041.png](/img/user/Files/Image/Pasted%20image%2020230203163041.png)

Теперь данный код не компилируется:
![Pasted image 20230203163235.png](/img/user/Files/Image/Pasted%20image%2020230203163235.png)

Т.к. метода **Bar** класса _Derived_ использует <span class="R">сокрытие по имени</span> то, члены базового класса с тем же именем не видны в производном классе. На сокрытие по имени влияет только имя.

### Конструктор .ctor
![Pasted image 20230217173043.png](/img/user/Files/Image/Pasted%20image%2020230217173043.png)

Базовый конструктор(конструктор без параметров) добавляется средой CLR ко всем типам.
