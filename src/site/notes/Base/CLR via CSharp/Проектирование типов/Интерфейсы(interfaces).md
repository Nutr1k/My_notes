---
{"dg-publish":true,"permalink":"/base/clr-via-c-sharp/proektirovanie-tipov/interfejsy-interfaces/"}
---


Интерфейс представляет собой **контракт** набор сигнатур методов.  Любой реализующий этот контракт, должен предоставлять реализацию для членов, определенных в интерфейсе.

В соответствии с соглашением имена интерфейсных типов начинаются с прописной буквы I, что облегчает их поиск в исходном коде

В интерфейсах можно определять методы, события, свойства, индексаторы, статические поля и константы

Многие языки программирования поддерживают **множественное наследование (multiple inheritance)** - возможность определения класса, производного от двух и более классов. Однако CLR, а значит все основанные на этой среде языки программирования множественное наследование не поддерживают.


> [!success] Ограниченное множественное наследование
> Однако CLR позволяет реализовывать **ограниченное множественное наследование** через интерфейсы. 

С точки зрения CLR, определение интерфейса — почти то же, что и определение типа. То есть CLR определяет внутреннюю структуру данных для объекта интерфейсного типа, а для обращения к различным членам интерфейса может использовать отражение.

Определение интерфейса может «наследовать» другие интерфейсы. Однако слово «наследовать» не совсем точное, поскольку в интерфейсах наследование работает иначе, чем в классах. Я предпочитаю рассматривать наследование интерфейсов как включение контрактов других интерфейсов. Например, определение интерфейса TCollection включает контракт интерфейсов TEnumerable и IEnumerable.


#### Внутренняя реализация интерфейсов
Компилятор C# требует, чтобы метод, реализующий интерфейс, отмечался модификатором public. CLR требует, чтобы интерфейсные методы были виртуальными.

Если метод **явно не определен** в коде как **виртуальный**, компилятор сделает его **таковым** и, вдобавок, **запечатанным**. Это не позволяет производному классу переопределять интерфейсные методы. 

То есть если класс реализует метод интерфейса таким образом:

```csharp
//Интерфейс определенный в пространстве имен **System**
public interface IDisposable
{
	void Dispose();
}

internal class Base : IDisposable
{
	// Этот метод неявно запечатан и его нельзя переопределить
	public void Dispose()
	{
		Console.WriteLine("Base's Dispose");
	}
}
```
То компилятор сделает его виртуальным запечатанным методом.
![Pasted image 20230529172207.png](/img/user/Files/Image/Pasted%20image%2020230529172207.png)

Если явно задать метод как **виртуальный**, компилятор сделает его **таковым** и оставит **незапечатанным**, что предоставит производному классу возможность переопределять интерфейсные методы.

То есть если класс реализует метод интерфейса таким образом:

```csharp
//Интерфейс определенный в пространстве имен **System**
public interface IDisposable
{
	void Dispose();
}

internal class Base : IDisposable
{
	// Этот метод неявно запечатан и его нельзя переопределить
	public virual void Dispose()
	{
		Console.WriteLine("Base's Dispose");
	}
}
```
То компилятор сделает его [[Base/CLR via CSharp/Проектирование типов/Вызов виртуальных методов, свойств и событий в CLR.\|виртуальным незапечатанным методом]] .
![Pasted image 20230529172408.png](/img/user/Files/Image/Pasted%20image%2020230529172408.png)


#### Вызов интерфейсного метода
При вызове интерфейсного метода объекта вызывается реализация, связанная с объект-типом 

```csharp
// Этот класс является производным от Object и реализует IDisposable
internal class Base : IDisposable
{
	// Этот метод неявно запечатан и его нельзя переопределить
	public void Dispose()
	{
		Console.WriteLine("Base's Dispose");
	}
}

// Этот класс наследует от Base и повторно реализует IDisposable
internal class Derived : Base, IDisposable
{
	// Этот метод не может переопределить Dispose из Base.
	// Ключевое слово 'new' указывает на то, что этот метод
	// повторно реализует метод Dispose интерфейса IDisposable
	new public void Dispose()
	{
		Console.WriteLine("Derived's Dispose");
		// ПРИМЕЧАНИЕ: следующая строка кода показывает,
		// как вызвать реализацию базового класса (если нужно)
		// base.Dispose();
	}
}

public static void Main()
{
	/************************* Первый пример *************************/
	Base b = new Base();
	// Вызов реализации Dispose в типе b: "Dispose класса Base"
	b.Dispose();
	// Вызов реализации Dispose в типе объекта b: "Dispose класса Base"
	((IDisposable)b).Dispose();
	
	/************************* Второй пример ************************/
	Derived d = new Derived();
	// Вызов реализации Dispose в типе d: "Dispose класса Derived"
	d.Dispose();
	// Вызов реализации Dispose в типе объекта d: "Dispose класса Derived"
	((IDisposable)d).Dispose();
	
	/************************* Третий пример *************************/
	//Тут происходит Upcasting
	b = new Derived();
	// Вызов реализации Dispose в типе b: "Dispose класса Base". Т.к. при приведении ссылки производного 
	// типа к базовому ему доступны только те члены, которые определены в базовом класс
	b.Dispose();
	
	// Вызов реализации Dispose в типе объекта b: "Dispose класса Derived". Т.к. при Upcasting к типу 
	// интерфейса доступны только те методы, которые определены в самом интерфейсе, а т.к. b указывает на 
	//объект Derived, а он в свою очеред на объект-тип Derived то, вызывается реализация метода из Derived
	((IDisposable)b).Dispose();
}
```

#### Подробнее о вызовах интерфейсных методов

Тип System.String из библиотеки FCL наследует сигнатуры и реализации методов System.Object. Кроме того, тип String реализует несколько интерфейсов: IComparable, ICloneable, IConvertible, IEnumerable, IComparable, IEnumerable и IEquatable. Это значит, что типу String не требуется реализовывать (или переопределять) методы, имеющиеся в его базовом типе Object. Однако тип String должен реализовывать методы, объявленные во всех интерфейсах.

##### Код:
```csharp
public static void Main()
{
	//1.
	// Переменная s ссылается на объект String
	String s = "Jeffrey";
	// Используя переменную s, можно вызывать любой метод,
	// определенный в String, Object, IComparable, ICloneable,
	// IConvertible, IEnumerable и т. д.
	
	//2.
	// Переменная cloneable ссылается на тот же объект String
	ICloneable cloneable = s;
	// Используя переменную cloneable, я могу вызвать любой метод,
	// объявленный только в интерфейсе ICloneable (или любой метод,
	// определенный в типе Object)

	//3.
	// Переменная comparable ссылается на тот же объект String
	IComparable comparable = s;
	// Используя переменную comparable, я могу вызвать любой метод,
	// объявленный только в интерфейсе IComparable (или любой метод,
	// определенный в типе Object)
	
	//4.
	// Переменная enumerable ссылается на тот же объект String
	// Во время выполнения можно приводить интерфейсную переменную
	// к интерфейсу другого типа, если тип объекта реализует оба интерфейса
	IEnumerable enumerable = (IEnumerable)comparable;
	// Используя переменную enumerable, я могу вызывать любой метод,
	// объявленный только в интерфейсе IEnumerable (или любой метод,
	// определенный только в типе Object)
}
```

Все переменные в этом коде ссылаются на один объект String в управляемой куче, а значит, любой метод, который я вызываю с использованием любой из этих переменных, задействует один объект String, хранящий строку "Jeffrey". Но **тип переменной определяет действие, которое я могу выполнить с объектом**. 

1. Переменная s имеет тип String, значит, она позволяет вызвать любой член, определенный в типе String (например, свойство Length). Переменную s можно также использовать для вызова любых методов, унаследованных от типа Object (например, GetType). 
2. Переменная cloneable имеет тип интерфейса ICloneable, а значит, позволяет вызывать метод Clone, определенный в этом интерфейсе. Кроме того, можно вызвать любой метод, определенный в типе Object (например, GetType), поскольку CLR «знает», что все типы являются производными от Object. Однако переменная cloneable не позволяет вызывать открытые методы, определенные в любом другом интерфейсе, реализованном типом String. 
3. Аналогичным образом через переменную comparable можно вызвать CompareTo или любой метод, определенный в типе Object, но не другие методы.
4. Аналогичным образом через переменную enumerable можно вызвать GetEnumerator или любой метод, определенный в типе Object, но не другие методы.

Используя переменную интерфейсного типа, можно вызывать методы, определенные этим интерфейсом

#### Приведение экземпляра значимого типа к интерфейсному типу
> Как и ссылочный тип, значимый тип может реализовать несколько (или нуль) интерфейсов. Но при приведении экземпляра значимого типа к интерфейсному типу этот экземпляр **надо упаковать**, потому что **интерфейсная переменная является ссылкой**, которая должна указывать на объект в куче, чтобы среда CLR могла проверить указатель и точно выяснить тип объекта. Затем при вызове метода интерфейса с упакованным значимым типом CLR использует указатель, чтобы найти таблицу методов типа объекта и вызвать нужный метод




