---
{"dg-publish":true,"permalink":"/base/clr-via-c-sharp/proektirovanie-tipov/upakovka-boxing-i-raspakovka-unboxing/"}
---


### Boxing:

Операция по преобразованию значимого типа в **Object** тип (ссылочный тип) называется **упаковкой.**

```csharp
int price = 39;  
Object obj = price;
```

Когда нужно применять упаковку: если нужна ссылка на экземпляр значимого типа, этот экземпляр должен быть упакован

Компилятор C# создает IL-код, необходимый для упаковки экземпляра значимого типа, **автоматически,** но вы должны понимать, что происходит «за кулисами» и помнить об опасности «распухания» кода и снижения производительности.

При упаковке экземпляра значимого типа происходит следующее. 
1. В управляемой куче выделяется память. Ее объем определяется длиной значимого типа и двумя дополнительными членами — указателем на типовой объект и индексом блока синхронизации. Эти члены необходимы для всех объектов в управляемой куче. 
{ #7b60d2}

2. Поля значимого типа копируются в память, только что выделенную в куче. 
3. Возвращается адрес объекта. Этот адрес является ссылкой на объект, то есть значимый тип превращается в ссылочный.


```csharp
int num = 123;
object o = num; //boxing
num = (int)o;   // unboxing
```

К примеру есть структура:

```csharp
// Объявляем значимый тип 
struct Point { public Int32 x, y; }
```

Мы хотим добавить структуру в объект типа ArrayList:

```csharp
ArrayList a = new ArrayList(); 
Point p; //Выделяется память для Point (не в куче)
for (Int32 i = 0; i < 10; i++) 
{ 
	p.x = p.y = i; // Инициализация членов в нашем значимом типе 
	a.Add(p); // Упаковка значимого типа и добавление 
			  // ссылки в ArrayList
}
```

Вроде boxing не присутствует, но если посмотреть на метод Add типа ArrayList, видно, что Add принимает объект типа object, то есть ссылку (указатель) на объект в управляемой куче. Чтобы код работал нужно преобразовать **значимый** тип Point в **объект из управляемой кучи** и получить на него ссылку. Это происходит автоматически ([[Base/CLR via CSharp/Проектирование типов/Упаковка(boxing) и распаковка(unboxing)#^7b60d2\|^]]).

```csharp
public virtual Int32 Add(Object value);
```

Вследствие этого поля экземпляра p значимого типа Point в период выполнения копируются во вновь созданный в куче объект Point. Полученный адрес упакованного объекта Point (теперь это ссылочный тип) передается методу Add. Объект Point остается в куче до очередной уборки мусора. Переменную p значимого типа Point можно использовать повторно, так как ArrayList ничего о ней не знает. 

Заметьте: время жизни упакованного значимого типа превышает время жизни неупакованного значимого типа.

### Unboxing:

Операция по преобразованию типа  **Object** (ссылочный тип) в значимый тип называется **распаковкой.**

```csharp
int price2 = (int) obj;
```

> У unboxing точно такой же синтаксис, что и у приведения типов. Но это совершенно разные операции. 

Также на unboxing накладывается ограничение, заключается в том, что вы можете распаковывать только в точный тип значения (или его эквивалент, допускающий значение NULL), а не в другой тип значения, в который может быть преобразован исходный тип значения.

Здесь ссылка (или указатель), содержащаяся в элементе с номером 0 массива ArrayList, помещается в переменную p значимого типа Point. Для этого все поля, содержащиеся в упакованном объекте Point, надо скопировать в переменную p значимого типа, находящуюся в стеке потока. 

```csharp
Point p = (Point) a[0];
```

CLR выполняет эту процедуру в два этапа:
1. Сначала извлекается адрес полей Point из упакованного объекта Point. Этот процесс называют распаковкой (unboxing). 
2. Затем значения полей копируются из кучи в экземпляр значимого типа, находящийся в стеке.

Распаковка **не является** точной противоположностью упаковки. Она гораздо менее ресурсозатратна, чем упаковка, и состоит только в получении указателя на исходный значимый тип (поля данных), содержащийся в объекте. 

| Что требует boxing                                                      | Что требует unboxing                                                                                                                      |
| ----------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------- |
| Выделения памяти в управляемой куче                                     | Проверки того, что объект, который вы пытаетесь распаковать, действительно является упакованным значением того же типа (или совместимого) |
| Копирование полей значимого типа в память(только что выделенную в куче) | **Необязательно:** Копирование полей в значимый тип                                                                                       |

Кратко:
При boxing создаётся новый экземпляр объекта и в него копируются значение.
При unboxing из упакованного экземпляра необходимо скопировать только значение.

При распаковке объекта должно быть выполнено приведение к неупакованному типу который использовался при его создании.

```csharp
public static void Main() 
{ 
	Int32 x = 5; 
	Object o = x; // Упаковка x; o указывает на упакованный объект 
	Int16 y = (Int16) o; // Генерируется InvalidCastException 
}
```

Исключение InvalidCastException **возникает, когда преобразование экземпляра одного типа в другой тип не поддерживается**.  Упакованный тип Int32 невозможно распаковать в тип Int16.
Т.к. x был типом Int32 при упаковке, то и при распаковке должен использоваться тип Int32. 


Распаковка с последующим приведением:

```csharp
public static void Main()
{
	Int32 x = 5;
	Object o = x; // Упаковка x; o указывает на упакованный объект
	Int16 y = (Int16)(Int32)o; // Распаковка, а затем приведение типа
}
```


Распаковка с последующим копированием:

```csharp
public static void Main()
{
	Point p;
	p.x = p.y = 1;
	Object o = p; // Упаковка p; o указывает на упакованный объект
	p = (Point)o; // Распаковка o и копирование полей из экземпляра в стек
}
```

В последней строке компилятор C# генерирует IL-команду для распаковки o (получение адреса полей в упакованном экземпляре) и еще одну IL-команду для копирования полей из кучи в переменную p, располагающуюся в стеке

Влияние на изменение неупакованного значение на упакованное:

```csharp
static void Main(string[] args)
{
	Int32 v = 5; // Создание неупакованной переменной значимого типа o
	Object o = v; // указывает на упакованное Int32, содержащее 5
	v = 123; // Изменяем неупакованное значение на 123
	Console.WriteLine(v + ", " + (Int32) o); // Отображается "123, 5"
}
```

Изменение неупакованного значения v не влияет на упакованное значение(которое содержит объект о) т.к. при упаковке значение копируется в управляемую кучу и больше с ним не как ни связанно.

### Примеры с неявной упаковкой и распаковкой

```csharp
	static void Main(string[] args)
	{
		Int32 v = 5; // Создание неупакованной переменной значимого типа o
		Object o = v; // указывает на упакованное Int32, содержащее 5
		Int16 b = 123; // Изменяем неупакованное значение на 123
		Console.WriteLine("{0} {1}",b,(Int32)o); // Отображается "123, 5"
	}
```

На вид тут происходит одна упаковка и одна распаковка, но на самом деле тут три упаковки и одна распаковка.

![Pasted image 20230225141726.png](/img/user/Files/Image/Pasted%20image%2020230225141726.png)

Т.к. вызывается перегрузка метода WriteLine с параметрами типа object, то все параметры нужно упаковать перед использованием данного метода.

1. Сначала создаётся экземпляр v неупакованного значимого типа Int32, которому присваивается число 5.
2. Затем создаётся переменная o типа Object, которая инициализируется указателем на v. Однако поскольку ссылочные типы  должны указывать на объект в управляемой куче, C# генерирует соответсвующий IL-код для упаковки v и заносит адрес упакованной копии v в о.
3. Создаётся экземпляр b неупакованного значимого типа Int16, которому присваивается число 123.
4. Вызывается метод WriteLine(string, object arg0, object arg1), который в качестве первого параметра принимает строку с плейсхолдерами (строка форматирования {0} {1}).
    В качестве arg0 приниматься значимый тип Int16, который необходимо упаковать.
    В качестве arg1 принимается значимый тип Int32, который распаковывается (но без копирования), при которой извлекается адрес неупакованного экземпляра Int32 внутри упакованного экземпляра Int32. Этот неупакованный экземпляр Int32 надо опять упаковать, а его адрес в памяти передать в качестве параметра arg2 методу.

```csharp
Console.WriteLine("{0} {1}",b,o); // Отображается "123, 5"
``` 
 
Этот вариант строки отличается от предыдущего только отсутствием для переменной o операции приведения типа (Int32). Этот код выполняется быстрее, так как o уже является ссылочным типом Object и его адрес можно сразу передать методу. Отказавшись от приведения типа, я избавился от двух операций: распаковки и упаковки

### Рекомендации по ToString()

Рихтер рекомендует использовать ToString для значимых типов, чтобы избежать упаковки.

```csharp
Console.WriteLine(v.ToString() + ", " + o); // Отображается "123, 5"
```

Но что более затратно упаковка или ToString()?



| Boxing                                                                                                            | ToString()                                                                                                                      |
| ----------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------- |
| В управляемой куче выделяется память                                                                              | В управляемой куче выделяется память                                                                                            |
| Поля значимого типа копируются в только что выделенную память                                                     | Поля значимого типа преобразуются в строку с учетом языка и региональных параметров и копируются в только что выделенную память |
| К примеру Int32 занимает 32 бит всего                                                                             | String занимает 16 бит на один символ                                                                                           |
| Возвращается адрес объекта. Этот адрес является ссылкой на объект, то есть значимый тип превращается в ссылочный. | Возвращается String. Строковые объекты являются ссылочными типами                                                                                                                               |

> Вывод ToString() занимает больше памяти и в нём присутствует дополнительная логика преобразования. Boxing примитивен, он просто размещает значимый тип в управляемой куче.


Ответ на вопрос создаёт ли ToString() объект в куче:

> Почти наверняка, да. Могут быть некоторые закулисные приемы, чтобы избежать выделения для некоторых небольших целых чисел, нулей и т. Д. (Быстрый тест в .NET 6 и .NET 7 показывает, что это относится к 0-9 включительно).
> Если это нежелательно, есть способы избежать этого — например, `Utf8Formatter`есть методы для записи примитивов в диапазон, обычно некоторая повторно используемая буферная память, — но у этого есть другой API и использование, чем `ToString()`.


### Вызов значимыми типами виртуальных методов

Неупакованные значимые типы могут вызывать виртуальные методы, несмотря на то, что не имеют указателей на типовой объект и не могут наследовать структуры и классы.

P.S. Обычно для вызова виртуального метода требуется указатель на типовой объект т.к. производный класс либо вызывает базовую реализация либо определяет свою, но структура является значимым типом и не может наследовать ни классы ни другие структуры =>**у неё должна отсутствовать возможность вызова и переопределения виртуальных методов**. 

Однако т.к. все значимые типы наследуют ValueType, а он наследует System.Object, то мы можем пользоваться базовыми методами определёнными в System.Object.

ValueType переопределяет метод Equals, GetHashCode, ToString()

Если в значимом типе переопределить этих виртуальных методов, CLR может вызвать метод невиртуально, потому что значимые типы неявно запечатываются и поэтому не могут выступать базовыми классами других типов.

Кроме того, экземпляр значимого типа, используемый для вызова виртуального метода, **не упаковывается**. 

Но если ваше переопределение виртуального метода вызывает реализацию этого метода из базового типа, экземпляр значимого типа упаковывается при вызове реализации базового типа, чтобы в указателе this базового метода передавалась ссылка на объект в куче.

GetType и MemberwiseClone являются не виртуальными методами => переопределить их не получиться. Соответственно вызов GetType или MemberwiseClone повлечёт за собой **упаковку** значимого типа так как эти методы определены в System.Object, поэтому методы ожидают, что в аргументе this передается указатель на объект в куче.

Приведение неупакованного экземпляра значимого типа к одному из интерфейсов этого типа требует, чтобы экземпляр был **упакован**, так как интерфейсные переменные всегда должны содержать ссылку на объект в куче.

[[Base/CLR via CSharp/Проектирование типов/Упаковка и распаковка значимых типов при вызове методов\|Пример упаковки в значимых типах при вызове методов]]

