---
dg-publish: true
---

Компилятор C# не определяют для значимых типов конструкторы по умолчанию, не имеющие параметров.


```csharp
internal struct Point
{
	public Int32 m_x, m_y;
}
internal sealed class Rectangle
{
	public Point m_topLeft, m_bottomRight;
}
```

Для того чтобы создать объект Rectangle, надо использовать оператор new с указанием конструктора. В этом случае вызывается конструктор, автоматически сгенерированный компилятором C#. 

Память, выделенная для объекта Rectangle, включает место для двух экземпляров значимого типа Point. 
Из соображений повышения производительности CLR **не пытается вызвать конструктор для каждого экземпляра значимого типа**, содержащегося в объекте ссылочного типа. Однако как отмечалось ранее, поля значимого типа инициализируются нулями/null.

>  Конструкторы значимых(struct) типов выполняются лишь при наличии кода, явно вызывающего один из них.

```csharp
internal struct Point
{
	public Int32 m_x, m_y;
	public Point(Int32 x, Int32 y)
	{
		m_x = x;
		m_y = y;
	}
}
internal sealed class Rectangle
{
	public Point m_topLeft, m_bottomRight;
	public Rectangle()
	{
		// В C# оператор new, использованный для создания экземпляра значимого
		// типа, вызывает конструктор для инициализации полей значимого типа
		m_topLeft = new Point(1, 2);
		m_bottomRight = new Point(100, 200);
	}
}
```

Если конструктор объекта Rectangle не инициализировал его поля m_topLeft и m_bottomRight вызовом с помощью оператора new конструктора Point, поля m_x и m_y у обеих структур Point будут содержать 0.



В C# 10.0 разрешено создание конструктора экземпляра значимого типа без параметров и инициализацию экземплярных полей в значимых типах.

```csharp
internal struct SomeValType { 
// В значимый тип можно подставлять инициализацию экземплярных полей (В C# 10.0)
	private Int32 m_x = 5; 
}

internal struct SomeValType
{
	private Int32 m_x;
	// В значимых типах можно объявлять конструктор без параметров (В C# 10.0)
	public SomeValType()
	{
		m_x = 5;
	}
}
```

>C# позволяет в значимых типах использовать синтаксис инициализации статических полей на месте


Любой конструктор, определенный для значимого типа, должен инициализировать все поля этого типа.
![Pasted image 20230324201227.png](/img/user/Files/Image/Pasted%20image%2020230324201227.png)

Чтобы разрешить проблему, конструктор должен ввести в поле y какое-нибудь значение (обычно 0).

В качестве альтернативного варианта можно инициализировать все поля значимого типа, как это сделано здесь:

```csharp
internal struct Point
{
	public Int32 m_x, m_y;
	public Point(Int32 x)
	{
		// Выглядит необычно, но компилируется прекрасно,
		// и все поля инициализируются значениями 0 или null
		this = new Point();
		m_x = x; // Присваивает m_x значение x
				 // Обратите внимание, что поле m_y было инициализировано нулем
	}
}
```

В конструкторе значимого типа this представляет экземпляр значимого типа и ему можно приписать значение нового экземпляра значимого типа, у которого все поля инициализированы нулями. 

В конструкторах ссылочного типа указатель this считается доступным только для чтения и присваивать ему значение нельзя.