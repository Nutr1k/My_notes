В процессе компиляции обобщенного кода компилятор C# анализирует его, убеждаясь, что он сможет работать с **любыми типами данных** — существующими и теми, которые будут определены в будущем.

Рассмотрим метод:
![Pasted image 20230528164127.png](/img/user/Files/Image/Pasted%20image%2020230528164127.png)


Метод пытается через переменную o1 вызвать метод CompareTo, но многие типы не поддерживают метод CompareTo, поэтому компилятор не в состоянии обеспечить, чтобы после компиляции метод смог работать со всеми типами данных.

При попытке скомпилировать приведенный код появится сообщение об ошибке (ошибка CS0117: T не содержит определение метода CompareTo)

К счастью, компиляторы и CLR поддерживают уже упоминавшийся механизм **ограничений (constraints)**, благодаря которому обобщения снова начинают приносить практическую пользу.

### Ограничения
Ограничение **сужает** перечень типов, которые можно передать в обобщенном аргументе, и **расширяет** возможности по работе с этими типами.

Ограничения обеспечиваются с помощью ключевого слова where
В классах:
```csharp
class имя_класса<T> where T: тип_ограничения

class имя_класса<T1,T2> where T1: тип_ограничения
							  T2: тип_ограничения2
```
В методах:
```csharp
имя_метода<T>(параметры) where T: тип_ограничения

имя_метода<T1,T2>(параметры) where T1: тип_ограничения
								   T2: тип_ограничения2
```

#### Виды ограничений:
Если параметр-тип не задает основное ограничение, автоматически задается тип System.Object

##### Основные(primary) ограничения:
В параметре-типе можно задать только **одно** основное ограничение.

| class  | аргумент-тип будет иметь ссылочный тип                                                          |
| ------ | ----------------------------------------------------------------------------------------------- |
| struct | аргумент-тип будет иметь значимый тип                                                           |
| Класс  | аргумент-тип относиться либо к типу, указанному в ограничении, либо к производному от него типу |

```csharp
internal sealed class PrimaryConstraintOfStream<T> where T : Stream
{
	public void M(T stream)
	{
		stream.Close();// OK
	}
}
```

Ограничение Stream сообщает компилятору что, аргумент-тип должен быть Stream либо класс производный от Stream(к примеру FileStream)

##### Дополнительные (secondary) ограничения
В параметре-типе могут быть заданы **неограниченное** число дополнительных ограничений

| Интерфейс(ы)                                            | аргумент-тип будет определять тип, реализующий один или более интерфейсов |
| ------------------------------------------------------- | ------------------------------------------------------------------------- |
| Ограничитель параметра типа (type parameter constraint) | Позволяет указать, что аргументы-типы должны быть связаны определенными отношениями. К примеру один аргумент-тип должен являться производным, от другого или агрумент-тип должен реализовывать интерфейс, который указывать другой аргумент-тип                                    |

```csharp
private static List<TBase> ConvertIList<T, TBase>(IList<T> list) where T : TBase
{
	List<TBase> baseList = new List<TBase>(list.Count);
	for (Int32 index = 0; index < list.Count; index++)
	{
		baseList.Add(list[index]);
	}
	return baseList;
}
public static void Main()
{
	// Создает и инициализирует тип List<String> (реализующий IList<String>)
	IList<String> ls = new List<String>();
	ls.Add("A String");
	// Преобразует IList<String> в IList<Object>
	IList<Object> lo = ConvertIList<String, Object>(ls);
	// Преобразует IList<String> в IList<IComparable>
	IList<IComparable> lc = ConvertIList<String, IComparable>(ls);
	// Преобразует IList<String> в IList<IComparable<String>>
	IList<IComparable<String>> lcs =
	ConvertIList<String, IComparable<String>>(ls);
	// Преобразует IList<String> в IList<String>
	IList<String> ls2 = ConvertIList<String, String>(ls);

	// Преобразует IList<String> в IList<Exception>
	IList<Exception> le = ConvertIList<String, Exception>(ls); // Ошибка
}
```
###### Пояснение:
В первом вызове ConvertIList компилятор проверяет, чтобы тип String был совместим с Object. Поскольку тип String является производным от Object, первый вызов удовлетворяет ограничению параметра-типа. 

Во втором вызове ConvertIList компилятор проверяет, чтобы тип String был совместим с IComparable. Поскольку String реализует интерфейс IComparable, второй вызов соответствует ограничению параметра-типа. 

В третьем вызове ConvertIList компилятор проверяет, чтобы тип String был совместим с IComparable. Так как String реализует интерфейс IComparable, третий вызов соответствует ограничению параметра-типа. 

В четвертом вызове ConvertIList компилятор знает, что тип String совместим сам с собой.

В пятом вызове ConvertIList компилятор проверяет, чтобы тип String был совместим с Exception. Однако так как тип String несовместим с Exception, пятый вызов не соответствует ограничению параметра типа, и компилятор возвращает ошибку (ошибка CS0311: тип string не может использоваться в качестве параметратипа 'T' в обобщенном типе или методе Program.ConvertIList(System. Collectons.Generic.IList). Не существует неявного преобразования ссылки из 'string' в 'System.Exception'

##### Ограничение конструктора (constructor constraint)

| new() | аргумент-тип будет иметь неабстрактный тип, имеющий открытый конструктор без параметров |
| ----- | --------------------------------------------------------------------------------------- |

```csharp
internal sealed class ConstructorConstraint<T> where T : new()
{
	public static T Factory()
	{
		// Допустимо, потому что у всех типов неявно
		// есть открытый конструктор без параметров, и потому что
		// это ограничение требует, чтобы у всех указанных ссылочных типов
		// также был открытый конструктор без параметров
		return new T();
	}
}
```


#### Решение проблемы приведённой выше

```csharp
public static T Min<T>(T o1, T o2) where T : IComparable<T>
{
	if (o1.CompareTo(o2) < 0) return o1;
	return o2;
}
```

Метод сможет использовать только те аргумент-типы которые реализую обобщённый интерфейс IComparable.

Данный код не сработает т.к. Object не реализует интерфейс IComparable (Object вообще не реализует ни один интерфейс)
```csharp
private static void CallMin() 
{ 
	Object o1 = "Jeff", o2 = "Richter"; 
	Object oMin = Min(o1, o2); // Ошибка CS0311 
}
```

#### Ограничения на перегрузку посредством обобщений
Среда CLR не поддерживает перегрузку по **именам параметров типа** или по **именам ограничений**. 

Перегрузка типов и методов выполняется только по **арности**.

```csharp
internal sealed class AType { }
internal sealed class AType<T> { }
internal sealed class AType<T1, T2> { }

// Ошибка: конфликт с типом AType<T>, у которого нет ограничений.
internal sealed class AType<T> where T : IComparable<T> { }

// Ошибка: конфликт с типом AType<T1, T2>
internal sealed class AType<T3, T4> { }

internal sealed class AnotherType
{
	// Можно определить следующие методы:
	private static void M() { }
	private static void M<T>() { }
	private static void M<T1, T2>() { }
	
	// Ошибка: конфликт с типом M<T>, у которого нет ограничений
	private static void M<T>() where T : IComparable<T> { }
	
	// Ошибка: конфликт с типом M<T1, T2>.
	private static void M<T3, T4>() { }
}
```

Однако при переопределении виртуального метода можно изменять имена ограничений. Но переопределяемый метод так же не может накладывать свои ограничения, он наследует ограничения виртуального метода.
```csharp
internal class Base
{
	public virtual void M<T1, T2>()
	where T1 : struct
	where T2 : class
	{
	}
}
internal sealed class Derived : Base
{
	public override void M<T3, T4>()
	where T3 : EventArgs // Ошибка
	where T4 : class // Ошибка
	{ }
}
```

#### Приведение переменной обобщенного типа
Приведение переменной обобщенного типа к другому типу допускается только в том случае, если она приводится к типу, совместимому с ограничением. 

Если необходимо привести переменную обобщённого типа к более конкретному(хотя это противоречит смыслу обобщений), то нужно сначала привести её к типу Object(т.к. все типы могут быть приведены к типу Object), а потом к более конкретному типу.

```csharp
private static void CastingAGenericTypeVariable2<T>(T obj)
{
	Int32 x = (Int32)(Object)obj; // Ошибки нет
	String s = (String)(Object)obj; // Ошибки нет
}
```


#### Присваивание переменной обобщенного типа значения по умолчанию
```csharp
private static void SettingAGenericTypeVariableToDefaultValue<T>()
{ 
	T temp = default(T); // Работает 
}
```

#### Сравнение переменной обобщенного типа с null
```csharp
private static void ComparingAGenericTypeVariableWithNull<T>(T obj) 
{ 
	if (obj == null) 
	{ 
		/* Этот код никогда не исполняется для значимого типа */ 
	} 
}
```
Так как тип T не ограничен, он может быть ссылочным или значимым. Во втором случае obj нельзя приравнять null. Обычно в этом случае компилятор C# должен выдать ошибку, но этого не происходит — код успешно компилируется. 

При вызове этого метода с аргументом значимого типа JIT-компилятор, обнаружив, что результат выполнения инструкции if никогда не равен true, просто не сгенерирует машинный код для инструкции if и кода в фигурных скобках. Если бы я использовал оператор !=, JIT-компилятор также не сгенерировал бы код для инструкции if (поскольку условие всегда ложно),

#### Сравнение двух переменных обобщенного типа
```csharp
private static void ComparingTwoGenericTypeVariables<T>(T o1, T o2) 
{ 
	if (o1 == o2) { } // Ошибка 
}
```

В этом примере у T нет ограничений, и хотя можно сравнивать две переменные ссылочного типа, сравнивать две переменные значимого типа допустимо лишь в том случае, когда значимый тип перегружает оператор `==`.

Если у T есть ограничение class, этот код скомпилируется, а оператор == вернет значение true, если переменные ссылаются на один объект и полностью тождественны. Если параметр T ограничен ссылочным типом, перегружающим `метод operator==`, компилятор сгенерирует вызовы этого метода в тех местах, где он встречает оператор `==`. Естественно, это относится и к оператору !=. При написании кода для сравнения элементарных значимых типов (Byte, Int32, Single, Decimal и т. д.) компилятор С# сгенерирует код правильно, но для непримитивных значимых типов генерировать код сравнения он не умеет