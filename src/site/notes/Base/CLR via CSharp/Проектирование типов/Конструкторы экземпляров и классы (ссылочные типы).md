---
{"dg-publish":true,"permalink":"/base/clr-via-c-sharp/proektirovanie-tipov/konstruktory-ekzemplyarov-i-klassy-ssylochnye-tipy/"}
---


Конструкторы — это специальные методы, позволяющие корректно инициализировать новый экземпляр типа. В IL-коде конструктор обозначается .ctor (от constructor). Обычный класс снабжается конструктором по умолчанию конструктор гарантирует установку всех полей в соответствующие стандартные значения.
Для статических классов, запечатанных и абстрактный компилятор не создает конструктор по умолчанию.

При создании экземпляра объекта ссылочного типа выделяется память для полей данных экземпляра и инициализируются служебные поля (указатель на объект-тип и индекс блока синхронизации), после чего вызывается конструктор экземпляра, устанавливающий исходное состояние нового объекта. 

При конструировании объекта ссылочного типа выделяемая для него память **всегда обнуляется до вызова конструктора экземпляра типа**. Любые поля, не задаваемые конструктором явно, гарантированно содержат 0 или null.

Если в классе отсутствует явно заданный конструктор, то компилятор C# **создаст конструктор по умолчанию(без параметров)**, реализация которого просто вызывает конструктор без параметров базового класса. 

В конечном счете всегда вызывается открытый конструктор объекта **System.Object** без параметров. Этот конструктор ничего не делает — просто возвращает управление по той простой причине, что в System.Object не определено никаких экземплярных полей данных, поэтому конструктору просто нечего делать

Конструктор экземпляров должен вызывать конструктор базового класса до обращения к какому-либо из унаследованных от него полей. 

Эти определения идентичны: 
```csharp
public class SomeType { } 
```

```csharp
public class SomeType 
{ 
	public SomeType() : base() { } 
}
```

При инициализации полей в не конструктора, компилятор на самом деле помещает код в конструктор

```csharp
internal sealed class SomeType 
{ 
	private Int32 m_x = 5; 
}
```
Компилятор собирает все поля инициализированные таким образом и помещает их в конструктор:
![Pasted image 20230320183515.png](/img/user/Files/Image/Pasted%20image%2020230320183515.png)


Также при создании множества конструкторов, **компилятор помещает в начало каждого** из методов код, инициализирующий поля m_x, m_s и m_d
```csharp
internal sealed class SomeType 
{
	private Int32 m_x = 5;
	private String m_s = "Hi there";
	private Double m_d = 3.14159;
	private Byte m_b;

	public SomeType() { }
	public SomeType(Int32 x) { m_x=x; }
	public SomeType(String s) { m_d = 10; } 
}
```

[[Pasted image 20230320191334.png]]
![Pasted image 20230320191334.png](/img/user/Files/Image/Pasted%20image%2020230320191334.png)
К примеру IL-код, сгенерированный для конструктора с параметром типа String, состоит из кода, инициализирующего поля m_x, m_s и m_d, и кода, перезаписывающего поле m_d значением 10. 

Заметьте: поле m_b гарантированно инициализируется значением 0, даже если нет кода, инициализирующего это поле явно.

Поскольку в показанном ранее классе определены три конструктора, компилятор трижды генерирует код, инициализирующий поля m_x, m_s и m_d: по одному разу для каждого из конструкторов.

Такое использование перегружаемых конструкторов приводит к сильному разбуханию кода. Лучше создать единственный конструктор, выполняющий общую инициализацию, и заставить каждый метод-конструктор явно вызывать конструктор, выполняющий общую инициализацию.

```csharp
internal sealed class SomeType
{
	// Здесь нет кода, явно инициализирующего поля
	private Int32 m_x;
	private String m_s;
	private Double m_d;
	private Byte m_b;
	// Код этого конструктора инициализирует поля значениями по умолчанию
	// Этот конструктор должен вызываться всеми остальными конструкторами
	public SomeType()
	{
		m_x = 5;
		m_s = "Hi there";
		m_d = 3.14159;
		m_b = 0xff;
	}
	// Этот конструктор инициализирует поля значениями по умолчанию,
	// а затем изменяет значение m_x
	public SomeType(Int32 x) : this()
	{
		m_x = x;
	}
	// Этот конструктор инициализирует поля значениями по умолчанию,
	// а затем изменяет значение m_s
	public SomeType(String s) : this()
	{
		m_s = s;
	}
}
```
Этот подход позволит уменьшить размер генерируемого кода.
[[Pasted image 20230320191852.png]]
![Pasted image 20230320191852.png](/img/user/Files/Image/Pasted%20image%2020230320191852.png)