---
{"dg-publish":true,"permalink":"/base/clr-via-c-sharp/proektirovanie-tipov/znachimye-tipy-value-types/"}
---


Экземпляры этих типов **обычно-иногда** размещаются в **стеке потока**, хотя они могут быть встроены и в объект ссылочного типа. В представляющей экземпляр переменной нет указателя на экземпляр; поля экземпляра размещаются в самой переменной.

Примеры значимых типов в C#:

-   Любой из примитивных типов является также значимым типом.
-   enum - перечисление.
-   Struct - структура.

Значимые типы легче ссылочных: 
- для них не надо выделять память в управляемой куче
- их не затрагивает сборка мусора
- у них нет дополнительных членов, присущих каждому объекту в куче: указателя на типовой объект и индекса блока синхронизации.

Основное отличие значимых типов от ссылочных типов в том, что **объекты значимых типов** всегда передаются по значению, т.е. копируются. (Создаётся независимая копия)

> Типы значений называются «типами значений», поскольку они копируются по значению. Ссылочные типы называются «ссылочными типами», поскольку они копируются по ссылке. Совершенно неверно, что «типы значений всегда живут в стеке». Если бы это было правдой, их бы называли «типами стека» и «типами кучи».

**Объекты ссылочных типов** всегда передаются по ссылке, т.е. теперь две переменные указывают на один объект.

Основное отличие между **примитивными типами** и **значимыми типами** заключается в том, что примитивные типы являются **встроенными типами** данных, тогда как значимые типы могут быть **определены пользователем**. 


**Если тип называют структурой (structure) или перечислением (enumeration) речь идет о значимом типе.**

По умолчанию все значимые типы должны быть производными от **System.ValueType** который, в свою очередь, является производным от System.Object.
В System.ValueType переопределены Equals и GetHashCode.

В структурах всем экземплярным полям присваивается null или 0 (нуль) **перед вызовом конструктора типа** 

Как было сказано ранее оператор new возвращает ссылку на объект, но это не работает для значимых типов.

```csharp
// Ссылочный тип (поскольку 'class') 
class SomeRef { public Int32 x; } 
// Значимый тип (поскольку 'struct') 
struct SomeVal { public Int32 x; } 
static void ValueTypeDemo() 
{ 
	SomeRef r1 = new SomeRef(); // Размещается в куче 
	SomeVal v1 = new SomeVal(); // Размещается в стеке
}
```

Компилятор C# знает что SomeVal является значимым типом и его следует разместить в стеке потока.

В переменной значимого типа(и ссылочного) всегда содержится некое значение соответствующего типа(но к ним нельзя обращаться т.к. компилятор выдаст ошибку), а при инициализации всем членам этого типа присваивается 0 (к таким переменным можно обращаться). То есть значимые( и ссылочные) типы содержать всегда **значения по умолчанию**,

| Type                                     | Значение по умолчанию |
| ---------------------------------------- | --------------------- |
| Любой ссылочный тип                      | null                  |
| Любой встроенный целочисленный тип       | Ноль (0)              |
| Любой встроенный тип с плавающей запятой | Ноль (0)              |
| bool                                     | false                 |
| char                                     | '\0' (U+0000)         |

Но несмотря на то, что в каждой переменной содержится значение по умолчанию (в int содержиться 0, в bool false) компилятор C# не позволяет обращаться к таким неинициализированным переменным. 

> Если в переменной содержится значение, то это не значит что она инициализирована.

**Компилятор C# не позволяет** совершать операций с неинициализированными переменными.
![Pasted image 20230324181525.png](/img/user/Files/Image/Pasted%20image%2020230324181525.png)

**Но CLR позволяет.**
Вышеприведённый код(Debug) транслируется в данный IL код:

```asm
    .method public hidebysig instance void M () cil managed 
    {
		.entrypoint
		// Размер кода:       11 (0xb)
        .maxstack 1
        .locals init ([0] int32 num)
        IL_0000: nop
        IL_0001: ldc.i4.8
        IL_0002: stloc.0
        IL_0003: ldloc.0
        IL_0004: call void [System.Console]System.Console::WriteLine(int32)
        IL_0009: nop
        IL_000a: ret
    } // end of method Program::Main
```

Если убрать команды `ldc.i4.8` и `stloc.0` отвечающие за инициализацию переменной, то нижеприведённый код без проблем скомпилируется и выдаст значение переменной по умолчанию: 

```asm
  .method public hidebysig static void  Main() cil managed
  {
    .entrypoint
    // Размер кода:       11 (0xb)
    .maxstack  1
    .locals init ([0] int32 num)
    IL_0000:  nop
    IL_0003:  ldloc.0
    IL_0004:  call       void [mscorlib]System.Console::WriteLine(int32)
    IL_0009:  nop
    IL_000a:  ret
  } // end of method Program::Main
```
Вывод:
![Pasted image 20230324183644.png](/img/user/Files/Image/Pasted%20image%2020230324183644.png)

Значимый тип размещается в стеке, но не считается инициализированным(всем его членам **присваивается** значение по умолчанию (0 или нуль), но к этой переменной нельзя обращаться). Однако мы можем инициализировать поля структуры **без оператора new**

```csharp
struct SomeVal { public Int32 x; public Int32 z; } 
SomeVal v1; // Размещается в стеке
// Console.WriteLine(v1.x); Выдаст ошибку т.к. x не инициализированна
v1.x = 5;   // инициализируем поле структуры
// Console.WriteLine(v1.z); Выдаст ошибку т.к. z не инициализированна
```
Из вышеприведённого видно, что конструктор new не вызываться т.к. если бы он вызвался неявно, то все поля были бы инициализированы

Когда переменной значимого типа присваивается другая переменная значимого типа, выполняется копирование всех ее полей.


### Разница между размещением в памяти ссылочных и значимых типов.

```csharp
// Ссылочный тип (поскольку 'class')
class SomeRef { public Int32 x; }
// Значимый тип (поскольку 'struct')
struct SomeVal { public Int32 x; }
static void ValueTypeDemo()
{
	SomeRef r1 = new SomeRef(); // Размещается в куче
	SomeVal v1 = new SomeVal(); // Размещается в стеке
	r1.x = 5; // Разыменовывание указателя
	v1.x = 5; // Изменение в стеке
	Console.WriteLine(r1.x); // Отображается "5"
	Console.WriteLine(v1.x); // Также отображается "5"
							 // В левой части рис. 5.2 показан результат
							 // выполнения предыдущих строк
	
	SomeRef r2 = r1; // Копируется только ссылка (указатель)
	SomeVal v2 = v1; // Помещаем в стек и копируем члены
	r1.x = 8; // Изменяются r1.x и r2.x
	v1.x = 9; // Изменяется v1.x, но не v2.x
	Console.WriteLine(r1.x); // Отображается "8"
	Console.WriteLine(r2.x); // Отображается "8"
	Console.WriteLine(v1.x); // Отображается "9"
	Console.WriteLine(v2.x); // Отображается "5"
							 // В правой части рис. 5.2 показан результат
							 // выполнения ВСЕХ предыдущих строк
}
```

![Pasted image 20230224143957.png](/img/user/Files/Image/Pasted%20image%2020230224143957.png)

