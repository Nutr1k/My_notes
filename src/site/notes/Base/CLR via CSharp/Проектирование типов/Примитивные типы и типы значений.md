> 
> В спецификации языка C# слово «примитивный» используется дважды; оно нигде не определено и совершенно неясно, что оно может означать.
> Спецификация языка C# не нуждается в использовании или определении слова «примитивный», поэтому не должна использовать этот неопределенный термин. Я поговорил с Мэдсом, и мы договорились, что будущие редакции спецификации будут перефразированы, чтобы полностью исключить это использование.
   \- [Эрик Липперт](https://stackoverflow.com/questions/2066035/in-c-sharp-are-the-terms-primitive-and-literal-interchangeable/2135136#2135136)


Эта путаницы полный бред. Нужно убрать понятие "Примитивные типы", в прочем как это и сделали. 

В спецификации языка [ECMA-334 4-е издание, июнь 2006 г](ECMA-334_4th_edition_june_2006.pdf) два упоминания про primitive type(примитивные типы).
![Pasted image 20241017215159.png](/img/user/Files/Image/Pasted%20image%2020241017215159.png)
В спецификации языка [ECMA-334 7-е издание, декабрь 2023 г](ECMA-334_7th_edition_december_2023.pdf) ноль упоминаний про primitive type(примитивные типы).
![Pasted image 20241017215305.png](/img/user/Files/Image/Pasted%20image%2020241017215305.png)

В спецификации определён термин Simple type(Простые типы)
![Pasted image 20241017220809.png](/img/user/Files/Image/Pasted%20image%2020241017220809.png)

> **Простые типы** — набор предопределенных структурных типов.

Как описано в спецификации, простые типы, предоставляемые C#, такие как int, double и bool, на самом деле являются структурными типами.


_Примечание_ : Простые типы отличаются от других структурных типов тем, что они допускают некоторые дополнительные операции:

- Большинство простых типов позволяют создавать значения путем записи _литералов_ ( [§6.4.5](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/language-specification/lexical-structure#645-literals) ), хотя C# не предусматривает литералов структурных типов в целом. _Пример_ : `123`является литералом типа `int`и `'a'`является литералом типа `char`.
- Когда все операнды выражения являются константами простого типа, компилятор может вычислить выражение во время компиляции. Такое выражение известно как _constant_expression_ ( [§12.23](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/language-specification/expressions#1223-constant-expressions) ). Выражения, включающие операторы, определенные другими структурными типами, не считаются константными выражениями
![Pasted image 20241017230744.png](/img/user/Files/Image/Pasted%20image%2020241017230744.png)
![Pasted image 20241018003123.png](/img/user/Files/Image/Pasted%20image%2020241018003123.png)
- С помощью `const`деклараций можно объявлять константы простых типов ( [§15.4](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/language-specification/classes#154-constants) ). Невозможно иметь константы других структурных типов, но аналогичный эффект обеспечивают статические поля только для чтения.
- Преобразования, включающие простые типы, могут участвовать в оценке операторов преобразования, определенных другими структурными типами, но пользовательский оператор преобразования никогда не может участвовать в оценке другого пользовательского оператора преобразования ( [§10.5.3](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/language-specification/conversions#1053-evaluation-of-user-defined-conversions) ).

Таблица типов
![Pasted image 20241017233231.png](/img/user/Files/Image/Pasted%20image%2020241017233231.png)

[Спецификация типов MSD](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/language-specification/types)








> [!failure] 
> Перечисленное ниже устарело: 

1. Есть ли разница между примитивными типами и типами значений?
2. Являются ли все типы значений примитивными типами и наоборот?
3. Есть ли разница между строкой и System.String?  
    
Эти вопросы, в основном, мы и собираемся сегодня кратко обсудить, потому что в этой области существует большое недопонимание.  
Итак, прежде всего, ответы на предыдущие вопросы  

1. Да, есть разница между типами Primitive и Value.
2. Нет, ни все типы значений являются примитивами, ни наоборот
3. Нет, нет разницы между строкой и System.String

**Типы значений**
Типы значений непосредственно содержат свои данные, а экземпляры типов значений либо размещаются в стеке, либо размещаются внутри структуры. Типы значений могут быть встроенными (реализованными средой выполнения), определяемыми пользователем (структуры) или перечислениями (enums).|
1. sbyte (System.SByte)*
2. byte (System.Byte)
3. short (System.Int16)
4. ushort (System.UInt16)*
5. int (System.Int32)
6. uint (System.UInt32)*
7. long (System.Int64)
8. ulong (Sysem.UInt64)*
9. char (System.Char)  
10. float (System.Single)
11. double (System.Double)
12. bool (System.Boolean)
13. decimal (System.Decimal)
14. **All variables defined from a struct data type**
15. **All Enumerations (enum) types**

**Примитивные типы**
Базовые системные типы, рассматриваемые компилятором как базовые строительные блоки для любой другой структуры данных.

1. sbyte (System.SByte)*
2. byte (System.Byte)
3. short (System.Int16)
4. ushort (System.UInt16)*
5. int (System.Int32)
6. uint (System.UInt32)*
7. long (System.Int64)
8. ulong (Sysem.UInt64)*
9. char (System.Char)  
10. float (System.Single)
11. double (System.Double)
12. bool (System.Boolean)
13. decimal (System.Decimal)
14. **string** (System.String)
15. **object** (System.Object)

_* Указывает тип, не совместимый с CLS._

Как видно из предыдущей таблицы, не все типы значений перечислены в типах-примитивах, также вы заметите, что типы-примитивы содержат два ссылочных типа ((string & object)), поэтому не все типы-примитивы являются типами-значениями.  

Итак, почему существует такое различие между типами значений и примитивными типами.  
Если вы посмотрите на каждый тип в последней таблице, вы обнаружите, что каждый тип значения соответствует типу System.<Какой-то тип> CLR, а также наследуется от System.ValueType, поэтому изначально, если вы хотите объявить переменную типа int, вы должны написать ее таким образом  

```csharp
System.Int32 i = new System.Int32();
```

и это стандартный формат объявления/инициализации для любого типа в CTS. Однако с синтаксической точки зрения это действительно глупо, и вам покажется странным писать такую ​​строку для каждой переменной, особенно если эти переменные используются часто, и это как раз основная причина примитивных типов, примитивные типы ярлык для объявления таких переменных, поэтому вместо предыдущей строки, а также знакомить их с самим языком, например int в C # и Integer в VB, вы просто напишите это  

```csharp
int i;
```

и это будет полностью эквивалентно предыдущей строке.  
поэтому отсюда мы можем понять, почему **string** & **object** типы считаются примитивными типами, потому что в противном случае вам пришлось бы писать это для каждой объявленной строковой переменной.  

```csharp
System.String s = new System.String()
```

что глупо, потому что мы все время используем String.  
  
Однако компилятор также примет следующее объявление, которое более удобно, чем первое объявление.  

```csharp
Int32 i;
```

Таким образом, вам не нужно писать часть после нового ключевого слова.

[Примитивные типы и типы значений](http://web.archive.org/web/20081015182721/http://spellcoder.com/blogs/bashmohandes/archive/2006/12/27/4821.aspx)