---
{"dg-publish":true,"permalink":"/base/clr-via-c-sharp/proektirovanie-tipov/tipy-parametrov-i-vozvrashhaemyh-znachenij-silnye-i-slabye-tipy/"}
---


**Моё определение слабым типам(минимальным):**
Слабый тип: тип который является базовым типом для большинства типов.
**Моё определение сильным типам:**
Сильный тип: тип который является производным типом для максимального количества типов.

Какие типы являются базовыми для других типов:
![Pasted image 20230504170617.png](/img/user/Files/Image/Pasted%20image%2020230504170617.png)

##### Типы (формальных) параметров:
Объявляя тип параметров метода, нужно по возможности указывать «минимальные»(слабые типы) типы, предпочитая интерфейсы базовым классам когда это возможно(IList\<T> и List\<T>). Так же следует предпочитать базовые классы производным классам (Stream(базовый класс) и FileStream).

Например, лучше объявлять метод, принимающий параметр IEnumerable, а не List:
```csharp
// Рекомендуется в этом методе использовать параметр слабого типа 
public void ManipulateItems(IEnumerable collection) { ... } 

// Не рекомендуется в этом методе использовать параметр сильного типа 
public void ManipulateItems(List collection) { ... }
```
Первый метод предпочтительнее т.к. его можно вызывать передав в него:
- массив
- объект List
- объект String и т. п., 
то есть любой объект, тип которого реализует интерфейс IEnumerable
Второй менее предпочтительнее т.к. принимает только объекты List


<details> 
  <summary>IList и List</summary>
Если нужно принимать список (а не просто любой перечислимый объект), нужно объявлять тип параметра как IList, в то время как типа List лучше избегать. Именно такой подход позволит вызывающему коду передавать массивы и другие объекты, тип которых реализует IList.
</details>

Например, лучше объявлять метод, принимающий объект Stream, а не FileStream:

```csharp
// Рекомендуется в этом методе использовать параметр мягкого типа 
public void ProcessBytes(Stream someStream) { ... } 

// Не рекомендуется в этом методе использовать параметр сильного типа 
public void ProcessBytes(FileStream fileStream) { ... }
```

Первый метод может обрабатывать байты из потока любого вида: FileStream, NetworkStream, MemoryStream и т. п. Второй поддерживает только FileStream, то есть область его применения ограничена.

##### Типы возвращаемых значений:
Объявляя типы возвращаемых параметров метода, нужно по возможности указывать «сильные» типы.

Например, лучше объявлять метод, возвращающий объект FileStream, а не Stream:
```csharp
// Рекомендуется в этом методе использовать 
// сильный тип возвращаемого объекта 
public FileStream OpenFile() { ... } 

// Не рекомендуется в этом методе использовать 
// слабый тип возвращаемого объекта 
public Stream OpenFile() { ... }
```
Здесь предпочтительнее первый метод, так как он позволяет вызывающему коду обращаться с возвращаемым объектом как с объектом FileStream или Stream. А вот второму методу требуется, чтобы вызывающий код рассчитывал только на объект Stream, то есть область его применения более ограничена.



Иногда требуется сохранить возможность изменять внутреннюю реализацию метода, не влияя на вызывающий код. В приведенном ранее примере изменение реализации метода OpenFile в будущем маловероятно, он вряд ли будет возвращать что-либо отличное от объекта типа FileStream (или типа, производного от FileStream). 

Однако для метода, возвращающего объект List, вполне возможно изменение реализации, после которого он начнет возвращать тип String[]. 
В подобных случаях следует выбирать более слабый тип возвращаемого объекта:

```csharp
// Гибкий вариант: в этом методе используется 
// слабый тип возвращаемого объекта 
public IList GetStringCollection() { ... } 
// Негибкий вариант: в этом методе используется 
// сильный тип возвращаемого объекта 
public List GetStringCollection() { ... }
```


**Кратко:**

Когда мы принимаем - лучше использовать слабый тип т.к. мы сможем принимать большее число различных типов.

Когда мы возвращаем - лучше использовать сильный тип т.к. мы сможем обращаться с возвращающим значение как с различными типами (приводя тип к базовому классу).

Слабый тип в качестве возвращаемого значения следует использовать тогда, когда может измениться реализация, после которой метод начнет возвращать новый другой тип (т.к. тип является слабым, а следовательно базовым для большинства других типов, то новые тип с большей долей вероятности будет являться производным типом и при его возврате произойдёт Upcasting(приведение производного типа к его базовому типу) который выполняется автоматически.


К примеру interface ICollection\<Т>(Строка) является базовым для  interface IList\<T>(Столбец) и class List\<T>(Столбец). Из этого следует что ICollection\<T> может принять IList\<T>(Столбец) и class List\<T>(Столбец). Другими словами: Переменной ссылки базового класса ICollection\<T> может быть присвоены ссылки на объекты производных классов IList\<T> и class List\<T>.
![Pasted image 20230504172106.png](/img/user/Files/Image/Pasted%20image%2020230504172106.png)

Любому типу из строки могут быть присвоены типы снизу из столбца(зелёные, жёлтые)
![Pasted image 20230504172855.png](/img/user/Files/Image/Pasted%20image%2020230504172855.png)

Из данной таблицы прослеживается ещё один важный вывод. 

По горизонтали указаны классы и интерфейсы являющиеся базовыми для классов и интерфейсов указанными под ними и наоборот:

По вертикали указаны интерфейсы и классы являющиеся производными от интерфейсов и классов указанных рядом с ними


К примеру interface IEnumerable и ICollection является базовым для интерфейса IList.
interface IList в свою очередь является производным от interface IEnumerable и ICollection
![Pasted image 20241014210008.png](/img/user/Files/Image/Pasted%20image%2020241014210008.png)

Получается чем больше зелёных клеток закрашено по вертикали, тем интерфейс/класс  слабее(слабый тип). interface IEnumerable является самым слабым типом т.к. он базовый для всех типов в таблице

Чем больше зелёных клеток закрашено по горизонтали, тем интерфейс/класс сильнее(сильный тип). class List является самым сильным типом т.к. он прямо или косвенно наследуется от всех типов в таблице.

![Pasted image 20241014212223.png](/img/user/Files/Image/Pasted%20image%2020241014212223.png)

=> List можно привести(присвоить,проабкастить) ко всем типам в таблице.

```csharp
	IEnumerable e1=new List<string>();
	IEnumerable<string> e2 = new List<string>();
	ICollection<string> c1= new List<string>();
	ICollection c2= new List<string>();
	IList l1= new List<string>();
	IList<string> l2= new List<string>();
```

