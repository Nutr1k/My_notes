---
dg-publish: true
---

Приведение типа объекта к его **базовому** типу не требуется, оно выполняется автоматически.
p.s. В C# нет специального синтаксиса для этого.

> Переменной ссылки на объект базового класса может быть присвоена ссылка на объект любого производного от него класса

Если ссылка на объект производного класса присваивается переменной ссылки на объект базового класса, то доступ разрешается только к тем частям этого объекта, которые определяются базовым классом.

Приведение типа объекта к его **производному** типу требуется, оно выполняется посредством явного приведения типов.

-   **Upcasting** — это операция, которая создает ссылку на базовый класс из ссылки на подкласс(производный класс). (подкласс -> базовый класс) (т.е. менеджер -> сотрудник)
   Приведение производного класса к типу базового класса
-   **Downcasting** — это операция, которая создает ссылку на подкласс(производных класс) из ссылки на базовый класс. (базовый класс-> подкласс) (т.е. сотрудник -> менеджер)
   Downcating возможен после того как был сделан Upcasting
   Приведение базового класса к типу производного класса.
Что на самом деле происходит в обоих «кастах»? Какие изменения происходят с объектами, когда мы бросаем вниз или вверх? Ответ довольно прост; ничего! Никакие изменения в объекты не вносятся вообще.

Оба приведения являются _преобразованием типов ссылочных переменных_ , сохраняющими идентичность; это означает, что объект до приведения и после приведения является (является) _одним и тем же объектом_ . Как следует из названия, _единственное, что вы меняете, — это тип ссылки, указывающей на объект_ ; переменные `a1`и `b1`.

Приведение ссылочной переменной не затрагивает объект, на который она ссылается, а лишь помечает этот объект по-другому, расширяя или сужая возможности работы с ним. **Upcasting(Восходящее) приведение сужает список методов и свойств, доступных для этого объекта, а downcasting(понижающее) приведение может его расширить.**

Ссылка похожа на дистанционное управление объектом. Пульт имеет больше или меньше кнопок в зависимости от его типа, а сам объект хранится в куче. Когда мы делаем кастинг, мы меняем тип пульта, но не меняем сам объект.

```csharp
class A
{
	public string a = "a";
	public void Show()
	{
		Console.ForegroundColor = ConsoleColor.Red;
		Console.WriteLine("A:" + a);
	}
}

class B : A
{
	public string b = "b";

	public void Show()
	{
		Console.ForegroundColor = ConsoleColor.Green;
		Console.WriteLine("B:"+a);
		Console.WriteLine("B:" + b);
	}
}

class Program
{
	static void Main(string[] args)
	{
		B b= new B();

		A a = b;//Upcasting
		a.Show();//A:a

		b = (B)a;//Downcasting
		b.Show();//B:a
				 //B:b

		Console.ForegroundColor = ConsoleColor.White;
		Console.WriteLine(a1.GetHashCode());//46104728
		Console.WriteLine(b.GetHashCode());//46104728
		Console.WriteLine( ReferenceEquals(a, b));//true
	}
}        
```


```csharp
// Этот тип неявно наследует от типа System.Object
internal class Employee
{

}
public sealed class Program
{
	public static void Main()
	{
	// Приведение типа не требуется, т. к. new возвращает объект Employee,
	// а Object — это базовый тип для Employee.
		Object o = new Employee();
	// Приведение типа обязательно, т. к. Employee — производный от Object
	// В других языках (таких как Visual Basic) компилятор не потребует
	// явного приведения
		Employee e = (Employee)o;
	}
}
```

Приведение типов с помощью операторов is и as

|           | is                                                                                 | as                                                                                                               |
| --------- | ---------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------- |
| Описание  | Проверяет совместимость объекта с данным типом                                     | Проверяет совместимость объекта с данным типом                                                                   |
| Результат | true - если совместим или false - не совместим. Для null ссылок всегда будет false | Если типы совместимы, as возвращает ненулевой указатель на этот объект, а если нет — оператор as возвращает null |


is:

```csharp
if (o is Employee) //1-ая проверка совместимости
{ 
Employee e = (Employee) o; //2-ая проверка совместимости(Путём явного приведения типов).
}
```

В этом коде CLR по сути проверяет тип объекта дважды: сначала в операторе is определяется совместимость o с типом Employee, а затем в теле оператора if анализируется, является ли o ссылкой на Employee.

as:

```csharp
Employee e = o as Employee; 
 if (e != null) { // Используем e внутри инструкции if }
```

В этом коде CLR проверяет совместимость o с типом Employee. Если o и Employee совместимы, as возвращает ненулевой указатель на этот объект, а если нет - оператор as возвращает null. Заметьте: оператор as заставляет CLR верифицировать тип объекта только один раз, а if лишь сравнивает e с null — такая проверка намного эффективнее, чем определение типа объекта.

[Зачем нужен](https://ru.stackoverflow.com/questions/433314/%D0%97%D0%B0%D1%87%D0%B5%D0%BC-%D0%BD%D1%83%D0%B6%D0%B5%D0%BD-upcast-%D0%BF%D0%BE%D0%B2%D1%8B%D1%88%D0%B0%D1%8E%D1%89%D0%B5%D0%B5-%D0%BF%D1%80%D0%B8%D0%B2%D0%B5%D0%B4%D0%B5%D0%BD%D0%B8%D0%B5-%D1%82%D0%B8%D0%BF%D0%B0)

Литералы сами по себе считаются экземплярами типа, поэтому можно вызывать экземплярные методы, например, следующим образом: 

```csharp
Console.WriteLine(123.ToString() + 456.ToString()); // "123456"
```