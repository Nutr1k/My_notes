Обобщения (generics) - механизм для многократного использования кода, а именно многократного использования алгоритмов. Обобщения обеспечивают безопасность типов на стадии компиляции.

В частности, в библиотеке FCL определен обобщенный алгоритм управления списками, работающий с набором объектов. Тип объектов(T) в обобщенном алгоритме не указан. Разработчик, который хочет использовать такой алгоритм, должен указать конкретный тип данных.

```csharp
public class List<T> : IList<T>, ICollection<T>, IEnumerable<T>, IList<T>, ICollection<T>, IEnumerable<T> {....}
```
Параметр типа (type parameters) - переменные указанные вместо типа (например, T) при определении обобщенного типа или метода.
T — это тип переменной, которое применяется в исходном тексте во всех местах, где используется соответствующий тип данных.

Аргумент-типа (type arguments) - конкретные указанные типы, подставляемые вместо параметров-типа. 
`List<DateTime> dtList = new List<DateTime>();` DateTime - аргумент-типа

```ad-note
title:Примечание
collapse:
В рекомендациях Microsoft для проектировщиков указано, что переменные параметров должны называться **T** или, в крайнем случае, **начинаться с T** (как, например, TKey или TValue). T означает тип (type).
```

###### Преимущества обобщений:

1. Защита исходного кода
2. Безопасность типов
Использование объектов совместимых с указанным типом данных.
3. Более простой и понятный код.
Т.к. тип заранее известен требуется меньше операций приведения типов.
4. Повышение производительности
До появления обобщений один из способов определения обобщенного алгоритма заключался в таком определении всех его членов, чтобы они «умели» работать с типом данных Object. Чтобы алгоритм работал с экземплярами значимого типа, перед вызовом членов алгоритма среда CLR должна была упаковать этот экземпляр. Упаковка требует выделения памяти в управляемой куче, что приводит к более частым процедурам уборки мусора, а это, в свою очередь, снижает производительность приложения.

#### Открытые и закрытые типы

Для обобщённых типов CLR также создаёт объект-типы(type objects). 

Тем не менее:


   ###### Открытый тип
Тип с любыми обобщенными параметрами-типами называют *открытым типом (open type)* 
```csharp
Dictionary<T,U> //(поскольку T и U являются параметрами-типа)
Dictionary<string,T>//(поскольку T параметром-типа)

```
- В CLR **запрещено** конструирование экземпляров открытых типов (как и экземпляров интерфейсных типов).

###### Закрытый тип.
Тип со всеми аргументами-типами называют *закрытым типом (closed type)* 
```csharp
Dictionary<string,int>
```
- В CLR **разрешено** создание экземпляров закрытых типов.


###### Сконструированный тип.
Тип который включает **все** любые(обобщённые параметры-типа, необобщенные параметры), необходимые аргументы типа, называется *сконструированным типом(constructed type)*
```csharp
Dictionary<T,U> //(поскольку предоставляются два аргумента типа)
Dictionary<string,T> //(поскольку предоставляются два аргумента типа)
```
Понятие не сконструированный тип в спецификации языка отсутствует, но полагаясь на определение выше:
```cs
Dictionary<T,> //(поскольку предоставляются только один агумент вместо двух)
Dictionary<,T> //(поскольку предоставляются только один агумент вместо двух)
Dictionary<,> //(поскольку предоставляются только один агумент вместо двух)
```

###### Несвязанный обобщённый тип.
Объявление обобщённого типа само по себе обозначает *несвязанный обобщённый тип(unbound generic type)*
```csharp
List<>
Dictionary<,>

//Их можно использовать с typeof и для рефлексии и позднего связывания.
typeof(List<>)
typeof(Dictionary<,>)
```
[Для чего нужны несвязанные обобщённые типы](https://rsdn.org/forum/dotnet/6373168.all)
Объявление универсального типа `List<>` подобно понятию объявления переменной `int num` 

###### Связанный тип.
Термин *связанный тип (bound type)* относится к необобщённому типу или сконструированному типу =>
необобщенные типы считаются как связанными, так и несвязанными.

###### Несвязанный тип.
Термин *несвязанный тип (unbound type)*  относится к необобщённому типу или несвязанному обобщённому типу

###### Примеры:
```csharp
A                             //не обобщённый,  связанный
A<U, V>                       //обобщённый,     связанный,  открытый,   сконструированный
A<int, V>                     //обобщённый,     связанный,  открытый,   сконструированный
A<int, int>                   //обобщённый,     связанный,  закрытый,   сконструированный
A<,> (used like typeof(A<,>)) //обобщённый,     не связанный
```

###### Арность(arity) типа.
Число параметров типа необходимых для данного обобщённого типа. Арность следует за одиночной кавычкой **`**
```cs
List<int> lst = new List<int>();
//Арность класса List равна 1, потому что для него требуется определить тип T
Console.WriteLine(lst);//System.Collections.Generic.List`1[System.Int32]

//Арность класса Dictionary равна 2, потому что для него требуется определить типы TKey и TValue
Dictionary<string,int> dict = new Dictionary<string, int>();
Console.WriteLine(dict);//System.Collections.Generic.Dictionary`2[System.String,System.Int32]
```

#### Реализация обобщенных типов в CLR

При JIT-компиляции обобщенного метода CLR подставляет в IL-код метода **указанные аргументы-типы**, а затем создает машинный код для данного метода, работающего с конкретными типами данных.

Недостатком такого подхода стало, то что CLR генерирует машинный код **для каждого сочетания «метод + тип»**, что приводит к **разрастанию кода (code explosion)**. В итоге существенно увеличивается рабочий набор приложения, **снижая производительность.**

##### Механизмы оптимизации, призванных предотвратить разрастание кода:

Если метод вызывается для конкретного аргумента типа и позже он вызывается опять с тем же аргументом типа, CLR компилирует код для такого сочетания «метод + тип» только один раз. Поэтому, если `List<DateTime>` используется в двух совершенно разных сборках (загруженных в один домен приложений), CLR компилирует методы для List всего один раз.

##### Ссылочные типы:

CLR считает все аргументы ссылочного типа тождественными, что опять же обеспечивает совместное использование кода. Например, код, скомпилированный в CLR для методов `List<String>`, может применяться для методов `List<Stream>`, потому что String и Stream — ссылочные типы

CLR выполняет эту оптимизацию, потому что все аргументы и переменные ссылочного типа — это просто указатели на объекты в куче, а все операции с указателями на объекты выполняются одинаково.

Как мы знаем int[] и string являются ссылочными типами данных и для них CLR генерирует одинаковый код.

Обобщённый класс
```csharp
class BasicStack<T>
{
	private T[] items;
	private int topIndex;
	public BasicStack(int capacity = 42)
	{
		items = new T[capacity];
	}
	public void Push(T item)
	{
		items[topIndex++] = item;
	}
	public T Pop()
	{
		return items[--topIndex];
	}
}

public static void Main()
{
	BasicStack<string> basicStackString= new BasicStack<string>();
	basicStackString.Push("a");
	basicStackString.Pop();

	BasicStack<int[]> basicStackIntArray= new BasicStack<int[]>();
	basicStackIntArray.Push(new int[] { 1, 2, 3 });
	basicStackIntArray.Pop();
}
```

Методы Push() и Pop() будут одинаковыми для объектов basicStackString и basicStackIntArray.

WinDbg:
`BasicStack<string>`
![Pasted image 20230522185022.png](/img/user/Files/Image/Pasted%20image%2020230522185022.png)
`BasicStack<int[]>`
![Pasted image 20230522185032.png](/img/user/Files/Image/Pasted%20image%2020230522185032.png)


<span class="G">Адреса методов</span> одинаковы, что подтверждает то, что ссылочные реализации List совместно используют один общий метод

##### Значимые типы:
Если аргументы типа относятся к значимому типу, среда CLR должна сгенерировать машинный код именно для этого значимого типа. Это объясняется тем, что у значимых типов может быть **разный размер**. 
=>Реализации методов для типов значений имеют разный код.

И даже если два значимых типа имеют одинаковый размер (например, Int32 и UInt32 — это 32-разрядные значения), CLR все равно не может использовать для них единый код, потому что для обработки этих значений могут применяться разные машинные команды

```csharp
public static void Main()
{
	BasicStack<int> basicStackInt = new BasicStack<int>();
	basicStack2.Push(1);
	basicStack2.Pop();

	BasicStack<double> basicStackDouble= new BasicStack<double>();
	basicStack3.Push(1.0);
	basicStack3.Pop();
}
```


WinDbg:

`BasicStack<int>`
![Pasted image 20230522191209.png](/img/user/Files/Image/Pasted%20image%2020230522191209.png)

`BasicStack<double>`
![Pasted image 20230522191215.png](/img/user/Files/Image/Pasted%20image%2020230522191215.png)
<span class="B">Адрес метода</span> и <span class="O">адрес метода</span>  отличны, что подтверждает то, что реализации типов значений имеют разные версии методов.


