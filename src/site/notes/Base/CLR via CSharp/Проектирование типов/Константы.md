---
{"dg-publish":true,"permalink":"/base/clr-via-c-sharp/proektirovanie-tipov/konstanty/"}
---


Константа (constant) — это идентификатор, значение которого **никогда не меняется**. Значение, связанное с именем константы, должно определяться во **время компиляции**. Затем компилятор сохраняет значение константы в метаданных модуля. Это значит, что константы можно определять только для таких типов, которые компилятор считает примитивными и также для типов не относящихся к примитивным если им присвоить значение null `public const SomeType Empty = null`.

Константы считаются **статическими**, а не экземплярными членами. Определение константы приводит в конечном итоге к созданию метаданных

Встретив в исходном тексте имя константы, компилятор просматривает метаданные модуля, в котором она определена, извлекает значение константы и внедряет его в генерируемый им **IL-код**.
Метод Main:
![Pasted image 20230318173600.png](/img/user/Files/Image/Pasted%20image%2020230318173600.png)

Метаданные:
![Pasted image 20230318173507.png](/img/user/Files/Image/Pasted%20image%2020230318173507.png)

Особенности констант:
- Значение константы внедряется прямо в код, в период выполнения память для констант не выделяется. 
- Нельзя получать адрес константы и передавать ее по ссылке

Управление версиями:
Из первого пункта списка следует вывод, о том, что если какая-либо программа будет оперировать константами из другой DLL-сборки и если разработчик поменяет значение константы и перекомпилирует  DLL-сборку при этом не перекомпилировав приложение, то это не повлияет на код самого приложения, оно буде использовать старое значение констант т.к. они встроены в IL-код самого приложения. 

Сторонняя DLL-библиотека

```csharp
public sealed class Program
{
	public static void Main()
	{
		Console.WriteLine("Max entries supported in list const: "
		+ SomeLibraryType.MaxEntriesInListConst);

		SomeLibraryType ob=new SomeLibraryType(); 
		Console.WriteLine("Max entries supported in list no const: "
		+ ob.MaxEntriesInListNoConst);
	}
}
```

```csharp
namespace OtherDll
{
	public sealed class SomeLibraryType
	{
		//Константа
		public const Int32 MaxEntriesInListConst = 10;
		//Экземплярное поле
		public Int32 MaxEntriesInListNoConst = 20;
	}
}
```

Вывод:
![Pasted image 20230318174549.png](/img/user/Files/Image/Pasted%20image%2020230318174549.png)

После изменение значение констант и **перекомпиляции только DLL-сборки**
```csharp
namespace OtherDll
{
	public sealed class SomeLibraryType
	{
		//Константа
		public const Int32 MaxEntriesInListConst = -500;
		//Экземплярное поле
		public Int32 MaxEntriesInListNoConst = 800;
	}
}
```
Вывод:
![Pasted image 20230318174908.png](/img/user/Files/Image/Pasted%20image%2020230318174908.png)

![Pasted image 20230319190543.png](/img/user/Files/Image/Pasted%20image%2020230319190543.png)
Как видно значение экземплярного поля изменилось, т.к. оно содержится в куче, а константа нет, т.к. она напрямую содержится IL коде.

Чтобы сохранить принцип неизменяемости и при этом каждый не перекомпилировать приложение, можно воспользоваться модификатором [[Base/CLR via CSharp/Проектирование типов/Поля#^5366e7\|readonly]]

P.S: Чтобы проделать этот пример в VS нужно: скомпилировать DLL и в ручную скопировать в папку с вызывающей программой и при этом запускать программу через exe-шник, а не через VS.


Нельзя применять константы во время выполнения (а не во время компиляции), если модуль должен задействовать значение, определенное в другом модуле. В этом случае вместо констант следует использовать предназначенные только для чтения поля.