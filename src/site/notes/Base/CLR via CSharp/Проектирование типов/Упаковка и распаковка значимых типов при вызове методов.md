---
dg-publish: true
---

```csharp
internal struct Point : IComparable
{
	private Int32 m_x, m_y;
	// Конструктор, просто инициализирующий поля
	public Point(Int32 x, Int32 y)
	{
		m_x = x;
		m_y = y;
	}
	// Переопределяем метод ToString, унаследованный от System.ValueType
	public override String ToString()
	{
		// Возвращаем Point как строку (вызов ToString предотвращает упаковку)
		return String.Format("({0}, {1})", m_x.ToString(), m_y.ToString());
	}
	// Безопасная в отношении типов реализация метода CompareTo
	public Int32 CompareTo(Point other)
	{
		// Используем теорему Пифагора для определения точки,
		// наиболее удаленной от начала координат (0, 0)
		return Math.Sign(Math.Sqrt(m_x * m_x + m_y * m_y)
		- Math.Sqrt(other.m_x * other.m_x + other.m_y * other.m_y));
	}
	// Реализация метода CompareTo интерфейса IComparable
	public Int32 CompareTo(Object o)
	{
		if (GetType() != o.GetType())
		{
			throw new ArgumentException("o is not a Point");
		}
		// Вызов безопасного в отношении типов метода CompareTo
		return CompareTo((Point)o);
	}
}
public static class Program
{
	public static void Main()
	{
		// Создаем в стеке два экземпляра Point
		Point p1 = new Point(10, 10);
		Point p2 = new Point(20, 20);
		
		// p1 НЕ пакуется для вызова ToString (виртуальный метод)
		Console.WriteLine(p1.ToString()); // "(10, 10)"
										  
		// p1 ПАКУЕТСЯ для вызова GetType (невиртуальный метод)
		Console.WriteLine(p1.GetType()); // "Point"
		
		// p1 НЕ пакуется для вызова CompareTo
		// p2 НЕ пакуется, потому что вызван CompareTo(Point)
		Console.WriteLine(p1.CompareTo(p2)); // "-1"
		
		// p1 пакуется, а ссылка размещается в c
		IComparable c = p1;
		Console.WriteLine(c.GetType()); // "Point"
		
		// p1 НЕ пакуется для вызова CompareTo
	    // Поскольку в CompareTo не передается переменная Point,
		// вызывается CompareTo(Object), которому нужна ссылка
		// на упакованный Point
		// c НЕ пакуется, потому что уже ссылается на упакованный Point
		Console.WriteLine(p1.CompareTo(c)); // "0"
		
		// c НЕ пакуется, потому что уже ссылается на упакованный Point
		// p2 ПАКУЕТСЯ, потому что вызывается CompareTo(Object)
		Console.WriteLine(c.CompareTo(p2));// "-1"
		
		// c пакуется, а поля копируются в p2
		p2 = (Point)c;
		
		// Убеждаемся, что поля скопированы в p2
		Console.WriteLine(p2.ToString());// "(10, 10)"
	}
}
```

- Вызов ToString. При вызове ToString упаковка p1 не требуется. Казалось бы, тип p1 должен быть упакован, так как ToString — метод, унаследованный от базового типа, System.ValueType. Обычно для вызова виртуального метода нужен **указатель на типовой объект**, а поскольку p1 является неупакованным [[Base/CLR via CSharp/Проектирование типов/Значимые типы(value types)\|значимым типом]], то нет ссылки на типовой объект Point. Однако **JIT-компилятор видит**, что метод ToString переопределен в Point, и создает код, который напрямую (невиртуально) вызывает ToString. Компилятор знает, что полиморфизм здесь невозможен, коль скоро Point является значимым типом, а значимые типы не могут применяться для другого типа в качестве базового и по-другому реализовывать виртуальный метод. Ели бы метод ToString из Point во внутренней реализации вызывал base.ToString(), то экземпляр значимого типа был бы **упакован** при вызове метода ToString типа System.ValueType. 

- Вызов GetType. При вызове невиртуального метода GetType **упаковка p1 необходима**, поскольку тип Point **не реализует GetType**, а наследует его от System. Object. Поэтому для вызова GetType нужен указатель на типовой объект Point, который можно получить только путем упаковки p1. 

- Первый вызов CompareTo. При первом вызове CompareTo **упаковка p1 не нужна**, так как Point реализует метод CompareTo, и компилятор может просто вызвать его напрямую. Заметьте: в CompareTo передается переменная p2 типа Point, поэтому компилятор вызывает перегруженную версию CompareTo, которая принимает параметр типа Point. Это означает, что p2 передается в CompareTo по значению, и никакой упаковки не требуется. 

- Приведение типа к IComparable. **Когда выполняется приведение типа p1 к переменной интерфейсного типа (с), упаковка p1 необходима**, так как интерфейсы по определению имеют ссылочный тип. Поэтому выполняется упаковка p1, а указатель на этот упакованный объект сохраняется в переменной c. Следующий вызов GetType подтверждает, что c действительно ссылается на упакованный объект Point в куче. 

- Второй вызов CompareTo. При втором вызове CompareTo упаковка p1 не производится, потому что Point реализует метод CompareTo, и компилятор может вызывать его напрямую. Заметьте, что в CompareTo передается переменная с интерфейса IComparable, поэтому компилятор вызывает перегруженную версию CompareTo, которая принимает параметр типа Object. Это означает, что передаваемый параметр должен **являться указателем**, ссылающимся на объект в куче. К счастью, с **уже ссылается на упакованный объект** Point, по этой причине адрес памяти из c может передаваться в CompareTo и никакой дополнительной упаковки не требуется. 

- Третий вызов CompareTo. При третьем вызове CompareTo переменная c уже ссылается на упакованный объект Point в куче. Поскольку переменная c сама по себе имеет **интерфейсный тип** IComparable, можно вызывать только метод CompareTo интерфейса, а ему **требуется параметр Object**. Это означает, что **передаваемый аргумент должен быть указателем**, ссылающимся на объект в куче. Поэтому выполняется упаковка p2 и указатель на этот упакованный объект передается в CompareTo. 

- Приведение типа к Point. Когда выполняется приведение c к типу Point, объект в куче, на который указывает c, **распаковывается**, и его поля **копируются из кучи в p2**, экземпляр типа Point, **находящийся в стеке**. 


### Попытка изменения полей в упакованных значимых типах

```csharp
using System;
// Point - значимый тип.
internal struct Point
{
	private Int32 m_x, m_y;
	public Point(Int32 x, Int32 y)
	{
		m_x = x;
		m_y = y;
	}
	public void Change(Int32 x, Int32 y)
	{
		m_x = x; m_y = y;
	}
	public override String ToString()
	{
		return String.Format("({0}, {1})", m_x.ToString(), m_y.ToString());
	}
}
public sealed class Program
{
	public static void Main()
	{
		Point p = new Point(1, 1);
		Console.WriteLine(p);//2,2
		p.Change(2, 2);
		Console.WriteLine(p);//2,2
		Object o = p;
		Console.WriteLine(o);
		((Point)o).Change(3, 3);//Не влияет на упакованный объект Point
		Console.WriteLine(o);//2,2
	}
}
```


Main создает в стеке экземпляр p типа Point и устанавливает его поля m_x и m_y равными 1. 
Затем p пакуется до первого обращения к методу WriteLine, который вызывает ToString для упакованного типа Point, в результате выводится, как и ожидалось, (1, 1). 

Затем p применяется для вызова метода Change, который изменяет значения полей m_x и m_y объекта p в стеке на 2. При втором обращении к WriteLine, как и предполагалось, выводится (2, 2). 

Затем p упаковывается в третий раз — o ссылается на упакованный объект типа Point. При третьем обращении к WriteLine снова выводится (2, 2), что опять вполне ожидаемо. 

При обращении к методу Change для изменения полей в упакованном объекте типа Point. Между тем Object (тип переменной o) ничего не «знает» о методе Change, так что сначала нужно привести o к Point. При таком приведении типа o распаковывается, и поля упакованного объекта типа Point **копируются во временный объект типа Point в стеке потока**. Поля m_x и m_y этого временного объекта устанавливаются равными 3, но это обращение к Change **не влияет на упакованный объект Point**. При обращении к WriteLine снова выводится (2, 2). 


>Преобразование упаковки(boxing) подразумевает создание копии упакованного значения. Это отличается от преобразования ссылочного типа в объект типа, при котором значение продолжает ссылаться на тот же экземпляр и просто рассматривается как менее производный объект типа.

[Более подробно](https://stackoverflow.com/questions/5812099/why-does-calling-an-explicit-interface-implementation-on-a-value-type-cause-it-t)