---
{"dg-publish":true,"permalink":"/base/clr-via-c-sharp/proektirovanie-tipov/chastichnye-metody-partial-method/"}
---


Представим что есть программа. Этой программе известно, что внутри программного кода есть места, в которых вы хотели бы настроить поведение типа на поздней стадии.
То оставить для себя возможность повлиять на поведение типа потом или не повлиять.

##### Решение с использованием виртуальных методов.

Обычно такая настройка производится при помощи виртуальных методов, вызываемых сгенерированным кодом.

Программа:
```csharp
// Сгенерированный код в некотором файле с исходным кодом:
internal class Base
{
	private String m_name;
	// Вызывается перед изменением поля m_name
	protected virtual void OnNameChanging(String value)
	{
	}
	public String Name
	{
		get { return m_name; }
		set
		{
			// Информирует класс о возможных изменениях
			OnNameChanging(value.ToUpper());
			m_name = value; // Изменение поля
		}
	}
}
```

Написанный программистом код из другого файла в целях настроит поведения типа. То есть тут мы можем использовать любой код. К примеру сделать валидацию пароля или логина.
```csharp

internal class Derived : Base
{
	protected override void OnNameChanging(string value)
	{
		if (String.IsNullOrEmpty(value))
			throw new ArgumentNullException("value");
	}
}
```

Использование:

```csharp
Derived b=new Derived();
b.Name = "";
Console.WriteLine(b.Name);
```
Если мы бы захотели то, оставили метод Derived:Base пустым

Недостатки данного подхода
- Тип не должен быть запечатанным (sealed) классом. 
- Нельзя использовать этот подход для статических методов, потому что они не могут переопределяться. 
- Существует проблема эффективности. Тип, определяемый только для переопределения метода, понапрасну расходует некоторое количество системных ресурсов. И даже если вы не хотите переопределять поведение типа OnNameChanging, код базового класса по-прежнему вызовет виртуальный метод, который помимо возврата управления ничего больше не делает. Метод ToUpper вызывается и тогда, когда OnNameChanging получает доступ к переданным аргументам, и тогда, когда не получает.

##### Решение с использованием частичных методов.

Частичный метод имеет свою сигнатуру, определенную в одной части частичного типа, и свою реализацию, определенную в другой части типа.

Частичные методы позволяют разработчикам классов предоставлять методы-хуки, похожие на обработчики событий, которые разработчики могут решить реализовать или нет. 

Если разработчик не предоставляет реализацию, компилятор удаляет сигнатуру во время компиляции. К частичным методам применяются следующие условия:

- Подписи в обеих частях частичного типа должны совпадать.
- Метод должен возвращать void.
- Модификаторы доступа не допускаются. Частичные методы неявно являются закрытыми


Программа:

```csharp
internal sealed partial class Base
{
	private String m_name;
	// Это объявление с определением частичного метода вызывается
	// перед изменением поля m_name
	partial void OnNameChanging(String value);
	public String Name
	{
		get { return m_name; }
		set
		{
			// Информирование класса о потенциальном изменении
			OnNameChanging(value.ToUpper());
			m_name = value; // Изменение поля
		}
	}
}
```

Написанный программистом код из другого файла в целях настроит поведения типа.

```csharp
internal sealed partial class Base
{
	// Это объявление с реализацией частичного метода вызывается перед тем,
	// как будет изменено поле m_name
	partial void OnNameChanging(String value)
	{
		if (String.IsNullOrEmpty(value))
			throw new ArgumentNullException("value");
	}
}
```
Код, сгенерированный программой, и код, написанный программистом, на самом деле являются двумя частичными определениями, которые в конце концов образуют одно определение типа.


Плюсы данного подхода:
- Теперь класс запечатан (хотя это и необязательно). В действительности класс мог бы быть статическим классом или даже значимым типом.
- При отсутствии объявления выполняемого частичного метода компилятор не будет генерировать метаданные, представляющие частичный метод и удалить сигнатуру(определение) данного метода.

Преимущества частичных методов:

К примеру у нас нет нужны настраивать поведение типа и мы решили не реализовывать частичный метод OnNameChanging. Тогда компилятор создаст IL код как будто у нас вообще **не был объявлен** частичный метод OnNameChanging.

```csharp
// Логический эквивалент сгенерированного инструментом кода в случае,
// когда нет объявления выполняемого частичного метода
internal sealed class Base
{
	private String m_name;
	public String Name
	{
		get { return m_name; }
		set
		{
			m_name = value; // Измените поле
		}
	}
}
```
![Pasted image 20230430162421.png](/img/user/Files/Image/Pasted%20image%2020230430162421.png)


> При отсутствии объявления выполняемого частичного метода компилятор не будет генерировать метаданные, представляющие частичный метод. К тому же компилятор не сгенерирует IL-команды вызова частичного метода, он не сгенерирует код, вычисляющий аргументы, которые необходимо передать частичному методу(не сгенерирует код для вызова метода ToUpper).
![Pasted image 20241022175438.png](/img/user/Files/Image/Pasted%20image%2020241022175438.png)

Ограничения на частичные методы:
- Они могут объявляться только внутри частичного класса или структуры.
- Они не могут иметь модификаторы доступа
- Они имеют тип void
- Они не могут иметь out-параметры
- Они не могут иметь модификаторы virtual, override, sealed, new или extern

Если же они не соответствуют какому-то из этих ограничений, то для них должна быть предоставлена реализация.