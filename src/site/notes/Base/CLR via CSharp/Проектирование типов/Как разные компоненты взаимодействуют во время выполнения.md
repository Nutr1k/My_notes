---
{"dg-publish":true,"permalink":"/base/clr-via-c-sharp/proektirovanie-tipov/kak-raznye-komponenty-vzaimodejstvuyut-vo-vremya-vypolneniya/"}
---


**[адрес возврата]** - то куда нужно вернуть управление
**[адрес возврата]**  в самом верху присутствует т.к. метод М1 тоже кто-то вызвал(например метод Main) и после выполнения метода М1 нужно вернуть управление в вызывающий метод.

### Пример 1.

#### 1.
Потоку выделяется стек размеров в **1 Мбайт**. Выделенная память используется для передачи параметров в методы и хранения определенных в пределах методов локальных переменных.
![Pasted image 20230221161809.png](/img/user/Files/Image/Pasted%20image%2020230221161809.png)

Стеки заполняются от области верхней памяти к области нижней памяти (то есть от старших к младшим адресам).

#### 2.
В начале выполнения метода M1 его входной код выделяет в стеке потока память для локальной переменной _name_.
![Pasted image 20230221161932.png](/img/user/Files/Image/Pasted%20image%2020230221161932.png)

#### 3.
Далее M1 вызывает метод M2, передавая в качестве аргумента локальную переменную _name_. При этом адрес локальной переменной <u>name заталкивается в стек</u>, так же <u>адрес возврата в вызывающий метод</u> также заталкивается в стек.

![Pasted image 20230221162526.png](/img/user/Files/Image/Pasted%20image%2020230221162526.png)

Внутри метода M2 местоположение стека хранится в переменной-параметре _s_. 

#### 4.
В начале выполнения метода M2 его входной код выделяет в стеке потока память для локальных переменных length и tally. Затем выполняется код метода M2. 

![Pasted image 20230221162741.png](/img/user/Files/Image/Pasted%20image%2020230221162741.png)

#### 5.
В конце концов, выполнение M2 доходит до <u>команды возврата</u>, которая записывает в указатель команд процессора <u>адрес возврата из стека</u>, и стековый кадр M2 <u>возвращается в прежнее состояние</u> (до вызова метода M2):

![Pasted image 20230221162904.png](/img/user/Files/Image/Pasted%20image%2020230221162904.png)

С этого момента продолжается выполнение кода M1, который следует сразу за вызовом M2, а стековый кадр метода находится в состоянии, необходимом для работы M1.

#### 6.

В конечном счете, метод M1 <u>возвращает управление вызывающей программе</u>, устанавливая указатель команд процессора на <u>адрес возврата</u>, и стековый кадр M1 возвращается в предыдущее состояние:
![Pasted image 20230221163212.png](/img/user/Files/Image/Pasted%20image%2020230221163212.png)

С этого момента продолжается выполнение кода <u>вызвавшего метода</u>, причем начинает выполняться код, непосредственно <u>следующий за вызовом M1</u>, а стековый кадр вызвавшего метода находится в состоянии, необходимом для его работы.

### Пример 2.

Допустим есть следующе два определения классов:

```csharp
internal class Employee
{
	public Int32 GetYearsEmployed() { ... }
	public virtual String GetProgressReport() { ... }
	public static Employee Lookup(String name) { ... }
}
internal sealed class Manager : Employee
{
	public override String GenProgressReport() { ... }
}
```

#### 1.
Процесс Windows загрузился в него загружена <u>исполняющая среда CLR</u>, инициализирована<u> управляемая куча</u>, и создан <u>поток</u> с его 1 Мбайтом в стеке. Поток уже выполняет какой-то код, из которого вызван метод М3:
![Pasted image 20230221175954.png](/img/user/Files/Image/Pasted%20image%2020230221175954.png)

В процессе преобразования IL-кода метода М3 в машинные команды <u>JIT-компилятор выявляет все типы</u>, на которые есть ссылки в M3, — это типы Employee, Int32, Manager и String (из-за наличия строки "Joe"). На данном этапе CLR обеспечивает <u>загрузку в домен приложений всех сборок</u>, в которых определены все эти типы. Затем, <u>используя метаданные сборки, CLR получает информацию о типах и создает структуры данных</u>, собственно и представляющие эти типы.

#### 2.
CLR создает внутренние объект-типы для ссылочных типов (классов), значимых типов (структур), интерфейсов и делегатов.
Структуры данных для <u>объектов-типов</u> Employee и Manager. 
(Поскольку до вызова M3 поток уже выполнил какой-то код, для простоты допустим, что объекты-типы Int32 и String уже созданы (что вполне возможно, так как это часто используемые типы) поэтому они не показаны на рисунке.)
![Pasted image 20230221180251.png](/img/user/Files/Image/Pasted%20image%2020230221180251.png)

Все объекты в куче содержат два дополнительных члена: **указатель на объект-тип** и **индекс блока синхронизации**. В объектах типа Employee и Manager оба эти члена присутствуют. При определении типа можно включить в него <u>статические поля данных</u>. 
Байты для этих статических полей выделяются **в составе самих объектов-типов**. 

Наконец, у каждого объекта-типа есть <u>таблица методов</u> с входными точками всех методов, определенных в типе. Так как в типе Employee определены три метода (GetYearsEmployed, GenProgressReport и Lookup), в соответствующей таблице методов есть три записи. В типе Manager определен один метод (переопределенный метод GenProgressReport), который и представлен в таблице методов этого типа.

#### 3.

После того как среда CLR создаст все необходимые для метода **объекты-типы** и откомпилирует код метода M3, она приступает к выполнению машинного кода M3. 

При выполнении входного кода M3 в стеке потока выделяется память для локальных переменных . В частности, <u>CLR автоматически инициализирует все локальные переменные значением null или 0 (нулем)</u> — это делается в рамках выполнения входного кода метода. Однако при попытке обращения к локальной переменной, неявно инициализированной в вашем коде, компилятор С# выдаст сообщение об ошибке Use of unassigned local variable (использование неинициализированной локальной переменной).
![Pasted image 20230221180744.png](/img/user/Files/Image/Pasted%20image%2020230221180744.png)

#### 4.

Далее M3 выполняет код **создания объекта Manager**. При этом в управляемой куче создается **экземпляр типа Manager,** то есть объект Manager. У объекта Manager — так же как и у всех остальных объектов — есть **указатель на объект-тип** и **индекс блока синхронизации**. У этого объекта тоже есть байты, необходимые для размещения всех **экземплярных полей данных**, определенные в типе Manager, а также всех **экземплярных полей, определенных во всех базовых классах** типа Manager (в данном случае — Employee и Object). 

Всякий раз при создании нового объекта в куче CLR автоматически инициализирует внутренний указатель на объект-тип так, чтобы он указывал на соответствующий объект-тип (в данном случае — на объект-тип Manager). 

Кроме того, CLR инициализирует индекс блока синхронизации и присваивает всем экземплярным полям объекта значение null или 0 (нуль) **перед вызовом конструктора типа** — метода, который, скорее всего, изменит значения некоторых экземплярных полей. Оператор new возвращает адрес в памяти объекта Manager, который хранится в переменной e (в стеке потока).

![Pasted image 20230221181115.png](/img/user/Files/Image/Pasted%20image%2020230221181115.png)

#### 5.

Следующая строка метода M3 вызывает статический метод Lookup объекта Employee. При вызове этого метода CLR определяет местонахождение **объекта-типа**, соответствующего типу, в <u>котором определен</u> статический метод. 

Затем на основании таблицы методов объекта-типа <u>среда CLR находит точку входа в вызываемый метод, обрабатывает код JIT-компилятором (при необходимости) и передает управление полученному машинному коду</u>. 

Для нашего обсуждения достаточно предположить, что метод Lookup объекта Employee выполняет запрос к базе данных, чтобы найти сведения о Joe. 
Допустим также, что в базе данных указано, что Joe занимает должность менеджера, поэтому код метода Lookup создает в куче <u>новый объект Manager</u>, инициализирует его данными Joe и возвращает адрес готового объекта. 
Адрес размещается в локальной переменной e.
![Pasted image 20230221181532.png](/img/user/Files/Image/Pasted%20image%2020230221181532.png)

#### 6.
Следующая строка метода M3 вызывает экземплярный метод GetYearsEmployed в Employee который возвращает значение 5.
![Pasted image 20230221182451.png](/img/user/Files/Image/Pasted%20image%2020230221182451.png)

#### 7.
Следующая строка метода M3 вызывает виртуальный экземплярный метод GenProgressReport в Employee. При вызове виртуального экземплярного метода CLR приходится выполнять некоторую **дополнительную работу**. 
1. Во-первых, CLR обращается к переменной, используемой для вызова, и затем следует по адресу вызывающего объекта. В данном случае переменная e указывает на объект Joe типа Manager. 
2. Во вторых, CLR проверяет у объекта внутренний указатель на **объект-тип**. Затем CLR находит в таблице методов **объекта-типа** запись вызываемого метода, обрабатывает код JIT-компилятором (при необходимости) и вызывает полученный машинный код.
В нашем случае <u>вызывается реализация метода GenProgressReport в Manager</u>, потому что e ссылается на объект Manager.
![Pasted image 20230221182306.png](/img/user/Files/Image/Pasted%20image%2020230221182306.png)

Заметьте, если метод Lookup в Employee обнаружит, что Joe — э<u>то всего лишь Employee, а не Manager</u>, то Lookup создаст объект Employee, в котором **указатель на объект-тип** ссылается на объект-тип Employee; это приведет к тому, что выполнится реализация GenProgressReport из Employee, а не из Manager.

> Другими словами, именно тип объекта, на который ссылаются (а не тип ссылки),
определяет, какая версия виртуального метода будет выполнена.
тип ссылки ob=new Тип объекта
\- _Герберт Шилдт_. _C#_ 4.0: полное руководство

#### 8.

![Pasted image 20230221195859.png](/img/user/Files/Image/Pasted%20image%2020230221195859.png)
Наверняка вы обратите внимание, что объекты типа Employee и Manager содержат указатели на **объекты-типы**. **По сути объекты-типы тоже являются объектами**. Создавая объект-тип, среда CLR должна его как-то инициализировать. Резонно спросить: «Какие значения будут присвоены при инициализации?» 

В общем, при своем запуске в процессе CLR сразу же создает специальный объект-тип для типа **System.Type** (он определен в MSCorLib.dll). 

<u>Объекты типа Employee и Manager являются «экземплярами» этого типа</u>, и по этой причине их **указатели на объекты-типы** инициализируются ссылкой на объект-тип System.Type. Конечно, объект-тип System.Type сам является объектом и поэтому также содержит указатель на объект-тип; значит, закономерно поинтересоваться, на что ссылается этот указатель. А ссылается он на самого себя, так как объект-тип System. Type сам по себе является «экземпляром» объекта-типа. Теперь становится понятно, как устроена и работает вся система типов в CLR. 

Кстати, метод **GetType** типа System.Object просто возвращает адрес, хранящийся в указателе на объект-тип заданного объекта. Иначе говоря, метод GetType возвращает указатель на объект-тип указанного объекта и именно поэтому можно определить истинный тип любого объекта в системе (включая объекты-типы).