---
dg-publish: true
---

Модификаторы определяют, на какие члены можно ссылаться из кода. 
В CLR имеется собственный набор возможных модификаторов доступа, но в каждом языке программирования существуют свои синтаксис и термины.


| CLR                                        | C#                  | Описание                                                                                                                         |
| ------------------------------------------ | ------------------- | -------------------------------------------------------------------------------------------------------------------------------- |
| Private (закрытый)                         | private             | Доступен только методам в определяющем типе и вложенных в него типах                                                             |
| Family (родовой, защищенный)               | protected           | Доступен только методам в определяющем типе (и вложенных в него типах) или в одном из его производных типов независимо от сборки |
| Family and Assembly (родовой и сборочный)  | (не поддерживается) | Доступен только методам в определяющем типе (и вложенных в него типах) и производных типах в определяющей сборке                 |
| Assembly (сборочный)                       | internal            | Доступен только методам в определяющей сборке(в которой он сам определён)                                                                                    |
| Assembly or Family (сборочный или родовой) | protected internal  | Доступен только методам вложенного типа, производного типа (независимо от сборки) и любым методам определяющей сборки            |
| Public (открытый)                          | public              | Доступен всем методам во всех сборках                                                                                            |
|                                            | private protected   | Доступен из любого места в своем классе или в производных классах, которые определены в той же сборке.                           |

![Pasted image 20230308185522.png](/img/user/Files/Image/Pasted%20image%2020230308185522.png)

Пояснения:
Под **непроизводным классом** понимается изменение объекта из другого класса:

"A.a_1" недоступен из-за его уровня защиты.
![Pasted image 20230308191807.png](/img/user/Files/Image/Pasted%20image%2020230308191807.png)


Проверка доступности типа или члена определяется два раза:
1.  **В процессе компиляции кода** компилятор языка проверяет корректность обращения кода к типам и членам. Обнаружив некорректную ссылку на какие-либо типы или члены, компилятор информирует об ошибке. 
2. **Во время выполнения** JIT-компилятор тоже проверяет корректность обращения к полям и методам при компиляции IL-кода в процессорные команды. Например, обнаружив код, неправильно пытающийся обратиться к закрытому полю или методу, JIT-компилятор генерирует исключение FieldAccessException или MethodAccessException соответственно.

Пример:
Другая, более вероятная возможность заключается в компиляции кода, обращающегося к открытому члену другого типа (другой сборки); если в период выполнения загрузится другая версия сборки, где модификатор доступа открытого члена заменен защищенным (protected) или закрытым (private), верификация обеспечит корректное управление доступом.

### Снижение ограничения доступа к члену

Компилятор C# требует чтобы у одинаковых членов базового и производного типов были одинаковые модификаторы доступа. Однако это ограничение языка C#, а не CLR.

При наследовании от базового класса CLR позволяет **снижать**, но не повышать ограничения доступа к члену.
Например, *защищенный(protected)* метод базового класса можно переопределить в производном классе в *открытый(public)*, но не в закрытый. 

Дело в том, что пользователь производного класса всегда может получить доступ к методу базового класса путем **приведения к базовому типу**. Если бы среда CLR разрешала устанавливать более жесткие ограничения на доступ к методу в производном типе, то эти ограничения бы элементарно обходились.

>Однако CLR разрешает повышать ограничение доступа, но в этом случае(когда производный класс переопределяет переменную базового класса с **повышением** ограничение доступа) просто будет вызываться член из базового класса.

```csharp
public class A
{
	public int a_1;
}

public class B:A
{
	private new int a_1;//переопределение поля a1
}
class Program
{  
	public static void Main() 
	{
		B ob=new B();
		ob.a_1 = 7;//используется поле из класса A,
				   //хотя в B его переопределили
	} 
}
```



