---
dg-publish: true
---

Типы данных, которые поддерживаются компилятором напрямую, называются **примитивными** (primitive types). У примитивных типов в CLR есть IL-команд для  работы с данными типами.  

[[Base/CLR via CSharp/Проектирование типов/Примитивные типы и типы значений\|Примитивные типы и типы значений]]

Также у них существуют прямые аналоги в библиотеке классов .NET Framework Class Library (FCL).

```csharp
int a = 0; // Самый удобный синтаксис 
System.Int32 a = 0; // Удобный синтаксис 
int a = new int(); // Неудобный синтаксис 
System.Int32 a = new System.Int32(); // Самый неудобный синтаксис
```

Примитивные типы в C# являются встроенными типами данных и включают в себя следующие типы:

-   Целочисленные типы: sbyte, byte, short, ushort, int, uint, long, ulong.
-   Типы с плавающей точкой: float, double, decimal.
-   Логический тип: bool.
-   Символьный тип: char.
-   Строка
-   object
-   dynamic

В таблице представлены типы **FCL** и соответствующие им примитивные типы C#. В других языках типам, удовлетворяющим общеязыковой спецификации (CLS), соответствуют аналогичные примитивные типы. Однако поддержка языком типов, не удовлетворяющих требованиям CLS, не обязательна.(То есть CLS совместимые языки могут не поддерживать типы не удовлетворяющих требованиям CLS )
[[Pasted image 20230222164528.png|Таблица]]

> Рихтер рекомендует избегать примитивных типов (int, string, short) и использовать имена FLC типов (Int32,String, Int16).

Компилятор C# неплохо разбирается в **примитивных типах** и применяет свои правила при компиляции кода. Иначе говоря, он распознает наиболее распространенные шаблоны программирования и генерирует такие IL-команды, благодаря которым исходный код работает так, как требуется.
Из-за этого этот код успешно скомпилируется, несмотря на то, System.Int32 и System.Int64, не являются производными друг от друга.

```csharp
Int32 i = 5; // 32-разрядное число 
Int64 l = i; // Неявное приведение типа к 64-разрядному значению
```


### Переполнение

C# разрешает неявное приведение типа, если это преобразование «безопасно», то есть не сопряжено с потерей данных; пример — преобразование из Int32 в Int64. Однако для преобразования с риском потери данных C# требует явного приведения типа. Для числовых типов «небезопасное» преобразование означает «связанное с потерей точности или величины числа».

Чтобы включить механизм управления процессом обработки переполнения на этапе компиляции, добавьте в командную строку компилятора параметр /checked+.
Чтобы точечно в коде указывать где следует проверять на переполнение следует использовать оператора checked и unchecked.

```csharp
UInt32 invalid = unchecked((UInt32) -1); // OK

Byte b = 100;                  // Выдается исключение 
b = checked((Byte) (b + 200)); // OverflowException

checked { 
	// Начало проверяемого блока 
	Byte b = 100; 
	b = (Byte) (b + 200); // Это выражение проверяется на переполнение 
}
```

###### Влияние переполнения  на работу методов:
Установка режима контроля переполнения не влияет на работу метода, вызываемого внутри оператора или инструкции **checked**, так как действие оператора (и инструкции) checked распространяется только на выбор IL-команд сложения, вычитания, умножения и преобразования данных. Например: 

```csharp
checked { 
// Предположим, SomeMethod пытается поместить 400 в Byte 
SomeMethod(400); 
// Возникновение OverflowException в SomeMethod 
// зависит от наличия в нем операторов проверки 
}
```

### Примитивный тип dynamic

Тип dynamic следует использовать тогда, когда тип объекта определяется не в момент компиляции программы, а в момент выполнения. Также он активно используется  для связи с компонентами, не реализованными на С#. 

Выражение **dynamic** реально имеет тот же тип, что и **System.Object**. Компилятор принимает операции с выражением как допустимые и не генерирует ни предупреждений, ни ошибок. Однако исключения могут быть выданы на этапе выполнения программы, если программа попытается выполнить недопустимую операцию

Когда ваш код вызывает член класса при помощи динамического выражения (переменной), компилятор создает специальный IL-код, который описывает желаемую операцию. Этот код называется полезной нагрузкой (payload). 

Во время выполнения программы он определяет существующую операцию для выполнения на основе действительного типа объекта, на который ссылается динамическое выражение (переменная).


```csharp
internal static class DynamicDemo
{
	public static void Main()
	{
		dynamic value;
		for (Int32 demo = 0; demo < 2; demo++)
		{
			value = (demo == 0) ? (dynamic)5 : (dynamic)"A";
			value = value + value;
			M(value);
		}
	}
	private static void M(Int32 n) { 
		Console.WriteLine("M(Int32): " + n); 
	}
	private static void M(String s) {
		Console.WriteLine("M(String): " + s); 
	}
}
```

У оператора **+** имеются операнды типа с пометкой dynamic. По этой причине компилятор С# генерирует код полезной нагрузки, который проверяет **действительный тип** переменной value во время выполнения и определяет, что должен делать оператор **+**.

Во время первого вызова оператора **+** значение его аргумента равно 5 (тип Int32), поэтому результат равен 10 (тоже тип Int32). Результат присваивается переменной value. Затем вызывается метод M, которому передается value. Для вызова метода M компилятор создает код полезной нагрузки, который на этапе выполнения будет проверять действительный тип значения переменной, переданной методу M. Когда value содержит тип Int32, вызывается перегрузка метода M, получающая параметр Int32. 

Во время второго вызова **+** значение его аргумента равно A (тип String), а результат представляет собой строку AA (результат конкатенации А с собой). Затем снова вызывается метод M, которому передается value. На этот раз код полезной нагрузки определяет, что действительный тип, переданный в M, является строковым, и вызывает перегруженную версию M со строковым параметром. 


Когда тип поля, параметр метода, возвращаемый тип метода или локальная переменная снабжаются пометкой dynamic, компилятор конвертирует этот тип в тип **System.Object** и применяет экземпляр System.Runtime.CompilerServices.DynamicAttribute к полю, параметру или возвращаемому типу в метаданных. 

Если локальная переменная определена как динамическая, то тип переменной также будет типом **Object**, но атрибут DynamicAttribute неприменим к локальным переменным из-за того, что они используются только внутри метода. 

Из-за того, что типы **dynamic и Object** <u>одинаковы</u>, вы не сможете создавать методы с сигнатурами, отличающимися только типами dynamic и Object. 

**Ошибка!**В Типе "Program" уже определяет член "Show" с такими же типами параметров.	
![Pasted image 20230306165445.png](/img/user/Files/Image/Pasted%20image%2020230306165445.png)

Тип dynamic можно использовать для определения аргументов типов обобщенных классов (ссылочный тип), структур (значимый тип), интерфейсов, делегатов или методов.

Когда вы это делаете, компилятор **конвертирует** тип dynamic в Object и применяет DynamicAttribute к различным частям метаданных, где это необходимо. Обратите внимание, что обобщенный код, который вы используете, уже скомпилирован в соответствии с типом Object, и динамическая отправка не осуществляется, поскольку компилятор не производит код полезной нагрузки в обобщенном коде.

Любое выражение может быть **явно** приведено к **dynamic**, поскольку все выражения дают в результате тип, производный от Object1. В общем случае компилятор не позволит вам написать код с неявным приведением выражения от типа Object к другому типу, вы должны использовать явное приведение типов.

Однако компилятор разрешит выполнить приведение типа dynamic к другому типу с использованием синтаксиса неявного приведения. 

```csharp
Object o1 = 123; // OK: Неявное приведение Int32 к Object (упаковка) 
Int32 n1 = o1; // Ошибка: Нет неявного приведения Object к Int32 
Int32 n2 = (Int32) o1; // OK: Явное приведение Object к Int32 (распаковка) 
dynamic d1 = 123; // OK: Неявное приведение Int32 к dynamic (упаковка) 
Int32 n3 = d; // OK: Неявное приведение dynamic к Int32 (распаковка)
```

```csharp
dynamic d = 123; 
var result = M(d); // 'var result' - то же, что 'dynamic result' 
```

Здесь компилятор позволяет коду компилироваться, потому что на этапе компиляции он не знает, какой из методов M будет вызван. Следовательно, он также не знает, какой тип будет возвращен методом M. Компилятор предполагает, что переменная result имеет **динамический тип**.

![Pasted image 20230306201713.png](/img/user/Files/Image/Pasted%20image%2020230306201713.png)


Компилятор C# на этапе выполнения программы генерирует код полезной нагрузки, основываясь на действительных типах объекта. Этот код полезной нагрузки использует класс, известный как компоновщик (runtime binder). Различные языки программирования определяют собственных компоновщиков, инкапсулируя в них правила языка. 

```csharp
// Находим метод, который подходит по типам аргументов
Type[] argTypes = newType[] { arg.GetType() };
MethodInfo method = target.GetType().GetMethod("Contains", argTypes);
// Вызываем метод с желаемым аргументом
Object[] arguments = newObject[] { arg };
Boolean result = Convert.ToBoolean(method.Invoke(target, arguments));
```

Если использовать тип C# dynamic, этот код можно значительно улучшить
с точки зрения синтаксиса.
```csharp
dynamic target = "Jeffrey Richter";
dynamic arg = "ff";
Boolean result = target.Contains(arg);
```



Код для компоновщика C# находится в сборке Microsoft.CSharp.dll, поэтому ссылка на эту сборку должна включаться в любой проект, использующий ключевое слово dynamic. Эта сборка ссылается на файл параметров по умолчанию, CSC.rsp. 

Код из этой сборки знает, что при применении оператора + применяется к двум объектам типа Int32 следует генерировать код сложения, а для двух объектов типа String — код конкатенации. 

Во время выполнения сборка Microsoft.CSharp.dll должна быть загружена в домен приложений, что снизит производительность приложения и повысит расход памяти. Кроме того, сборка Microsoft.SCharp.dll загружает библиотеки System.dll и System.Core.dll. А если вы используете тип dynamic для связи с COM-объектами, загружается и библиотека System.Dynamic.dll. И когда будет выполнен код полезной нагрузки, генерирующий динамический код во время выполнения, этот код окажется в сборке, названной анонимной сборкой динамических методов (Anonymously Hosted Dynamic Methods Assembly). Назначение этого кода заключается в повышении производительности динамических ссылок в ситуациях, в которых конкретное место вызова (call site) выдает много вызовов с динамическими аргументами, соответствующих одному типу на этапе выполнения.




