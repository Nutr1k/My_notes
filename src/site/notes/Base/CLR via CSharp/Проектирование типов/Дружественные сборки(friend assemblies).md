Аттрибут *InternalsVisibleTo* задает, что типы, видимые обычно только в пределах **текущей** [[Base/CLR via CSharp/Основы CLR/Cборка\|сборки]], являются видимыми для заданной **другой** сборки.

К примеру в компании есть группа *А*, определяющая набор полезных типов в одной сборке, и группа *Б*, использующая эти типы. Чтобы сборка группы *Б* могла использовать типы группы *А*, группа *А* должна определить все нужные второй группе типы как открытые. 

Однако это означает, что эти типы будут доступны абсолютно **всем сборкам**. В результате разработчики другой компании смогут написать код, использующий общедоступные типы, а это нежелательно.

То есть нам необходим способ, который бы позволил группе *А* определить свои типы как **внутренние (internal)**, но в то же время предоставить группе *Б* **доступ** к этим типам. Для таких ситуаций в CLR и C# предусмотрен механизм дружественных сборок (friend assemblies).


В процессе создания сборки можно указать другие сборки, которые она будет считать «друзьями», — для этого служит атрибут InternalsVisibleTo

```csharp
// Внутренние типы этой сборки доступны из кода двух следующих сборок
// (независимо от версии или региональных стандартов)
[assembly:InternalsVisibleTo("Wintellect, PublicKey=12345678...90abcdef")]
[assembly:InternalsVisibleTo("Microsoft, PublicKey=b77a5c56...1934e089")]
internal sealed class SomeInternalType { ... }
internal sealed class AnotherInternalType { ... }
```

`PublicKey` - Полный открытый ключ, а не только токен открытого ключа

Получение публичного ключа 
`sn -Tp имя_сборки.dll`

`SomeInternalType` и `AnotherInternalType` будут доступы из сборок `Wintellect` и `Microsoft`. 

Чтобы использовать `InternalsVisibleTo`со строго подписанной сборкой, сборки ваших "друзей" также должны быть строго подписаны. Однако  сборка без строгого имени может открыть внутреннюю часть "дружественной" сборки со строгим именем

Так же допускается использование со сборками без строгого имени(неподписанными сборками) 
```csharp
[assembly:InternalsVisibleTo("Other_Library")]
```

Без аттрибута `InternalsVisibleTo` это было бы невозможно т.к. класс помеченный модификатором доступа **internal** доступен только внутри сборки в которой он объявлен.

Обращение из сборки `Wintellect'.

```csharp
internal sealed class Foo
{
	private static Object SomeMethod()
	{
		// Эта сборка Wintellect получает доступ к внутреннему типу
		// другой сборки, как если бы он был открытым
		SomeInternalType sit = new SomeInternalType();
		return sit;
	}
}
```

