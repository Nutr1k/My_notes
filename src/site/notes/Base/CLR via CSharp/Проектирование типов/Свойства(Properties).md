Свойство — это член, предоставляющий гибкий механизм для обеспечения инкапсуляция данных. На самом деле это всего лишь пара методов доступа, определенных внутри типа.

Инкапсуляция данных означает, что поля типа ни в коем случае не следует открывать для общего бесконтрольного доступа.


Синонимы:
get, set - акссесоры, методы доступа
get- акцессор; set - мутатор
###### Способ обеспечения инкапсуляции №1.

С помощью методов доступа(accessor)

```csharp
public sealed class Employee
{
	private Int32 m_Age; // Поле стало закрытым

	//Метод доступа
	public Int32 GetAge()
	{
		return (m_Age);
	}

	//Метод доступа
	public void SetAge(Int32 value)
	{
		if (value < 0)
			throw new ArgumentOutOfRangeException("value", value.ToString(),
			"The value must be greater than or equal to 0");
		m_Age = value;
	}
}
```
Методы доступа (accessor) - методы, выполняющие функции оболочки для доступа к полю.

Методы доступа могут выполнять дополнительные проверки, гарантируя, что сведения о состоянии объекта никогда не будут искажены.

Минусы:
1. Длинный код
2. Для изменения значения приходиться вызывать метод

###### Способ обеспечения инкапсуляции №2.

С помощью свойств
```csharp
public sealed class Employee
{
	private Int32 m_Age;
	public Int32 Age
	{
		get { return (m_Age); }
		set
		{
			if (value < 0) // Ключевое слово value всегда
						   // идентифицирует передаваемое значение
				throw new ArgumentOutOfRangeException("value", value.ToString(),
				"The value must be greater than or equal to 0");
			m_Age = value;
		}
	}
}
```

Однако опустив(удалив) метод доступа(асессор) set, можно определить свойство, доступное только для чтения, а опуская(удаляя) только метод доступа(асессор) get, мы получим свойство, доступное только для записи

При компиляции компилятор обнаруживает свойство Age. Поскольку есть методы доступа get и set, компилятор генерирует в типе Employee два определения методов.

```csharp
public sealed class Employee
{
	private Int32 m_Age;
	
	public Int32 get_Age()
	{
		return m_Age;
	}
	public void set_Age(Int32 value)
	{
		if (value < 0)
		{ // value всегда идентифицирует новое значение
			throw new ArgumentOutOfRangeException("value", value.ToString(),
			"The value must be greater than or equal to 0");
		}
		m_Age = value;
	}
}
```

![Pasted image 20230510190108.png](/img/user/Files/Image/Pasted%20image%2020230510190108.png)

Помимо методов доступа, для каждого из свойств, определенных в исходном тексте, компиляторы генерируют в метаданных управляемого модуля запись с определением свойства. Такая запись содержит несколько флагов и тип свойства, а также ссылки на методы доступа get и set.
![Pasted image 20230510191042.png](/img/user/Files/Image/Pasted%20image%2020230510191042.png)

Поддержка свойств встроена в C#. Обнаружив код, пытающийся получить или задать свойство, компилятор генерирует вызов соответствующего метода. Если используемый язык не поддерживает свойства напрямую, к ним все равно можно обратиться **посредством вызова нужного метода доступа**.

IL код методов get, set:
![Pasted image 20230513180517.png|600](/img/user/Files/Image/Pasted%20image%2020230513180517.png)

###### Способ обеспечения инкапсуляции №3.
С помощью автоматически реализуемых свойства

```csharp
public sealed class Employee
{
	// Это свойство является автоматически реализуемым
	public String Name { get; set; }
}
```
Если объявить свойство и не обеспечить реализацию методов set и get, то компилятор C# автоматически реализует методы get_Name и set_Name для правильного возвращения значения из поля и назначения значения полю.

![Pasted image 20230510193404.png](/img/user/Files/Image/Pasted%20image%2020230510193404.png)
backing field - *резервное поле*


Автоматически реализуемые свойства нужны для поздней реализации логики работы асессоров.

Вы спросите, зачем это нужно, особенно в сравнении с обычным объявлением строкового поля Name? Между ними есть большая разница.

Любой программный код, имеющий доступ к этому свойству, вызывает методы get и set. Если вы позднее решите реализовать эти методы самостоятельно, заменив их реализацию, предложенную  компилятором по умолчанию, **то код, имеющий доступ к свойству, не нужно будет перекомпилировать**. 

Однако если объявить Name как поле и позднее заменить его свойством, то весь программный код, имеющий доступ к полю,** придется перекомпилировать**, поскольку он будет обращаться к методам свойства

Минусы:
1. Во время отладки нельзя установить точку останова
2. Имя *резервного поля* для AIP определяется компилятором, и он может менять это имя каждый раз, когда компилирует код, сводя на нет возможность десериализации экземпляров всех типов, содержащих автоматически реализуемые свойства


Разница между свойствами-методами и полями.

|                                     | Свойства | Поля |
| ----------------------------------- | :--------: | :----: |
| Всегда доступны для чтения/записи   | ✕        | ✓    |
| Может выдавать исключения           | ✓        | ✕    |
| Использование ref/out при передаче  | ✕        | ✓    |
| Что быстрее при обращении           | ✕        | ✓    |
| Постоянность возвращаемого значения | ✕        | ✓    |
| Возвращается ссылка                 | ✕        | ✓    |
| Возвращается копия                  | ✕        | ✓    |


### Важное отличие свойств от полей.

Когда вы обращаетесь к полю, вы обращаетесь к фактической структуре. Когда вы обращаетесь к ней через свойство, вы вызываете метод, который возвращает то, что хранится в свойстве. **В случае структуры, которая является типом значения, вы получите обратно копию структуры.**

Когда мы извлекаем значение структуры с помощью свойства, то мы получаем неявно копию этого значение и дальше уже работаем с этой копией. Из-за этого вызывающий код не влияет на значение структуры
```csharp
	someVariable = someObject.someProeprty;
	
	//Этот оператор в конечном итоге будут выполнены как
	var temp = someObject.somePropertyBackingField;
	someVariable = temp;



	someobject.someProperty = someVariable;
	
	//Этот оператор в конечном итоге будут выполнены как
	var temp = someObject.somePropertyBackingField; 
	temp= someVariable;
```

Если у тебя структурное поле объявлено действительно как поле (field), то операция присвоения модифицирует непосредственно поле структуры, то есть берет адрес поля и записывает непосредственно туда измененное значение, модифицируя структуру in place(на месте) и конкретное в ней поле.


Подробнее про реализацию свойств [Сслыка](https://stackoverflow.com/questions/18292087/accessing-and-changing-structs-as-property-vs-as-field)

Конечно, мы можем получать копию значения структуры, изменять её, а потом присваивать целую структуру через свойства(set).

```csharp

    someobject.someProperty = someVariable;

    //Чтобы вызывающий код изменял значения структуры нужно
	var temp = someObject.somePropertyBackingField; 
	temp= someVariable;
	someobject.someProperty=temp;
```




Ещё одно тонкое отличие свойства от поля состоит в том, что геттер возвращает вам _копию_ значения, в то время как при работе с полем вы получаете доступ непосредственно к переменной. При работе со полями reference-типов (то есть, тип которых есть класс) практической разницы нет, так как работа с объектом по копии ссылки не отличается от работы по оригиналу ссылки. Разница, однако, есть, когда **свойство является _изменяемой_ структурой**


```csharp
struct MutableStruct
{
	public int Value;
	public void SetValue(int newValue) { Value = newValue; }
}

class MutableStructHolder
{
	public MutableStruct Field;
	public MutableStruct Property { get; set; }
}

class Program
{
	static void Main(string[] args)
	{
		MutableStructHolder holder = new MutableStructHolder();
		// Меняет значение holder.Field
		holder.Field.SetValue(10);
		// Получает *копию* holder.Property и изменяет её
		holder.Property.SetValue(10);

		Console.WriteLine(holder.Field.Value);    // 10
		Console.WriteLine(holder.Property.Value); // 0
	}
}
```

```csharp
	static void Main(string[] args)
	{
		MutableStructHolder holder = new MutableStructHolder();
		// Меняет значение holder.Field
		holder.Field.SetValue(10);
		
		
		// Получает *копию* holder.Property и изменяет её
		holder.Property.SetValue(10);
	
		//Строка holder.Property.SetValue(10) аналогична этой:
		var temp = holder.Property;
		temp.SetValue(10);
		//или
		temp.Value = 10;
		
		Console.WriteLine(holder.Field.Value);    // 10
		Console.WriteLine(holder.Property.Value); // 0
	}
```

Нюанс заключается в том, что адрес поля теперь не взять и требуется взаимодействовать через методы get / set.  В этом случае, раньше можно было попытаться внести изменение, которое по факту модифицировало копию. Сейчас это стало сложнее и в большинстве случае, ты словишь ошибку CS1612, которая от тебя требует явного создания измененного экземпляра структуры и присвоения. 
Управление версиями:


###### Побочный эффект при отладке свойств в Visual Studio

Если свойство, а именно асессор get вычисляет какое-либо выражение или изменяет своё значение то, возникает побочный эффект. При каждом обращении к свойству в отладчике будет повторно производиться вычисление.

Пример:

```csharp
public sealed class Employee
{
	private int count;
	public int Count
	{
		get
		{
			return count++;
		}
		set
		{
			count = value;
		}
	}
}
```

Ctrl+Alt+Q
При нажатии кнопки пересчитать 4 раза:
![Pasted image 20230511181034.png](/img/user/Files/Image/Pasted%20image%2020230511181034.png)


Если начат отлаживать приведённый ниже код, то наводя указатель мыiи на условие будет вызываться асессор get который будет инкрементировать значение.
```csharp
if(ob.Count == 5)
{
	Console.WriteLine("Успех");//6
}

```
![Properties.gif](/img/user/Files/Image/Properties.gif)