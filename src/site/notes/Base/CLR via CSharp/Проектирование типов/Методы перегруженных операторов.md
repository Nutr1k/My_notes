CLR вообще ничего неизвестно о перегрузке операторов, она даже не знает что это оператор. 
Смысл операторов и код, который должен быть сгенерирован, когда тот или иной оператор встретится в исходном тексте, **определяется языком программирования**.

К примеру С# и Visual Basic исполняются в CLR.

| Оператор    | C#                      | Visual Basic         |
| :-----------: | :-----------------------: | :--------------------: |
| Неравенства | !=                      | <>                   |
|      ^           | «исключающее или» (XOR) | возведение в степень |
В C# для обозначения неравенства в C# используется оператор !=, а в Visual Basic — оператор <>


С точки зрения CLR перегруженные операторы представляют собой просто методы

Хотя CLR ничего не знает об операторах, среда указывает как языки программирования должны предоставлять доступ к перегруженным операторам, чтобы Методы перегруженных операторов могли легко использоваться в коде на разных языках программирования.

Требования CLR к перегруженным операторным методам:
- Были открытыми и статическими
Требования C# к перегруженным операторным методам:
- Чтобы у операторного метода тип, по крайней мере, одного из параметров или возвращаемого значения совпадал с типом, в котором определен операторный метод

###### Перегрузка унарных операторов
```csharp
public static возвращаемый_тип operator оператор|+|-|*|(тип_параметра операнд)
{  }
```

###### Перегрузка бинарных операторов:
```csharp
public static возвращаемый_тип operator оператор|+|-|*|(тип_параметра1 операнд1, тип_параметра2 операнд2)
{  }
```

Пример метода перегруженного оператора, заданного в определении класса C#:

```csharp
class Car
{
	public string Name { get; set; }
	public static Car operator+(Car car1, Car car2)
	{
		return new Car { Name = car1.Name +" "+ car2.Name };
	}
}
```

```csharp
static void Main(string[] args)
{
	Car bmw=new Car("BMW");
	Car Honda=new Car("Honda");
	Car unknownСar=bmw+Honda;
	Console.WriteLine(unknowCar.Name);//BMW Honda
}
```

Компилятор генерирует определение метода op_Addition и устанавливает в записи с определением этого метода флаг specialname, свидетельствующий о том, что это «особый» метод. 

Когда компилятор языка (в том числе компилятор C#) видит в исходном тексте оператор +, он исследует типы его операндов. 
![Pasted image 20230429144306.png|300](/img/user/Files/Image/Pasted%20image%2020230429144306.png)
При этом компилятор пытается выяснить, не определен ли для одного из них метод op_Addition с флагом specialname, параметры которого совместимы с типами операндов. Если такой метод существует, компилятор генерирует код, вызывающий этот метод, иначе возникает ошибка компиляции

![Pasted image 20230429144424.png](/img/user/Files/Image/Pasted%20image%2020230429144424.png)


##### Операторы и взаимодействие языков программирования

Не все языки программирования поддерживают перегрузку операторов. Для решения этой проблемы Microsoft рекомендует определять **открытые экземплярные методы с дружественными именами**, вызывающие методы перегруженных операторов в своей внутренней реализации.

Таким образом, показанный ранее тип Car можно было бы определить и так:

```csharp
class Car
{
	public string Name { get; set; }
	public static Car operator+(Car car1, Car car2)
	{
		return new Car { Name = car1.Name + car2.Name };
	}
	public static Car Add(Car car1, Car car2)
	{
		return car1 + car2;
	}
}
```
Список рекомендованных **дружественных имен** для всех методов операторов приводится в третьем столбце приведённых ниже таблиц.


Унарные операторы С# и CLS-совместимые имена. соответствующих методов
![Pasted image 20230429154906.png](/img/user/Files/Image/Pasted%20image%2020230429154906.png)

Бинарные операторы и их CLS-совместимые имена методов
![Pasted image 20230429154926.png](/img/user/Files/Image/Pasted%20image%2020230429154926.png)

Microsoft также использует методы с дружественными именами к примеру в System.Deciaml и даёт пояснения:

![Pasted image 20230429155629.png|600](/img/user/Files/Image/Pasted%20image%2020230429155629.png)

