Неуправляемый ресурс, unmanaged resources (Системные ресурс) — ресурс операционной системы которые могут быть выделены процессу.
К числу основных ресурсов вычислительных систем можно отнести: 


Примеры использования системных ресурсов:
- Типу `System.IO.FileStream` нужно открыть файл (системный ресурс) и сохранить его дескриптор. Затем при помощи этого дескриптора методы Read и Write данного типа работают с файлом
- Тип `System.Threading.Mutex` открывает мьютекс, являющийся объектом ядра Windows (системный ресурс), и сохраняет его дескриптор, который использует при вызове методов объекта Mutex

Управляемые ресурсы в основном означают "управляемую память", которая управляется сборщиком мусора. Когда у вас больше нет ссылок на управляемый объект (который использует управляемую память), сборщик мусора (в конце концов) освободит эту память для вас.

Неуправляемые ресурсы — это все, о чем сборщик мусора не знает. 
Например:
- Открыть файлы
- Открытые сетевые соединения
- Неуправляемая память



Финализация — это механизм позволяющий объекту выполнить корректную очистку системных ресурсов, прежде чем уборщик мусора освободит занятую им память.

Любой тип, использующий **системный ресурс** (файл, сетевое соединение, сокет, мьютекс и т. д.), должен поддерживать финализацию. 

Когда CLR определяет, что объект стал недоступным, ему предоставляется возможность выполнить **финализацию** с освобождением всех задействованных системных ресурсов, после чего объект будет возвращен в управляемую кучу.

Всеобщий базовый класс `System.Object` определяет защищенный виртуальный метод с именем `Finalize`. Когда уборщик мусора определяет, что объект подлежит уничтожению, он вызывает метод `Finalize` этого объекта (если он переопределен). 

Для определения метода финализации в С# перед именем класса нужно добавить знак тильды (~):
```csharp
internal sealed class SomeType
{
	// Метод финализации
	~SomeType()
	{
		 // Код метода финализации
	}
}
```

![Pasted image 20241122153828.png](/img/user/Files/Image/Pasted%20image%2020241122153828.png)

При изучении IL-кода метода Finalize также становится ясно, что код в теле метода генерируется в блок try, а вызов метода base.Finalize — в блок finally.


> [!warning] Вниание
>  В предыдущих версиях спецификации С# этот метод назывался `деструктором (destructor)`. Однако метод финализации работает совсем не так, как неуправляемый деструктор C++, что сбивает с толку многих разработчиков, переходящих с одного языка на другой. Беда в том, что разработчики ошибочно полагают, что использование синтаксиса деструктора означает в C# детерминированное уничтожение объектов типа, как это происходит в C++.
>  Но CLR не поддерживает детерминированное уничтожение, поэтому C# не может предоставить этот механизм 

#### Метод Dispose
Метод `Dispose()`  — используется для гарантированной очистки неуправляемых ресурсов.

Назначение метода его`Dispose()` — освободить неуправляемые ресурсы, выполнить общую очистку и указать, что финализатор, если он есть, не должен запускаться.

`Dispose()`  —  не удаляет управляемый объект из управляемой кучи. Единственный способ освобождения памяти в управляемой куче — уборка мусора.

Учтите, что гарантированное освобождение системных ресурсов возможно и без вызова Dispose. Рано или поздно оно все равно будет выполнено; вызов Dispose позволяет вам управлять тем, когда это произойдет

[Подробнее](https://stackoverflow.com/questions/4267729/what-happens-if-i-dont-call-dispose-on-the-pen-object/5555243#5555243)
[Подробнее](https://stackoverflow.com/questions/45036/will-the-garbage-collector-call-idisposable-dispose-for-me)
[Подробнее](https://stackoverflow.com/questions/1691846/does-garbage-collector-call-dispose)
[Подробнее](https://stackoverflow.com/questions/15157877/more-information-on-how-c-sharp-dispose-works)
[Подробнее](https://learn.microsoft.com/en-gb/dotnet/standard/garbage-collection/implementing-dispose#dispose-and-disposebool)



#### Внутренняя реализация финализации

1. Когда приложение создает новый объект, оператор new выделяет для него память из кучи. 
2. Если в типе объекта определен метод финализации, непосредственно перед вызовом конструктора экземпляра типа указатель на объект помещается в список финализации `(finalization list)` — внутреннюю структуру данных, находящуюся под управлением уборщика мусора. Каждая запись этого списка указывает на объект, для которого нужно вызвать метод финализации, прежде чем освободить занятую им память.


На рисунке показана куча с несколькими объектами. Объекты A, C, D, F достижимы из корней приложения,  остальные— нет. При создании объектов C, E, F, I и J система, обнаружив в их типах методы финализации, добавила указатели на эти объекты в список финализации.
![Pasted image 20241122185153.png](/img/user/Files/Image/Pasted%20image%2020241122185153.png)


Сначала уборщик мусора определяет, что объекты B, E, G, H, I и J — это мусор. Уборщик сканирует `список финализации` в поисках указателей на эти объекты. 

Обнаружив указатель, он извлекает его из `списка финализации` и добавляет в конец `очереди на финализацию (freachable queue)` — еще одной внутренней структуры данных уборщика мусора. Каждый указатель в этой очереди идентифицирует объект, готовый к вызову своего метода финализации.
![Pasted image 20241122185342.png](/img/user/Files/Image/Pasted%20image%2020241122185342.png)

На рисунке видно, что занятая объектами B, G и H память была освобождена, поскольку у них нет метода финализации. Однако память, занятую объектами E, I и J, освободить нельзя, так как их методы финализации еще не вызывались.

```ad-note
title:Поток для вызова методов финализации
collapse:
В CLR есть особый высокоприоритетный поток, выделенный для вызова методов финализации. Он нужен для предотвращения возможных проблем синхронизации, которые могли бы возникнуть при использовании вместо него одного из потоков приложения с обычным приоритетом. При пустой очереди на финализацию (это ее обычное состояние) данный поток бездействует. Но как только в ней появляются элементы, он активизируется и последовательно удаляет элементы из очереди, вызывая соответствующие методы финализации. Особенности работы данного потока запрещают исполнять в методе финализации любой код, имеющий какиелибо допущения о потоке, исполняющем код. Например, в методе финализации следует избегать обращения к локальной памяти потока.

Возможно, в будущем, CLR будет поддерживать множественные потоки финализации, поэтому следует избегать создания кода, в котором методы финализации вызываются последовательно. При наличии всего лишь одного потока финализации могут возникнуть проблемы производительности и масштабируемости в ситуации, когда финализируемые объекты распределяются между несколькими процессорами, но лишь один поток исполняет методы финализации — он может просто не успеть.
```




1. Если объект недоступен, уборщик считает его мусором. 
2. Когда уборщик перемещает ссылку на объект из списка финализации в очередь на финализацию, объект перестает считаться мусором, а это означает, что занятую им память освобождать нельзя. На этом этапе уборщик завершает поиск мусора, и некоторые объекты, идентифицированные как мусор, перестают считаться таковым — они как бы воскресают. 
3. По мере маркировки объектов из очереди на финализацию другие объекты, на которые ссылаются их поля ссылочного типа, также рекурсивно помечаются — все эти объекты должны пережить уборку мусора. На этой стадии уборщик мусора завершил выявление мусора, а некоторые объекты, отнесенные к мусору, были воскрешены. 
5. Уборщик мусора сжимает освобожденную память, воскрешенные объекты переводятся в более старое поколение, а особый поток CLR очищает очередь на финализацию, выполняя метод финализации для каждого объекта из очереди. 
6. Вызванный снова, уборщик обнаруживает, что финализированные объекты стали мусором, так как ни корни приложения, ни очередь на финализацию больше на них не указывают. Память, занятая этими объектами, попросту освобождается. Важно понять, что для освобождения памяти, занятой объектами, требующими финализации, уборку мусора нужно выполнить дважды. На самом деле может понадобиться и больше операций уборки мусора, поскольку объекты переходят в следующее поколение (но об этом — чуть позже).

На рисунке показан вид управляемой кучи после второй уборки мусора.
![Pasted image 20241122191450.png](/img/user/Files/Image/Pasted%20image%2020241122191450.png)

Алгоритм работы сборки мусора с объектами требующих финализацию:
1. Когда приложение создает новый объект, оператор new выделяет для него память из кучи. 
2. Если в типе объекта определен метод финализации, то непосредственно **в момент создания объекта** указатель на него помещается в список финализации `(finalization list).
3. Только что созданные объекты относятся к поколению 0.
4. По какой-либо причине инициируется уборка мусора.
5. Уборщик мусора определяет, какие объекты являются мусором. 
6. Уборщик сканирует `список финализации` в поисках есть ли в нём объекты идентифицированные на предыдущем шаге как мусор. 
7. Обнаружив такие объекты, он извлекает его из `списка финализации` и добавляет в конец `очереди на финализацию (freachable queue)`. Объект перестает считаться мусором, а это означает, что занятую им память освобождать нельзя и следовательно они **переживут сборку мусора**.
8. По мере маркировки объектов из очереди другие объекты, на которые ссылаются их поля ссылочного типа, также рекурсивно помечаются — все эти объекты должны пережить уборку мусора.
9. Уборщик мусора очищает память недоступных объектов(мусора) за исключением тех, которые есть в списке на финализацию.
10. Объекты **пережившие сборку мусора** переводятсяя в более старое поколение
11. Особый поток CLR очищает очередь на финализацию, выполняя метод финализации для каждого объекта из очереди.

Объектами, требующими финализации, уборку мусора нужно выполнить минимус дважды. На самом деле может понадобиться и больше операций уборки мусора, поскольку объекты переходят в следующее поколение, а когда уборщик мусора решит собрать его зависит от многих фактов.


