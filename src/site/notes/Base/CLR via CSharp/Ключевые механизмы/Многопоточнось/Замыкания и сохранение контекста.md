---
{"dg-publish":true,"permalink":"/base/clr-via-c-sharp/klyuchevye-mehanizmy/mnogopotochnos/zamykaniya-i-sohranenie-konteksta/"}
---

Изменённая цитата из книги:

Компилятор C#, встретив в программе оператор await, сохраняет определённые аспекты состояния метода. 
Запоминаются все локальные переменные метода, в том числе: 
• параметры метода; 
• все переменные, определенные в текущей области видимости; 
• все прочие переменные, например счетчики циклов; 
• переменную this, если метод не статический. 

В результате после возобновления метода окажутся доступны все переменные-члены класса. Всё это сохраняется в виде объекта в куче .NET, обслуживаемой сборщиком мусора. Таким образом, встретив await, компилятор выделяет память для объекта

> [!success] Пояснение
> Всё это храниться в стейт машине(`StateMachine`), но сама стейт машина хранить это в [[Base/CLR via CSharp/Ключевые механизмы/Многопоточнось/Замыкания(Closure)\|замыкания]].

Пример:
Всё то, что используется внутри await и после выполнения `await` сохраняется в замыканиях.
![Pasted image 20250115184235.png](/img/user/Files/Image/Pasted%20image%2020250115184235.png)

Весь тип с названием `<Main>d__0` — это и есть замыкание.

State Machine достаточная непростая концепция. Так что в этом случае достаточно ограничиться тем, что данные хранятся в замыканиях внутри State Machine.

Сохранение данных связанно с `SynchronizationContext`, но я нигде не нашёл явных ссылок на это.
https://devblogs.microsoft.com/dotnet/configureawait-faq/
https://easyoffer.ru/question/11384