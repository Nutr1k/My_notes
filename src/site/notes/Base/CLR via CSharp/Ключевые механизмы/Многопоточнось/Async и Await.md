---
dg-publish: true
---
### Async

1. Ключевое слово `async` указывает только на то, что метод может иметь внутри себя вызовы с ключевым словом `await`. Всё, больше ни на что оно не указывает. Будут там эти вызовы или нет - уж как напишете. Если вызовов `await` там нет, то метод явно не асинхронный.

```csharp
async void SimpleAsync() {} // пустой метод - обычный синхронный пустой метод
```

### Await
2. Ключевое слово `await` говорит о попытке выполнить Task асинхронно. Какой то таск можно выполнить асинхронно, а какой то не получится. А всё потому, что Task - это по сути абстракция какой то работы, а раз это абстракция, то и у разных тасков будет разное поведение. Например, если таск уже завершен, то уже поздно пытаться выполнить его асинхронно.
Работа заключается в том `await`, чтобы приостановить текущий метод до тех пор, пока _не будет завершено то, что вы ему передадите_ .

Начало асинхронного метода выполняется так же, как и любой другой метод. То есть, он выполняется синхронно, пока не встретит «await» (или не выдаст исключение).

Ключевое слово «await» — это то, где всё может стать асинхронным. Await похож на унарный оператор: он принимает один аргумент, **awaitable** («awaitable» — это асинхронная операция). Await проверяет awaitable, чтобы узнать, завершился ли он; **если awaitable уже завершился, то метод просто продолжает выполняться (синхронно, как обычный метод**).

Если «await» видит, что awaitable не завершен, то он действует асинхронно. Он сообщает awaitable запустить оставшуюся часть метода, когда он завершится, а затем _возвращается_ из асинхронного метода.

Позже, когда awaitable завершится, он выполнит остаток асинхронного метода. Если вы ожидаете встроенный awaitable (например, задачу), то остаток асинхронного метода выполнится в «контексте», который был захвачен до того, как «await» был возвращен.

[Stephen Cleary](https://blog.stephencleary.com/2012/02/async-and-await.html)


Await - это как Звонящему будет сказано: «Это займет некоторое время, не стесняйтесь делать что-то еще», так что он может продолжить.

В C# `await`ключевое слово используется для приостановки выполнения асинхронного метода до тех пор, пока не завершится ожидаемая задача. Это немного похоже на то, как если бы вы сказали: «Подождите, мне нужно, чтобы эта операция завершилась, прежде чем я смогу продолжить». 

**Прелесть здесь в том, что пока метод приостановлен, вызывающий поток не блокируется. Вместо этого он освобождается для обработки других задач, и выполнение автоматически возобновится после завершения ожидаемой задачи.**


```csharp
async void SimpleAsync2() {await Task.FromResult(0);}
```

В примере выше мы пытаемся выполнить таск асинхронно, но там нечего выполнять, так как таск был создан уже выполненным. Потому код выше опять, просто синхронный код.

Хотя операция продолжается, она не блокирует исходный поток; поток, который запустил операцию, свободен для выполнения другой работы. Когда операция завершится, она уведомляет свое обещание или активизирует обратный вызов или 
событие, чтобы приложение узнало о завершении.



### Асинхронный вызов
Асинхронный вызов - вызов какого то кода, но не блокируя при этом свой поток.

```csharp
async void SimpleAsync3() {await Task.Run(()=>Thread.Sleep(1000));}
```

Асинхронный ли это вызов? Ну, по идее да, с точки зрения языка программирования. Но, является ли это асинхронным выполнением? Давайте глянем на [определение](https://ru.stackoverflow.com/a/416086/179763)

> Асинхронное исполнение
> Асинхронность (asynchrony) подразумевает, что операция может быть выполнена кем-то на стороне: удаленным веб-узлом, сервером или другим устройством за пределами текущего вычислительного устройства.
> Основное свойство таких операций в том, что начало такой операции требует значительно меньшего времени, чем основная работа. Что позволяет выполнять множество асинхронных операций одновременно даже на устройстве с небольшим числом вычислительных устройств.

В коде выше, будет ли операция выполнена на стороне? Нет, ведь в коде выше просто один поток будет асинхронно ожидать(не совсем верно т.к. вызывающий поток **освобождается** и может выполнять другие задачи), пока другой поток будет заблокирован. То есть пример выше просто какой-то многопоточный код с асинхронным ожиданием, то есть код вроде как использует асинхронные механизмы, но не является "асинхронным выполнением".


### Асинхронное выполнение

Код, который не только выглядит как асинхронный, но и работает как асинхронный.

```csharp
async void SimpleAsync4() {await File.ReadAllTextAsync("..."); }
```
Ну вот выше код читает текст из файла. То есть это I/O операция. Такую операцию должен выполнять жесткий диск, а не процессор. То есть, во время считывания данных, процессор не делает ничего, никакие потоки не блокированы, просто жесткий диск работает, а проц занимается своими делами, пока жесткий диск все не считает. То есть операция считывания выполняется на устройстве жесткого диска и CPU не блокирован. Вот это называется асинхронное выполнение.


https://darthpedro.net/2024/10/21/understanding-await-vs-continuewith-in-c-async-programming/

https://ru.stackoverflow.com/questions/1416834/%D0%A7%D1%82%D0%BE-%D1%82%D0%B0%D0%BA%D0%BE%D0%B5-%D0%B0%D1%81%D0%B8%D0%BD%D1%85%D1%80%D0%BE%D0%BD%D0%BD%D0%B0%D1%8F-%D1%84%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D1%8F-%D0%BC%D0%B5%D1%82%D0%BE%D0%B4-%D0%B2-c-%D0%B8-%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B8-%D0%B2-%D1%86%D0%B5%D0%BB%D0%BE%D0%BC