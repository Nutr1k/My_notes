---
dg-publish: true
---

На заре компьютерной эры операционные системы поддерживали всего один поток исполнения, обслуживающий как код операционной системы, так и код приложений.
Обычной была ситуация, когда распечатывающее документ приложение приостанавливало работу всей машины.
При разработке нового ядра операционной системы было решено запускать каждый экземпляр приложения в отдельном процессе (process).
Для решения этой проблемы и были придуманы потоки. Именно поток стал той концепцией, которая предназначена для виртуализации процессора

### Процесс(process)
> [!success] Процесс(process)
> Процесс — это исполняемый экземпляр приложения. Каждый процесс запускается с одним потоком, часто называемым _основным потоком_ , но может создавать дополнительные потоки из любого из своих потоков.

```ad-note
title:Подробнее про процессы
collapse:
Каждому процессу выделяется виртуальное адресное пространство:
- Это гарантирует, что код и данные одного процесса будут недоступны для другого. 
- Это делает приложения отказоустойчивыми, поскольку при таком подходе один процесс не может повредить код или данные другого. 
- Код и данные ядра также недоступны для процессов; а значит, код приложений не в состоянии повредить код или данные операционной системы. 
- Система становится также более безопасной, потому что код произвольного приложения не имеет доступа к именам пользователей, паролям, информации кредитной карты или иным конфиденциальным данным, с которыми работают другие приложения или сама операционная система.
```

### Поток(theard)

> [!success] Поток(theard)
> Поток — это сущность внутри процесса, которая может быть запланирована для выполнения. Все потоки процесса совместно используют его виртуальное адресное пространство и системные ресурсы

Каждое ядро ​​может запускать 1 поток одновременно или 2 потока параллельно, если включена технология Hyper-Threading. Таким образом, в системе с 4 установленными ядрами может быть 4 или 8 потоков, работающих параллельно, макс.

Однако, даже в этом случае, ваше приложение не единственное, которое запускает потоки. Каждый запущенный процесс имеет как минимум 1 поток, может быть больше. А сама ОС имеет десятки, может быть сотни запущенных потоков. Так что, очевидно, что потоков в целом намного больше, чем количество установленных ядер.

Итак, ОС имеет встроенный планировщик, который активно планирует все эти запущенные потоки таким образом, что ядра будут переключаться между потоками через регулярные интервалы, известные как «временные срезы». Этот процесс планирования обычно называют «переключением задач».

Это означает, что когда временной отрезок на ядре истекает, ядро ​​временно приостанавливает поток, который в данный момент выполняется на нем, сохраняет состояние этого потока, а затем возобновляет ранее приостановленный поток для следующего временного отрезка, затем приостанавливает и сохраняет этот поток, переключается на другой поток и так далее, десятки/сотни раз в секунду. Распределяется по количеству установленных ядер.

Большинство систем _не_ работают в режиме реального времени, поэтому настоящая параллельная обработка — это просто иллюзия. Просто много переключений между потоками по мере того, как становятся доступны основные временные срезы.

### Переключения контекста
> [!success] Переключения контекста
> Переключения контекста(context switching) - это процесс, при котором процессор переключается с выполнения одного потока (или процесса) на выполнение другого

В произвольный момент времени Windows передает процессору на исполнение один поток. Этот поток исполняется в течение некоторого временного интервала, иногда называемого тактом (quantum). 
После завершения этого интервала контекст Windows переключается на другой поток. При этом обязательно происходит следующее: 
1. Значения регистров процессора исполняющегося в данный момент потока сохраняются в структуре контекста, которая располагается в ядре потока. 
2. Из набора имеющихся потоков выделяется тот, которому будет передано управление. Если выбранный поток принадлежит другому процессу, Windows переключает для процессора виртуальное адресное пространство. Только после этого возможно выполнение какого-либо кода или доступ к каким-либо данным. 
3. Значения из выбранной структуры контекста потока загружаются в регистры процессора. 
После переключения контекста процессор исполняет выбранный поток, пока не истечет выделенное потоку время, после этого снова происходит переключение контекста. Windows делает это примерно каждые 30 мс




### Создание потока

Для создания поток нам необходимо создать экземпляр класса `System. Threading.Thread`

```csharp
	public sealed class Thread : CriticalFinalizerObject, ... 
	{
		public Thread(ParameterizedThreadStart start);
		// Здесь не показаны редко используемые конструкторы
	}
```

Параметр `start` задает метод, который будет выполняться в выделенном потоке. Сигнатура этого метода должна совпадать с сигнатурой делегата 
```csharp
delegate void ParameterizedThreadStart(Object obj);
```

Создание объекта `Thread` является достаточно простой операцией, так как при этом физический поток в операционной системе не появляется. 

Для создания физического потока, призванного исполнить метод обратного вызова, следует воспользоваться методом`Start`, передав в него объект (состояние), который вы хотите сделать аргументом метода обратного вызова

Блокирует вызывающий поток до завершения потока, представленного этим экземпляром.
```csharp
public void Join ();
```



```csharp
public static void Main()
{
	Console.WriteLine("Main thread: starting a dedicated thread " +
	"to do an asynchronous operation");
	Thread dedicatedThread = new Thread(ComputeBoundOp);
	dedicatedThread.Start(5);
	Console.WriteLine("Main thread: Doing other work here...");
	Thread.Sleep(10000);// Имитация другой работы (10 секунд)
	dedicatedThread.Join(); // Ожидание завершения потока
	Console.WriteLine("Hit <Enter> to end this program...");
	Console.ReadLine();
}
// Сигнатура метода должна совпадать
// с сигнатурой делегата ParameterizedThreadStart
private static void ComputeBoundOp(Object state)
{

	Console.WriteLine("In ComputeBoundOp: state={0}", state);
	Thread.Sleep(10000);// Имитация другой работы (1 секунда)
		// После возвращения методом управления выделенный поток завершается
					   // Метод, выполняемый выделенным потоком
}
```

Результат компиляции и запуска такого кода: 
1. Main thread: starting a dedicated thread to do an asynchronous operation 
2. Main thread: Doing other work here... 
3. In ComputeBoundOp: state=5 
Так как мы не можем контролировать очередность исполнения потоков в Windows, возможен и другой результат: 
1. Main thread: starting a dedicated thread to do an asynchronous operation 
3. In ComputeBoundOp: state=5 
2. Main thread: Doing other work here...

### Фоновые и активные потоки
В CLR все потоки делятся на активные (foreground) и фоновые (background). 
При завершении активных потоков в процессе CLR принудительно завершает также все запущенные на этот момент фоновые потоки.

Создание фонового потока
```csharp
public static void Main()
{
	// Создание нового потока (по умолчанию активного)
	Thread t = new Thread(Worker);
	// Превращение потока в фоновый
	t.IsBackground = true;
	t.Start(); // Старт потока
			   // В случае активного потока приложение будет работать около 10 секунд
			   // В случае фонового потока приложение немедленно прекратит работу
	Console.WriteLine("Returning from Main");
}
private static void Worker()
{
	Thread.Sleep(10000); // Имитация 10 секунд работы
						 // Следующая строка выводится только для кода,
						 // исполняемого активным потоком
	Console.WriteLine("Returning from Worker");
}
```
Основной поток приложения и все потоки, в явном виде созданные путем конструирования объекта Thread, по умолчанию являются **активными**. 
Потоки из пула по умолчанию являются фоновыми.