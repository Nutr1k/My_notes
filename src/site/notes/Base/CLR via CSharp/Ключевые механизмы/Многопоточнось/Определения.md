---
dg-publish: true
---

Задачи можно физически делить на куски, в кусках может быть сколько попало инструкций/операций - но не дробное число.

У задачи есть ее **личный поток выполнения** - последовательность этих самых кусков + какое-то состояние памяти = контекст. 

Когда процессор выполняет задачу - он размещает конкретный кусок задачи на **реальный поток выполнения** + восстанавливает контекст этой самой задачи.

На какой-то конкретный момент времени задача может быть не начата, начата (выполняться - когда размещена на **реальном потоке выполнения**, или же приостановлена - когда не размещена) и закончена.

Две задачи выполняются последовательно - если нет момента времени, когда они обе начаты
Две задачи выполняются одновременно - когда существует такой момент времени, когда они обе начаты
Две задачи выполняются параллельно в момент времени X - если существует как минимум два реальных потока выполнения, и в этот момент X обе задачи начаты и выполняются на этих двух разных потоках выполнения

Две задачи выполняются одновременно - когда существует такой момент времени, когда они обе начаты и неважно какая часть выполняется сейчас.


![Pasted image 20241215154304.png](/img/user/Files/Image/Pasted%20image%2020241215154304.png)




### Поток
« Поток выполнения — это **наименьшая последовательность запрограммированных инструкций, которая может управляться независимо планировщиком, который обычно является частью операционной системы**

 Потоки — это программная конструкция. Я могу запустить столько потоков pthreads, сколько захочу, даже на старом одноядерном процессоре. Так что **многопоточность не обязательно параллельна: она параллельна только в том случае, если ее поддерживает оборудование. Так что если у вас есть несколько ядер и/или гиперпоточность, ваша многопоточность становится параллельной**.
Если ваши потоки выполняются на физических ядрах одновременно, то они параллельны, в противном случае они просто работают с разделением времени или являются конкурентными.
```ad-note
title:Про потоки
collapse:
Есть "тут" и "там", есть события происходящие "там", и влияние этих событий на "тут"
"Тут" - это текущий поток (flow) выполнения, последовательность известных действий/операций - у который есть явный линейный порядок по времени.
"Там" - это что попало, кроме текущего потока выполнения - хоть другой поток выполнения на другом потоке-треде (thread), хоть какое-то физическое устройство, хоть удаленная машина, хоть этот же тред (когда на нем несколько потоков выполнения жонглирует диспетчер)
Если событие, происходящее "там", влияет на порядок выполнения "тут" - то оно синхронное. Если нет - асинхронное.
В самом простом случае, когда событие - результат выполнения операции "там", если "тут" после вызова операции "там" следующее действие не начинается, пока не появится результат - то это будет синхронный вызов/синхронное ожидание результата. Если рисовать порядок выполнения блоками, нанизанными на основную нитку - будет выглядеть так, что блок операции "там" будет на другой нитке, но в то же время на основной нитке будет дырка - как раз под размер блока операции "там".
Если после вызова операции "там" можно сразу переходить к следующей операции "тут", а результат операции обработать когда-нибудь потом - то это будет асинхронный вызов/асинхронное ожидание. На основной нитке дырки не будет.
Бывают сценарии сильно сложнее, но в шарпе надо очень сильно постараться, что б воспроизвести, такое в основном ближе к железу случается. Это когда операция "там" выполняется, "тут" тоже выполняется своя операция, но "тут" и "там" синхронизованы "по часам" - и "тут" операция может выполняться ограниченное время, пока не придет результат операции "там". А ля "вот у тебя свободное время, сделай что-нибудь полезное, но будь готов что через 37 тактов прилетит результат/прерывание" - вот такая ситуация - тоже синхронная. Потому что потоки выполнения может быть и разные, но завязаны но общие часики.
 
В шарпе асинхронность - на тасках. Таска - это информация для "тут" о том, что происходит "там". Заметьте, не факт, что там - это другой поток, это может быть и не поток вовсе - этой инфы таска не дает. Зато дает возможность узнать, закончилась ли она, какой результат, синхронно подождать/заблокироваться через Wait и зарегистрировать continuation через ContinueWith = асинхронно подождать.
Async/await - строго говоря, это не про асинхронный код - это про возможность писать асинхронный код максимально похоже по стилю "синхронного"

======================================================
На одном потоке можно иметь несколько потоков выполнения - ровно как и на одном ядре процессора можно иметь несколько потоков. Выполняться только может одна операция одновременно.
Единственное два отличия:  
1) операционная система сама умеет ставить потоки на паузу и переключать их, на диспетчере тебе явно надо отдать управление через Dispatcher.Yield()
2) API постарше тасок будет, и оперирует своей абстракцией DispatcherOperation - но это в принципе та же таска, и сейчас ее можно в таску обернуть через DispatcherOperation.Task
А так - то же самое, вызываешь операции через Dispatcher.InvokeAsync, отдаешь управление через Dispatcher.Yield - и вот у тебя куча разных операций выполняется асинхронно, диспетчер выбирает кто в каком порядке выполняется, в зависимости от указанного приоритета. Если не плодить гигантских непрерывных числодробилок  и часто делать Yield - то и не тормозит вовсе. И все на одном потоке.

================================

Если в таске, которая в потоке UI происходит к примеру await Task.Delay(100), то происходит переключение на поток выполнения, который отвечает за UI?

Текущая операция завершается, создается новая операция на продолжение деятельности(кода которые находиться после await) (то что после await), ставится timerCallback с задачей "через 100 мс отправь эту операцию на диспетчер", управление передается диспетчеру. Диспетчер разбирает очередь операций - находит там операции по перерисовке UI - вызывает их


```




### Синхронное выполнение

Это когда задачи выполняются последовательно — если нет момента времени, когда они обе начаты

### Конкуренция

**Конкуренция(Concurrency)** — это процесс, при котором одновременно выполняется более одной задачи, под одновременностью понимается 
существование такого момента времени, когда они обе начаты и неважно какая часть выполняется сейчас.
Одновременность в данном контексте не стоит понимать как выполнение в какой-то **такт**, т.к. на данном уровне абстракции в определённый так может исполняться только одна задача.
Одновременность это выполнение нескольких задач по частям с помощью переключения контекста.

Это не **выполнение множества задач одновременно**, а именно **работу с ними**, но выполнением в какой-то так только одной задачи т.к. иное на одноядерном однопоточном процессоре на данном уровне абстракции невозможно.

Нельзя смешивать одни и те же термины из разных уровней абстракции

Переключение контекста между задачами(потоками задач) происходит так быстро и так часто, что для наблюдателя-человека кажется, что ЦП выполняет задачи одновременно.

Конкурентное исполнение - это самый общий термин, который не говорит о том, каким образом эта конкурентность будет получен

```ad-note
title:Конкуренция(Concurrency)-дополнительно
collapse:
Представьте, что вам дали задание одновременно петь и есть. В каждый конкретный момент времени вы либо поёте, либо едите, так как в обоих случаях задействован ваш рот. Чтобы справиться с этим, вы едите некоторое время, затем поёте, и повторяете это, пока еда не закончится или песня не будет спета. Таким образом, вы выполняли свои задачи конкурентно.

![Pasted image 20241214200950.png](/img/user/Files/Image/Pasted%20image%2020241214200950.png)
Вы можете петь или есть по очереди, но не одновременно.


**Конкурентность** означает выполнение нескольких задач одновременно, но не обязательно параллельно. 
Под словом одновременно подразумевается переключением контекста/чередования задач.

В одноядерной среде (т. е. ваш процессор имеет одно ядро) конкурентность достигается с помощью процесса переключением контекста/чередования задач, что создаёт иллюзию одновременности.

По сути, это утверждение означает, что могут быть одновременно отправлены две задачи для совместного выполнения, но они не будут выполнены одновременно. Вместо этого они будут выполнены по частям с помощью переключения контекста.


В многоядерной среде(т.е. ваш процессор имеет несколько ядер), конкурентность может быть достигнут с помощью параллелизма.

![Pasted image 20241214202737.png](/img/user/Files/Image/Pasted%20image%2020241214202737.png)
```

Две задачи выполняются одновременно - когда существует такой момент времени, когда они обе начаты

[Ссылка](https://wyounas.github.io/concurrency/2024/12/12/how-concurrency-works-a-visual-guide/)

### Параллелизм

**Параллелизм(Parallelism)** — это процесс, при котором несколько задач выполняются фактически параллельно, то есть это **выполнение множества задач одновременно**, это возможность выполнение или выполнение в какой-то **такт** более чем одной задачи.

> [!info] 
> **Условие, которое возникает, когда одновременно выполняются по крайней мере два потока** 

Две задачи выполняются одновременно в течение одного и того же периода времени
![Pasted image 20241215153957.png](/img/user/Files/Image/Pasted%20image%2020241215153957.png)

Две задачи выполняются параллельно в момент времени X - если существует как минимум два реальных потока выполнения, и в этот момент X обе задачи начаты и выполняются на этих двух разных потоках выполнения

Две задачи выполняются одновременно - когда существует такой момент времени, когда они обе начаты и неважно какая часть выполняется сейчас

**Параллелизм — это когда задачи буквально выполняются одновременно, например, на многоядерном или многопоточном процессоре

```ad-note
title:Параллелизм(Parallelism)-дополнительно
collapse:

Параллелизм(Parallelism)

Представьте, что вам дали две задачи: готовить и разговаривать с другом по телефону. Вы можете делать эти две вещи одновременно. Вы можете готовить и разговаривать по телефону. Теперь вы выполняете свои задачи параллельно.

Представьте, что ваша одна часть мозга отвечает за общение по телефону, а другая за координацию руки для готовки.

Параллелизм означает выполнение двух или более задач одновременно. Параллельные вычисления в информатике относятся к процессу выполнения нескольких вычислений одновременно.

![Pasted image 20241214202940.png](/img/user/Files/Image/Pasted%20image%2020241214202940.png)

Параллелизм — это строгое подмножество конкурентного исполнения. =>Что конкурентность может быть достигнута параллелизмом

Асинхронное программирование — это форма конкуренции  при которой задачи начинаются и затем продолжаются, не дожидаясь завершения предыдущей задачи.

В асинхронной модели программирования при выполнении одной задачи можно переключиться на другую задачу, не дожидаясь завершения предыдущей.  Это всё действует при условии IO операций, если операции CPU-bound,то переключиться всё же можно, но от этого операция быстрее не выполниться
```

### Конкуренция и параллелизм

Что такое конкуренция
Состояние, когда выполняются как минимум два потока 

Что такое параллелизм?
Состояние, возникающее, когда **одновременно** выполняются как минимум два потока

В чем разница между параллелизмом и многопоточностью ? 
Конкуренция — это выполнение как минимум двух потоков , тогда как параллелизм — это выполнение как минимум двух потоков одновременно.

### Асинхронное исполнение

Асинхронность (asynchrony) подразумевает, что операция может быть выполнена кем-то на стороне: удаленным веб-узлом, сервером или другим устройством за пределами текущего вычислительного устройства. Операции привязаны к сети или вводу-выводу, а не к процессору.

Еще один важный момент, с точки зрения разработчика - разница между CPU-bound и IO-bound операциями. CPU-Bound операции нагружают вычислительные мощности текущего устройства, а IO-Bound позволяют **выполнить задачу вне текущей железки**.

Разница важна тем, что число одновременных операций зависит от того, к какой категории они относятся. Вполне нормально запустить параллельно сотни IO-Bound операций, и надеяться, что хватит ресурсов обработать все результаты. Запускать же параллельно слишком большое число CPU-bound операций (больше, чем число вычислительных устройств) бессмысленно.

Нет смысла выполнять в 1000 потоков метод, если он является CPU-Intensive (нагружает центральный процессор), поскольку это приведет к падению общей эффективности вычислений. ОС-ке придется переключать несколько доступных ядер для обслуживания сотен потоков. А этот процесс не является дешевым.

Первые два примера этого руководства показали, как можно использовать `async`и `await`для работы, связанной с вводом-выводом и ЦП. Важно, чтобы вы могли определить, когда работа, которую вам нужно выполнить, связана с вводом-выводом или ЦП, поскольку это может значительно повлиять на производительность вашего кода и потенциально привести к неправильному использованию определенных конструкций.

Вот два вопроса, которые вам следует задать, прежде чем писать какой-либо код:

1. Будет ли ваш код «ждать» чего-либо, например, данных из базы данных?
    Если ваш ответ «да», то ваша работа связана **с вводом-выводом** .
2. Будет ли ваш код выполнять дорогостоящие вычисления?

    Если вы ответили «да», то ваша работа связана **с ресурсами процессора** .

Если ваша работа связана **с вводом-выводом** , используйте `async`и `await` _без_ `Task.Run` . Вам _не следует_ использовать библиотеку Task Parallel Library.

Если работа у вас **связана с процессором** и вам важна скорость отклика, используйте `async`и `await`, но перенесите работу в другой поток _с помощью_ `Task.Run` . Если работа подходит для параллелизма и многопоточности, также рассмотрите возможность использования [Task Parallel Library](https://learn.microsoft.com/en-us/dotnet/standard/parallel-programming/task-parallel-library-tpl) .


```ad-note
title:Пояснение
collapse:
В общем случае используйте синхронные методы в следующих случаях:

- Операции простые или кратковременные.
- Простота важнее эффективности.
- Операции в основном являются операциями ЦП, а не операциями, которые подразумевают обширные дисковые или сетевые накладные расходы. Использование методов асинхронных действий в операциях, ограниченных ЦП, не дает никаких преимуществ и приводит к дополнительным накладным расходам.

В общем случае используйте асинхронные методы в следующих случаях:

- Вы вызываете службы, которые могут использоваться через асинхронные методы, и используете .NET 4.5 или выше.
- Операции привязаны к сети или вводу-выводу, а не к процессору.
- Параллелизм важнее простоты кода.
- Вы хотите предоставить механизм, позволяющий пользователям отменить длительный запрос.
- Когда выгода от переключения потоков перевешивает стоимость переключения контекста. В общем случае следует сделать метод асинхронным, если синхронный метод ожидает поток запроса ASP.NET, не выполняя никакой работы. Сделав вызов асинхронным, поток запроса ASP.NET не останавливается, не выполняя никакой работы, пока он ожидает завершения запроса веб-службы.
- Тестирование показывает, что блокирующие операции являются узким местом в производительности сайта и что IIS может обслуживать больше запросов, используя асинхронные методы для этих блокирующих вызовов.
```
https://stackoverflow.com/questions/27265818/does-the-use-of-async-await-create-a-new-thread
#### Почему для асинхронных операций не нужен новый поток?
Не для каждой операции нужен поток. В типичной системе есть много процессоров/контроллеров, включая контроллеры дисков, контроллеры сетевых карт, графические процессоры и т. д. Им просто нужно получить команду от процессора. Затем они приступают к выполнению команды и сообщают процессору о завершении (**уведомляют его, прерывая его или используя какой-либо другой механизм(обратный вызов,события)**). До тех пор поток не задействован. Вызывающий поток может либо перейти в спящий режим, либо перейти в пул потоков, где его можно использовать повторно. Когда команда завершена, выполнение программы может быть продолжено спящим потоком или потоком пула потоков.

`await DoAsync()`с `await Task.Run(Do)`. последний будет использовать пул потоков из-за Task.Run
### Многопоточность

**Многопоточность — это способность центрального процессора (ЦП) (или одного ядра в многоядерном процессоре) обеспечивать конкурентное выполнение нескольких потоков, поддерживаемых операционной системой**


Многопоточность - это один из способов реализации конкурентного исполнения путем выделения абстракции "рабочего потока" (worker thread).

«Системы с **одним процессором** обычно реализуют многопоточность путем квантования времени: центральный процессор (ЦП) переключается между различными программными потоками . Это переключение контекста обычно происходит достаточно часто, чтобы пользователи воспринимали потоки или задачи как работающие параллельно (для популярных серверных/настольных операционных систем максимальный квант времени потока, когда другие потоки ждут, часто ограничен 100-200 мс). 

В многопроцессорной, многоядерной или многопоточной системе несколько потоков могут выполняться параллельно, при этом каждый процессор или ядро ​​одновременно выполняет отдельный поток ; на процессоре или ядре с аппаратными потоками **отдельные программные потоки также могут выполняться конкурентно отдельными аппаратными потоками.**

**Можно использовать многопоточность( на одноядерной машине, но параллелизм возможен только на многоядерной машине**

 Операционная система, среда исполнения или библиотека прячет подробности того, будет многопоточное исполнение конкурентным (когда потоков больше чем физических процессоров), или параллельным (когда число потоков меньше или равно числу процессоров и несколько задач физически выполняются одновременно).

[GitHub](https://github.com/ysoh880710/ParallelComputing)
[Stackoverflow 1](https://stackoverflow.com/questions/1050222/what-is-the-difference-between-concurrency-and-parallelism)
[Stackoverflow 2](https://ru.stackoverflow.com/questions/445768/%D0%9C%D0%BD%D0%BE%D0%B3%D0%BE%D0%BF%D0%BE%D1%82%D0%BE%D1%87%D0%BD%D0%BE%D0%B5-vs-%D0%B0%D1%81%D0%B8%D0%BD%D1%85%D1%80%D0%BE%D0%BD%D0%BD%D0%BE%D0%B5-%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5)
[Stackoverflow 3](https://ru.stackoverflow.com/questions/445768/%d0%9c%d0%bd%d0%be%d0%b3%d0%be%d0%bf%d0%be%d1%82%d0%be%d1%87%d0%bd%d0%be%d0%b5-vs-%d0%b0%d1%81%d0%b8%d0%bd%d1%85%d1%80%d0%be%d0%bd%d0%bd%d0%be%d0%b5-%d0%bf%d1%80%d0%be%d0%b3%d1%80%d0%b0%d0%bc%d0%bc%d0%b8%d1%80%d0%be%d0%b2%d0%b0%d0%bd%d0%b8%d0%b5/416086#416086)

