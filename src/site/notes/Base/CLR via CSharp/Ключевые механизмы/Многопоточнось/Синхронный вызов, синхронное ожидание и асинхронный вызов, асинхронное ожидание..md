---
dg-publish: true
---

1. **Синхронный вызов**
Синхронный вызов — это выполнение операции, при которой текущий поток или программа ждёт её завершения перед продолжением работы. То есть вызывающий код останавливается до завершения операции.

```csharp
void SynchronousCall() 
{ 
	Thread.Sleep(1000); // Текущий поток "замораживается" на 1 секунду 
	Console.WriteLine("Операция завершена."); 
}
```
Поток блокируется до завершения операции.

2. **Асинхронный вызов**
Асинхронный вызов — это выполнение операции, которая позволяет текущему потоку продолжить выполнение работы, пока операция выполняется в фоновом режиме (или в другом потоке).

```csharp
async Task AsynchronousCall()
{
    await Task.Delay(1000); // Текущий поток освобождается, пока "ждёт" 1 секунду
    Console.WriteLine("Операция завершена.");
}
```
Текущий поток не блокируется.

3. **Синхронное ожидание**
Синхронное ожидание — это форма ожидания результата, при которой текущий поток **блокируется**, пока операция не завершится.

```csharp
void SynchronousWait()
{
    Task task = Task.Delay(1000); // Запуск асинхронной задачи
    task.Wait(); // Блокирует текущий поток до завершения задачи
    Console.WriteLine("Операция завершена.");
}
```
Смешивание синхронного кода и асинхронных задач часто приводит к проблемам, например, к блокировкам или "взаимным зависимостям" потоков.

4. **Асинхронное ожидание**
Асинхронное ожидание — это форма ожидания, при которой текущий поток **освобождается**, пока задача не завершится. Это достигается с помощью `await` в C#.
```csharp
async Task AsyncWaitExample()
{
    Console.WriteLine("Перед ожиданием...");
    // Асинхронное ожидание с Task.Delay
    await Task.Delay(3000); // "Ожидание" 3 секунды без блокировки потока
    Console.WriteLine("После ожидания.");
}

```
Освобождает текущий поток, позволяя ему выполнять другие задачи.
- `await Task.Delay(3000)` означает: "Приостанови выполнение метода на 3 секунды, но не блокируй поток".
- Поток освобождается для выполнения других задач, а метод продолжится, когда таймер завершит работу.