---
{"dg-publish":true,"permalink":"/base/clr-via-c-sharp/klyuchevye-mehanizmy/mnogopotochnos/zamykaniya-closure/"}
---

### Замыкания
В C# **замыкание** — это механизм, который позволяет функции "захватывать" переменные из внешней области видимости, даже если эта область вышла из контекста выполнения. Замыкания часто используются в [[Base/CLR via CSharp/Проектирование типов/Анонимные методы\|анонимных методах]]  и [[Base/CLR via CSharp/Проектирование типов/Лямбда-выражения\|лямбда-выражениях]] или [[Base/CLR via CSharp/Основные типы данных/Делегаты\| делегатах]], позволяя им ссылаться на переменные, объявленные вне их тела.


Когда мы объявляем локальную переменную в методе, а затем используете её в анонимной функции, лямбда-выражении, делегате компилятор создаёт специальный класс-контейнер, который содержит эту переменную, чтобы анонимная функция могла продолжать работать с ней, даже если метод уже завершил выполнение.

> Замыкание захватывает переменную, а не его значение. Точнее создаётся класс-контейнер в котором будет определено поле соответствующее данной переменной и все обращения будут идти к этому полю класса.


Вот какой кот будет сгенерирован компилятором для анонимного метода:
![Pasted image 20250115164853.png](/img/user/Files/Image/Pasted%20image%2020250115164853.png)

> Очень важным фактом является, то что где до этого мы использовали локальную переменную (`num_1,num_2`), теперь используется поле класса-контейнера. То есть все обращения к локальным переменным заменяются на обращения к полю класса.
> ![Pasted image 20250115165147.png](/img/user/Files/Image/Pasted%20image%2020250115165147.png)

```ad-note
title:Замыкания в делегатах
collapse:
![Pasted image 20250115170558.png](/img/user/Files/Image/Pasted%20image%2020250115170558.png)
```csharp
using System;
public class Program 
{
    delegate void Show();
    public static void Main() 
    {
        int count = 0; // Переменная, которая будет захвачена замыканием

        Show ShowToConsole = new Show(ShowMethod);

        // Вложенный метод — замыкание
        void ShowMethod()
        {
            count++; // Увеличиваем захваченную переменную
            Console.WriteLine(count);
        }
        ShowToConsole();
        count+=123;
        Console.WriteLine(count);
    }   
}
```


```ad-note
title:Замыкания в лямбда-выражениях
collapse:
![Pasted image 20250115170947.png](/img/user/Files/Image/Pasted%20image%2020250115170947.png)
```csharp
using System;
public class Program
{
    public static void Main() 
    {
          var actions = new List<Action>();
          for (int i = 0; i < 10; i++)
          {
            actions.Add(() => Console.WriteLine(i));
          }

          foreach(var a in actions)
          {
            a();
          }
    }
}
```


#### Необычное поведения 
Если рассмотреть данный код, то складывается впечатление, что он просто выведет числа от 1 до 10.
```csharp
void Foo()
{
  var actions = new List<Action>();
  for (int i = 0; i < 10; i++)
  {
    actions.Add(() => Console.WriteLine(i));
  }

  foreach(var a in actions)
  {
    a();
  }
}
```
 
 Но вывод будет таким:
```
10
10
10
10
10
10
10
10
10
10
```

![Pasted image 20250115174242.png](/img/user/Files/Image/Pasted%20image%2020250115174242.png)

Как мы уже знаем для поддержки замыкания создаётся класс контейнер, который содержит нашу переменную `i`. 

> Класс-контейнер будет создан там, где вы объявили свою переменную, которую в дальнейшем будете захватывать.


Копироваться значение переменной i должно (по логике вещей) во время создания экземпляра класса-контейнера. По данному коду кажется, что класс-контейнер будет создан в теле цикла, но C# транслирует цикл `for` в цикл `while`:
![Pasted image 20250115172024.png](/img/user/Files/Image/Pasted%20image%2020250115172024.png)


В итоге мы получаем один экземпляр класса-контейнера на все итерации цикла for. А добавляя при каждой итерации в список actions новую лямбду, мы, по факту, добавляем в него одну и ту же ссылку на ранее созданный экземпляр класса-контейнера и соответственно i будет ссылаться на последнее значение.

В результате чего, когда мы обходим циклом foreach все элементы списка actions, то все они содержат один и тот же экземпляр класса-контейнера.


Можно избежать данной особенности следуя приведённому выше правилу.
Необходимо следить за тем, где и какие переменные вы захватываете. Помните, класс-контейнер будет создан там, где вы объявили свою переменную, которую в дальнейшем будете захватывать. Следовательно, объявим промежуточную переменную в теле цикла.

```csharp
void Foo()
{
  var actions = new List<Action>();
  for (int i = 0; i < 10; i++)
  {
    int j=i;
    actions.Add(() => Console.WriteLine(j));
  }

  foreach(var a in actions)
  {
    a();
  }
}
```

Вывод:
```
0
1
2
3
4
5
6
7
8
9
```
![Pasted image 20250115174321.png](/img/user/Files/Image/Pasted%20image%2020250115174321.png)

Посмотрев на код цикла for из данного примера, мы увидим, что экземпляр класса-контейнера будет создаваться каждую итерацию цикла. Таким образом, список actions будет содержать ссылки на разные экземпляры с корректными значениями итераторов.
