---
{"dg-publish":true,"permalink":"/base/clr-via-c-sharp/klyuchevye-mehanizmy/isklyucheniya-i-upravlenie-sostoyaniem/"}
---


Блок `try`:
В блоке try должен располагаться код, который может приводить к генерации исключения.
В блоке try размещается код, требующий очистки ресурсов и/или восстановления после исключения.

Блок `catch`:
В блок catch помещают код, который должен выполняться в ответ на исключение.
Выражение в скобках после ключевого слова `catch` называется `типом исключения (catch type)`. В C# эту роль играет тип `System.Exception` и его производные.

Поиск подходящего блока `catch` в CLR осуществляется сверху вниз, поэтому наиболее конкретные обработчики должны находиться в `начале списка`. 

Сначала стоит указывать потомков с наибольшей глубиной наследования, потом — их базовые классы (если таковые имеются) и, наконец, — класс System.Exception (или блок с неуказанным типом исключений). В противном случае компилятор сообщит об ошибке, так как более узкоспециализированные блоки в такой ситуации окажутся для него недостижимыми.

Блок `finally`:
Выполняется после того, как будут выполнены все блоки 'catch'
Обычно этот код производит очистку после выполнения блока try

Запомните, что в блок finally помещается код для **выполнения завершающей очитски**. И он должен выполнять только те действия, которые необходимы для отмены операций, начатых в блоке try.

Пример:
Если в блоке try был открыт некий файл, блок finally должен содержать закрывающий этот файл код:

```csharp
private void ReadData(String pathname)
{
	FileStream fs = null;
	try
	{
		fs = new FileStream(pathname, FileMode.Open);
		// Обработка данных в файле
	}
	catch (IOException)
	{
		// Код восстановления после исключения IOException
	}
	finally
	{
		// Файл обязательно следует закрыть
		if (fs != null) fs.Close();
	}
}
```





#### Активно используйте блоки finally

CLR **запрещает** аварийно завершать потоки во время выполнения кода блоков catch и finally. Поэтому сделать метод Transfer более устойчивым можно следующим способом:

Блоки finally позволяют определять код, который будет гарантированно исполнен независимо от вида сгенерированного потоком исключения:

```csharp

public static void Transfer(Account from, Account to, Decimal amount)
{
	try { /* здесь ничего не делается */ }
	finally
	{
		from -= amount;
		// Прерывание потока (из-за Thread.Abort/AppDomain.Unload)
		// здесь невозможно
		to += amount;
	}
}
```
В блоках finally стоит изменять самые чувствительные состояния.

#### Класс System.Exception
StackTrace - Имена и сигнатуры методов, вызов которых стал источником исключения. Чрезвычайно полезное для отладки свойство

Блок catch может прочитать его для получения информации о том, какой именно метод стал источником исключения. Эта информация может быть весьма ценной для поиска объекта, ставшего источником исключения, и последующего исправления кода. 

При обращении к этому свойству вы фактически обращаетесь к коду в CLR, поскольку свойство не просто возвращает строку. При создании объекта типа, производного от Exception, свойству StackTrace присваивается значение null. И соответственно, при попытке прочитать свойство вы получили бы не результат трассировки стека, а null. 

При появлении исключения CLR делает запись с указанием места его возникновения. Когда блок catch получает исключение, CLR записывает, где именно оно было обнаружено. 

Если внутри блока catch обратиться к свойству StackTrace объекта, сгенерированного при появлении исключения, реализующий это свойство код обратится к CLR, где и будет создана строка, содержащая имена всех методов от точки, в которой было вброшено исключение, до точки, где оно было перехвачено.

> [!info]  Важно
> При появлении исключения CLR обнуляет его начальную точку. То есть CLR запоминает только место появления самого последнего исключения. 

Следующий код генерирует то же исключение, которое было перехвачено, и заставляет CLR **обнулить начальную точку**:
```csharp
private void SomeMethod()
{
	try { ... }
	catch (Exception e)
	{
		...
 throw e; // CLR считает, что исключение возникло тут
		  // FxCop сообщает об ошибке
	}
}
```
В противоположность этому, при повторном вызове перехваченного исключения
с помощью ключевого слова throw удаления из стека информации о **начальной
точке не происходит**. 

Пример:
```csharp
private void SomeMethod()
{
	try { ... }
	catch (Exception e)
	{
		...
 throw; // CLR не меняет информацию о начальной точке исключения.
		// FxCop НЕ сообщает об ошибке
	}
}
```

Эти два фрагмента кода отличаются только тем, где, по мнению CLR, было сгенерировано исключение. К сожалению, при первом или повторном вызове исключения Windows обнуляет стек с информацией о начальной точке. И в случае необработанного исключения в систему сбора информации об ошибках Windows уходят сведения о последнем вброшенном исключении, даже если CLR «знает», где именно было сгенерировано самое первое исключение. Это серьезно усложняет отладку приложений. 

Некоторым разработчикам подобная ситуация кажется недопустимой, поэтому они выбирают другой способ реализации кода, гарантирующий истинность информации о первоначальной точке возникновения исключения:

```csharp
private void SomeMethod()
{
	Boolean trySucceeds = false;
	try
	{
		 ...
		 trySucceeds = true;
	}
	finally
	{
		 if (!trySucceeds) { /* код перехвата исключения */ }
	}
}
```

#### Using и finally
Код генерируемый при использовании конструкции using аналогичен использованию try finally.
![Pasted image 20241116172049.png](/img/user/Files/Image/Pasted%20image%2020241116172049.png)