---
dg-publish: true
---

Приложение может контролировать уборку мусора при помощи свойства `GCLatencyMode` класса `GCSettings`. Этому свойству могут присваиваться любые значения из перечисления `GCLatencyMode`.

| Значение                                                           | Описание                                                                                                                                                                                                                                                                                                                                                                                                                 |
| ------------------------------------------------------------------ | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| Batch (по умолчанию используется для серверного режима)            | Отключает параллельную уборку мусора                                                                                                                                                                                                                                                                                                                                                                                     |
| Interactive (по умолчанию используется для режима рабочей станции) | Включает параллельную уборку мусора                                                                                                                                                                                                                                                                                                                                                                                      |
| **LowLatency**                                                         | В режиме рабочей станции этот скрытый режим используется для кратковременных, критичных по времени операций (например, анимации), для которых уборка мусора в поколении 2 из-за снижения производительности может оказаться неприемлемой                                                                                                                                                                                 |
| SustainedLowLatency                                                | Используется для предотвращения долгих пауз уборки мусора во время выполнения приложения. Блокирующая уборка мусора поколения 2 запрещается при наличии свободной памяти. Пользователи таких приложений скорее предпочтут установить на компьютере дополнительную память, чтобы избежать пауз. Пример приложения такого рода — приложение для торговли на бирже, которое должно немедленно реагировать на изменение цены |



Подробнее про режим `LowLatency`:
- Этот режим включают для реализации операций, для которых важно время выполнения, а затем возвращают режим Batch или Interactive. 

- В режиме `LowLatency` уборщик мусора обходит вниманием поколение 2, так как это может занять много времени. Разумеется, если вы вызовете метод `GC.Collect()`, поколение 2 также отправится в мусор. То же самое произойдет, если Windows «пожалуется» CLR на недостаток системной памяти. 

- В режиме `LowLatency` приложение может выдавать исключение `OutOfMemoryException`. Соответственно, **можно порекомендовать включать этот режим на максимально короткое время**, избегать размещения в памяти многих объектов, а также больших объектов и **возвращаться к режимам Batch и Interactive**. Также помните, что режим LowLatency является настройкой уровня процесса и потоки могут быть запущены параллельно. Эти потоки могут даже менять данную настройку в процессе ее использования другим потоком.

```csharp
private static void LowLatencyDemo()
{
	GCLatencyMode oldMode = GCSettings.LatencyMode;
//try выполнялся только при условии выполнения кода в связанных с ним блоках catch и finally.
   System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions();
	try
	{
		GCSettings.LatencyMode = GCLatencyMode.LowLatency;
		// Здесь выполняется код чувствительный к сборке мусора
	}
	finally
	{
		GCSettings.LatencyMode = oldMode;
	}
}
```
Метод `PrepareConstrainedRegions` играет особую роль. Обнаружив его перед блоком try, JIT-компилятор немедленно начинает компилировать соответствующие блоки catch и finally. JIT-компилятор загружает любые сборки, создает любые типы, вызывает любые статические конструкторы и компилирует любые методы. Если хотя бы одна из этих операций дает сбой, исключение возникает до входа потока в блок try.

##### Программное управление уборщиком мусора

Чтобы заставить уборщика мусора провести уборку, следует вызвать метод `Collect` класса `GC`. 
```csharp
GC.Collect();
```
При вызове можно указать поколение, в котором нужно выполнить уборку мусора, параметр `GCCollectionMode` и логический признак выполнения блокирующей (непараллельной) или фоновой (параллельной) уборки мусора. 

Сигнатура самой сложной перегруженной версии Collect выглядит так:
`void Collect(Int32 generation, GCCollectionMode mode, Boolean blocking)`

```csharp
GC.Collect(1,GCCollectionMode.Optimized,true);
```

Значения параметра `GCCollectionMode`:

| Значение  | Описание |
| --------- | -------- |
| Default   | Аналогично вызову метода GC.Collect без флагов. В настоящее время эквивалентно передаче параметра Forced, но в следующих версиях CLR ситуация может измениться         |
| Forced    | Инициирует уборку мусора для всех поколений вплоть до указанного вами, включая и само это поколение         |
| Optimized | Уборка мусора осуществляется только при условии качественного конечного результата, выражающегося либо в освобождении большого объема памяти, либо в уменьшении фрагментации. В противном случае вызов метода в этом режиме не дает никакого эффекта         |


Обычно следует избегать вызова любых методов Collect: лучше не вмешиваться в работу уборщика мусора и позволить ему самостоятельно настраивать пороговые значения для поколений, основываясь на реальном поведении приложения. 

Однако при написании приложения с **консольным или графическим интерфейсом** его код «владеет» процессом и CLR в этом процессе. В подобных приложениях порой следует собирать мусор принудительно во вполне **определенное время**. Это можно сделать при помощи метода `GCCollectionMode` в режиме `Optimized`. 

Режимы Default и Forced обычно используют для отладки и тестирования. Например, имеет смысл вызывать метод Collect, если только что произошло некое разовое событие, которое привело к уничтожению множества старых объектов. Вызов Collect в такой ситуации очень кстати, ведь основанные на прошлом опыте прогнозы уборщика мусора, скорее всего, для разовых событий окажутся неточными. Например, в приложении имеет смысл выполнить принудительную уборку мусора во всех поколениях после инициализации приложения или сохранения пользователем файла с данными. 



