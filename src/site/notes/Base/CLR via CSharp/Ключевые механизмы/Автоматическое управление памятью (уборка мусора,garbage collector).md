---
dg-publish: true
---
Любая программа использует ресурсы — файлы, буферы в памяти, пространство экрана, сетевые подключения, базы данных и т. п. В объектно-ориентированной среде каждый тип идентифицирует некий доступный этой программе ресурс. Чтобы им воспользоваться, должна быть выделена память для представления этого типа. 

Для доступа к ресурсу вам нужно: 
1. Выделить память для типа, представляющего ресурс (обычно это делается при помощи оператора new в C#). 
2. Инициализировать выделенную память, установив начальное состояние ресурса и сделав его пригодным к использованию. За установку начального состояния типа отвечает его конструктор. 
3. Использовать ресурс, обращаясь к членам его типа (при необходимости операция может повторяться). 
4. В рамках процедуры очистки уничтожить состояние ресурса. 
5. Освободить память. За этот этап отвечает исключительно уборщик мусора.

Очистка ресурсов не дожидаясь сборщика мусора выполняется с помощью метода - Dispose 

В CLR память для всех ресурсов выделяется из так называемой управляемой кучи (managed heap). При инициализации процесса CLR резервирует область адресного пространства под управляемую кучу, а также указатель, который я называю **NextObjPtr**. Он определяет, где в куче будет выделена память для следующего объекта, и изначально указывает на базовый адрес этой зарезервированной области адресного пространства. По мере заполнения области объектами CLR выделяет новые области, вплоть до заполнения всего адресного пространства. Таким образом, память приложения ограничивается виртуальным адресным пространством процесса. Для 32-разрядных процессов можно выделить до 1,5 гигабайта памяти, а для 64-разрядных процессов — около 8 терабайт памяти.


На рисунке изображена управляемая куча с тремя объектами: А, В и С. Новый объект размещается по адресу, заданному указателем NextObjPtr (сразу после объекта С).
![Pasted image 20241116185400.png](/img/user/Files/Image/Pasted%20image%2020241116185400.png)

В среде, поддерживающей уборку мусора, новые объекты располагаются в памяти непрерывно, что повышает производительность за счет близкого расположения ссылок.

На рисунке показана управляемая куча с несколькими объектами до уборки мусора, в которой корни приложения напрямую ссылаются на объекты А, С, D и F. Все эти объекты маркируются. При маркировке объекта D уборщик мусора обнаруживает, что в этом объекте есть поле, ссылающееся на объект H, поэтому объект H также помечается. Затем уборщик продолжает рекурсивный просмотр всех достижимых объектов.
![Pasted image 20241116193328.png](/img/user/Files/Image/Pasted%20image%2020241116193328.png)

На рисунке показана управляемая куча после сжатия. После завершения фазы сжатия CLR возобновляет выполнение потоков приложения, а они обращаются к объектам так, словно никакой уборки мусора и не было.
![Pasted image 20241116193427.png](/img/user/Files/Image/Pasted%20image%2020241116193427.png)

#### Алгоритм уборки мусора
Когда приложение вызывает оператор new для создания объекта, оставшегося адресного пространства может не хватить для выделения памяти под объект. 
В таком случае CLR **выполняет уборку мусора**.

Для управления сроком жизни объектов CLR использует алгоритм отслеживания ссылок. Алгоритм отслеживания ссылок работает только с переменными ссылочного типа, потому что только эти переменные могут ссылаться на объекты в куче; переменные значимых типов просто содержат данные экземпляра значимого типа.
Все переменные ссылочных типов называются **корнями (roots).**

Алгоритм работы сборки мусора:

```ad-note
title:Фаза №1. Маркировка (marking)
collapse:
 1. CLR приостанавливает все программные потоки в процессе. Тем самым предотвращается обращение к объектам и возможное изменение состояния во время их анализа CLR.
 2. CLR перебирает все объекты в куче, задавая биту в поле индекса блока синхронизации значение 0, если в приложении не существует корня (ссылки), через который приложение могло бы к ним обратиться.
3. Если корень ссылается на объект, в поле индекса блока синхронизации этого объекта устанавливается бит (1) это и есть признак маркировки объекта. 
4. После маркировки объекта CLR проверяет все корни в этом объекте и маркирует объекты, на которые они ссылаются. Встретив уже маркированный объект, уборщик мусора останавливается, чтобы избежать возникновения бесконечного цикла в случае циклических ссылок.

Маркированные объекты переживут уборку мусора, потому что на них ссылается хотя бы один объект; можно сказать, что они достижимы из кода приложения. Немаркированные объекты недостижимы, потому что в приложении не существует корня, через который приложение могло бы к ним обратиться
```

```ad-note
title:Фаза №2. Cжатие (compacting phase)
collapse:
1.CLR групирует вместе(перемещает вниз) все «немусорные» объекты, чтобы они занимали смежный блок памяти. Это служит сокращению размера рабочего набора приложения, а следовательно, повышает производительность обращения к этим объектам в будущем
2. Т.к. после перемещения в памяти все ссылки на «выжившие» объекты из корней указывают на прежнее местонахождение объекта в памяти, а не на тот адрес, по которому объект был перемещен, то CLR вычитает из каждого корня количество байт, на которое объект был перемещён *сдвинут вниз в памяти). Тем самым гарантируется, что каждый корень будет ссылаться на тот же объект, что и прежде; просто сейчас этот объект оказался в другом месте памяти.
3.После сжатия памяти кучи в указатель NextObjPtr управляемой кучи заносится первый адрес за последним объектом, не являющимся мусором
```



#### Уборщик мусора с поддержкой поколений (generational garbage collector)

Уборщик мусора с поддержкой поколений (generational garbage collector), который также называют эфемерным уборщиком мусора (ephemeral garbage collector), работает на основе следующих предположений: 
- чем младше объект, тем короче его время жизни; 
- чем старше объект, тем длиннее его время жизни; 
- уборка мусора в части кучи выполняется быстрее, чем во всей куче.

![Pasted image 20241117170201.png](/img/user/Files/Image/Pasted%20image%2020241117170201.png)

```ad-note
title:Инициализация CLR
collapse:
При инициализации CLR выбирает пороговый размер для поколения 0,1,2.
Уборщик мусора CLR является самонастраивающимся, то есть в процессе работы он анализирует функциональность приложения и адаптирует порог для поколений.

При уборке мусора в поколениях уборщик определяет, сколько памяти было освобождено и сколько объектов осталось. В зависимости от полученных данных он может увеличить или уменьшить пороги для этих поколений, чтобы повысить производительность работы приложения.

Если памяти было освобождено много, уборщик может снизить порог для поколения и уборка будет выполняться чаще.
Если памяти было освобождено мало, уборщик может поднять порог для поколения и уборка будет выполняться реже,нокаждый раз будет освобождаться значительный объем памяти.
Управляемая куча поддерживает только три поколения: 0, 1 и 2.
```ad-note
title:Более подробно
collapse:
Если уборщик видит, что после уборки мусора в поколении остается очень мало выживших объектов, он может снизить порог для поколения. В этом случае уборка мусора будет выполняться чаще, но это меньше загрузит уборщик, поэтому рабочий набор процесса останется небольшим

В то же время, если после обработки поколения уборщик мусора обнаруживает множество выживших объектов, значит, удается освободить мало памяти. В этом случае уборщик мусора может поднять порог для поколения 0. В результате уборка мусора выполняется реже, но каждый раз будет освобождаться значительный объем памяти
```

```ad-done
title:Добавление новых объектов
collapse:
Только что созданные объекты которых не касался уборщик мусора относяться к поколению 0.
![Pasted image 20241117150716.png](/img/user/Files/Image/Pasted%20image%2020241117150716.png)
```

```ad-tip
title:Запуск сборки мусора
collapse:
Если в результате выделения памяти для нового добавленного объекта размер поколения 0 превышает пороговое значение, должна начаться уборка мусора.

Объекты А–Е относятся к поколению 0. Тогда при размещении объекта F должна начаться уборка мусора. Уборщик мусора определяет, что объекты С и E — это мусор, и выполняет сжатие памяти для объекта D, перемещая его вплотную к объекту B.
```

```ad-danger
title:Перевод объектов в более старшее поколение
collapse:
Объекты, пережившие уборку мусора (А, В и D), становятся поколением 1. Объекты из поколения 1 были проверены уборщиком мусора один раз.
![Pasted image 20241117152316.png](/img/user/Files/Image/Pasted%20image%2020241117152316.png)
```

```ad-done
title:Добавление новых объектов
collapse:
После уборки мусора объектов в поколении 0 не остается. Туда помещаются новые объекты. Приложение продолжает работу и размещает новые объекты F–K. Также в ходе работы приложения становятся недоступными объекты B, H и J, поэтому занятая ими память должна рано или поздно освободиться.
![Pasted image 20241117153359.png](/img/user/Files/Image/Pasted%20image%2020241117153359.png)
```

```ad-tip
title:Запуск сборки мусора
collapse:
При попытке размещения объекта L размер поколения 0 превысил пороговое значение, поэтому должна начаться уборка мусора. При этом уборщик мусора решает, какие поколения следует обработать. Я уже упоминал, что при инициализации CLR выбирает пороговый размер поколения 0; CLR также выбирает пороговый размер для поколения 1.


Начиная уборку мусора, уборщик определяет, сколько памяти занято поколением 1. Пока поколение 1 занимает намного меньше отведенной памяти, поэтому уборщик проверяет только объекты поколения 0. Поскольку уборщик игнорирует объекты поколения 1, уборка мусора значительно ускоряется.  

Производительность растет еще больше благодаря выборочной проверки объектов в управляемой куче. 


Если переменная или объект ссылается на объект из старшего поколения, то CLR должна проверять все корни в этом объекте и маркировать объекты, на которые они ссылаются, но в целях оптимизации уборщик игнорирует все внутренние ссылки старшего объекта, сокращая время построения графа доступных объектов, т.к. нету смысла проверять объект из старшего поколения сейчас т.к. он будут проверяться, когда размер этого(старшего) поколения превысит пороговое значение.(объекты в старшем поколении, как правило, стабильны, и их внутренняя структура мало изменяется).



Возможна ситуация, когда старый объект ссылается на новый. Чтобы не пропустить обновленные поля этих старых объектов, уборщик использует внутренний механизм JIT-компилятора, устанавливающий флаг при изменении ссылочного поля объекта. Он позволяет уборщику выяснить, какие из старых объектов (если они есть) были изменены с момента последней уборки мусора. Остается проверять только старые объекты с измененными полями, чтобы выяснить, не ссылаются ли они на новые объекты из поколения 0.



Уборщик мусора с поддержкой поколений также предполагает, что объекты, прожившие достаточно долго, продолжат жить и дальше. Так что велика вероятность, что объекты поколения 1 и впредь останутся доступными в приложении. То есть проверив объекты поколения 1, уборщик нашел бы мало мусора и не смог бы освободить много памяти. Следовательно, уборка мусора в поколении 1, скорее всего, окажется пустой тратой времени. Если в поколении 1 появляется мусор, он просто остается там

```

```ad-danger
title:Перевод объектов в более старшее поколение
collapse:
Как видите, объекты F,G,I,K из поколения 0, пережившие уборку мусора, перешли в поколение 1. Так как уборщик не проверяет поколение 1, память, занятая объектом В, не освобождается, даже если этот объект на момент уборки мусора недоступен. И в этот раз после уборки мусора поколение 0 пустеет, в это поколение попадут новые объекты
![Pasted image 20241117160855.png](/img/user/Files/Image/Pasted%20image%2020241117160855.png)
```

```ad-done
title:Добавление новых объектов
collapse:
Приложение работает дальше и выделяет память под новые объекты L–O. Во время работы приложение прекращает использовать объекты G, L и M, и они становятся недоступными. В результате куча выглядит так, как показано на рисунке
![Pasted image 20241117163115.png](/img/user/Files/Image/Pasted%20image%2020241117163115.png)

Допустим, в результате размещения объекта P размер поколения 0 превысил пороговое значение, что инициировало уборку мусора.
```

```ad-tip
title:Запуск сборки мусора
collapse:
Поскольку все объекты поколения 1 занимают в совокупности меньше порогового уровня, уборщик вновь решает собрать мусор только в поколении 0, игнорируя недоступные объекты в поколении 1 (B и G). 

Уборщик мусора определяет, что объекты L и M — это мусор  и выполняет сжатие памяти для объектов N,O, перемещая объекты N,O вплотную к объекту K.
```

```ad-danger
title:Перевод объектов в более старшее поколение
collapse:
Куча после уборки мусора показана на рисунке
![Pasted image 20241117163303.png](/img/user/Files/Image/Pasted%20image%2020241117163303.png)
Как видите, объекты N,O из поколения 0 пережившие уборку мусора, перешли в поколение 1.
```

```ad-done
title:Добавление новых объектов
collapse:
На рисунке видно, что поколение 1 постепенно растет. Допустим, поколение 1 выросло до таких размеров, что все его объекты в совокупности превысили пороговое значение. В этот момент приложение продолжает работать (потому что уборка мусора только что завершилась) и начинает размещение в памяти объектов P–S, которые заполняют поколение 0 до его порогового значения

![Pasted image 20241117164517.png](/img/user/Files/Image/Pasted%20image%2020241117164517.png)

При попытке приложения разместить объект Т поколение 0 заполняется и начинается уборка мусора.
```

```ad-tip
title:Запуск сборки мусора
collapse:
На этот раз уборщик мусора обнаруживает, что место, занятое объектами, превысило пороговое значение. После нескольких операций уборки мусора в поколении 0 велика вероятность, что несколько объектов в поколении 1 стали недоступными (как в нашем примере). Поэтому теперь уборщик мусора проверяет все объекты поколений 1 и 0. 
```

```ad-danger
title:Перевод объектов в более старшее поколение
collapse:
После уборки мусора в обоих поколениях куча выглядит так, как показано на рисунке.

![Pasted image 20241117164806.png](/img/user/Files/Image/Pasted%20image%2020241117164806.png)

Как видите, объекты Q,S из поколения 0 пережившие уборку мусора, перешли в поколение 1.
Объекты D,F,I,N,O из поколения 1 пережившие уборку мусора, перешли в поколение 2.

Все выжившие объекты поколения 0 теперь находятся в поколении 1, а все выжившие объекты поколения 1 — в поколении 2. Как всегда, сразу после уборки мусора поколение 0 пустеет: в нем будут размещаться новые объекты. В поколении 2 находятся объекты, проверенные уборщиком мусора не меньше двух раз. Операций уборки мусора может быть много, но объекты поколения 1 проверяются только тогда, когда их суммарный размер достигает порогового значения
```

Когда запускается сборка мусора:
- Если Windows сообщает о недостаточном объеме свободной памяти, CLR запускает уборку мусора.
- Объем памяти, используемой объектами, выделенными в управляемой куче, превышает допустимый пороговый размер. Этот порог непрерывно корректируется во время выполнения процесса.
- вызывается метод `GC.Collect`


Алгоритм работы сборщика мусора:
0. CLR выбирает пороговый размер для поколения 0,1,2. Они могут меняться в ходе выполнения.
0. CLR выделяет две кучи, одну для малые(SOH) объектов и одну для больших объектов(LOH)(85 000 байт и более) 
1. Только что созданные малые объекты относятся к поколению 0.
1. Только что созданные большие объекты относятся к поколению 2.
2. Если размер поколения 0 превышает пороговое значение, то начаться уборка мусора.
	1. Если во время уборки мусора инициированного 0 поколением уборщик мусора обнаружит что размер поколения 1 превышает пороговое значение, то в нём также начинается уборка мусора.
	2. Если во время уборки мусора инициированного 0 поколением уборщик мусора обнаружит что размер поколения 2 превышает пороговое значение, то в нём также начинается уборка мусора.
3. Фаза №1. Маркировка. Сборщик мусора определяет какие объекты достижимы из кода приложения(они переживут сборку мусора), а какие не доступны и, следовательно, могут быть удалены.(Они не переживут сборку мусора их можно удалить).
4. Фаза №2. Сжатие. Уборщик мусора очищает память недоступных объектов(мусора) и перемещает объекты, пережившие сбор мусора, к более старому сегменту, чтобы все объекты занимали смежный блок памяти(то есть были плотнее друг к другу).
5. Фаза №3. Перемещения. Обновляются ссылки на объекты которые были перемещены(сжаты). CLR вычитает из каждой переменной ссылочного типа количество байт, на которое объект был сдвинут. Тем самым гарантируется, что все переменное ссылочного типа будет ссылаться на тот же объект, что и прежде; просто сейчас этот объект оказался в другом месте памяти.
6. Объекты, созданные на ранних этапах жизненного цикла приложения, которые **переживают сборку**, продвигаются и сохраняются в поколениях 1 и 2.
 
[Подробнее](https://learn.microsoft.com/en-us/archive/msdn-magazine/2008/june/clr-inside-out-large-object-heap-uncovered)
[Подробнее](https://learn.microsoft.com/en-us/dotnet/standard/garbage-collection/fundamentals)
[Подробнее](https://learn.microsoft.com/en-us/dotnet/standard/garbage-collection/large-object-heap)
[Статья от создателя GC-Maoni Stephens ](https://github.com/Maoni0/mem-doc/blob/master/doc/.NETMemoryPerformanceAnalysis.md#GC-Fundamentals)
[Habr](https://habr.com/ru/articles/590475/)
Есть ещё книга Konrad Kokosa - Pro .NET Memory Management на русском книга называлась Управление памятью в .NET для профессионалов | Кокоса Конрад

#### Большие объекты

Существует еще один путь повышения быстродействия, о котором стоит рассказать. CLR делит объекты на **малые** и **большие**. Любые объекты размером 85 000 байт и более считаются большими . CLR работает с большими объектами по несколько отличающимся правилам:
- Память для них выделяется в отдельной части адресного пространства процесса. 
- К большим объектам не применяется сжатие, так как на их перемещение в памяти потребуется слишком много процессорного времени. Возможная фрагментация адресного пространства между большими объектами может привести к выдаче исключения OutOfMemoryException. В будущих версиях CLR большие объекты могут участвовать в сжатии. 
- Большие объекты всегда считаются частью поколения 2, поэтому их следует создавать лишь для ресурсов, которые должны жить долго. Размещение в памяти короткоживущих больших объектов приведет к необходимости частой уборки мусора в поколении 2, что снижает производительность. Обычно в больших объектах хранятся большие строки (например, XML или JSON) или массивы байтов, используемые в операциях ввода/вывода — например, при чтении данных из файла или сети в буфер для последующей обработки.


[Параллельная сборка мусора](https://habr.com/ru/articles/590475/)

#### Режимы уборки мусора
При запуске CLR выбирается один из режимов уборки мусора, который не может быть изменен до завершения процесса. Существует два основных режима уборки мусора:

- **Режим рабочей станции.** Он оптимизирован для минимизации времени приостановки потоков приложения, чтобы не раздражать пользователя. Уборщик предполагает, что на компьютере работают другие приложения, и старается не занимать слишком много ресурсов процессора.

- **Режим сервера.** Уборщик предполагает, что на машине не запущено никаких сторонних приложений (клиентских или серверных), поэтому все ресурсы процессора можно бросить на уборку мусора. В этом режиме управляемая куча разбирается на несколько разделов — по одному на процессор. Изначально уборщик мусора использует один поток на один процессор. Каждый поток выполняется в собственном разделе одновременно с другими потоками. Такой подход хорошо работает в случае приложений с единообразным поведением рабочих потоков. **Функция работает на компьютерах с несколькими процессорами**; только в этом случае параллельная обработка потоков позволяет получить прирост производительности


Принудительно задать серверный режим можно через конфигурационный файл:

```cfg
<configuration>
 <runtime>
 <gcServer enabled="true"/>
 </runtime>
</configuration>
```

Узнать, запущена ли среда CLR в серверном GC-режиме, можно при помощи логического свойства `IsServerGC`:

```csharp
public static class Program
{
	public static void Main()
	{
		Console.WriteLine(
		"Application is running with server GC=" + GCSettings.IsServerGC);
	}
}
```

#### Параллельная (используемый по умолчанию) и непараллельная сборка мусора
> [!success] Обновление
> В более поздних версиях параллельная сборка мусора заменена фоновой. 


Кратко:
**Фоновая сборка мусора позволяет управляемым потокам продолжать операции во время сборки мусора. **


Полно:
В параллельном режиме у уборщика мусора есть **дополнительный фоновый поток**, выполняющий пометку объектов во время работы приложения. Когда поток размещает в памяти объект, вызывающий превышение порога для поколения 0, уборщик сначала приостанавливает все потоки, а затем определяет поколения, в которых нужно выполнить уборку мусора. Если уборщик должен собрать мусор в поколении 0 или 1, он работает как обычно, но если нужно собрать мусор в поколении 2, размер поколения 0 увеличивается выше порогового, чтобы разместить новый объект, а затем исполнение потоков приложения возобновляется. Пока работают потоки приложения, отдельный поток уборщика с нормальным приоритетом находит все недоступные объекты в фоновом режиме. После того как объекты будут обнаружены, уборщик приостанавливает все потоки и решает, нужно ли дефрагментировать память. Если он принимает положительное решение, память дефрагментируется, ссылки корней исправляются, а исполнение потоков приложения возобновляется — такая уборка мусора обычно проходит быстрее, так как перечень недоступных объектов создается заранее. Однако уборщик может отказаться от дефрагментации памяти, что, на самом деле, предпочтительнее. Если свободной памяти много, уборщик не станет дефрагментировать кучу — это повышает быстродействие, но увеличивает рабочий набор приложения. Прибегая к параллельной уборке мусора, приложение обычно расходует больше памяти, чем при непараллельной уборке.

В непараллельном серверном режиме, .NET приостанавливает работу приложения на время работы сборщика мусора. В целом это более эффективно, чем параллельный режим — сборка мусора занимает столько же времени, но при этом ей не приходится бороться с продолжающей работать программой. Однако, при выполнении полной сборки могут возникать заметные паузы.

Запрет использования параллельной сборки мусора:
```cfg
<configuration>
 <runtime>
 <gcConcurrent enabled="false"/>
 </runtime>
</configuration>
```


