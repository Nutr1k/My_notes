---
{"dg-publish":true,"permalink":"/base/clr-via-c-sharp/osnovnye-tipy-dannyh/massivy/"}
---


Массив представляет собой механизм, позволяющий рассматривать набор элементов как единую коллекцию. 
Общеязыковая исполняющая среда Microsoft .NET (CLR) поддерживает **одномерные** (single-dimension), **многомерные** (multidimension) и **нерегулярные** (jagged) массивы. 

Базовым для всех массивов является абстрактный класс System.Array, производный от System.Object. Значит, **массивы всегда относятся к ссылочному тип**у и размещаются в **управляемой куче**, а переменная в приложении содержит **не элементы массива**, а **ссылку на массив**.

##### Массив с элементами значимого типа

```csharp
Int32[] myIntegers; // Объявление ссылки на массив 
myIntegers = new Int32[100]; // Создание массива типа Int32 из 100 элементов
```

1. В первой строке объявляется переменная myIntegers, которая будет ссылаться на одномерный массив элементов типа Int32. Вначале ей присваивается значение null, так как память под массив пока не выделена.
2. Во второй строке выделяется память под 100 значений типа Int32; и всем им присваивается **начальное значение 0**. Поскольку массивы относятся к **ссылочным типам**, блок памяти для хранения 100 неупакованных экземпляров типа Int32 выделяется в **управляемой куче**.
3. Помимо элементов массива в этом блоке размещается **указатель на объект-тип**, **индекс блока синхронизаци**и, а также некоторые **дополнительные члены** -  сведения о размерности массива, нижних границах всех его измерений (почти всегда 0) и количестве элементов в каждом измерении, тип элементов массива.
4. Адрес этого блока памяти заносится в переменную myIntegers.

##### Массив с элементами ссылочного типа
```csharp
Control[] myControls; // Объявление ссылки на массив 
myControls = new Control[50]; // Создание массива из 50 ссылок // на переменную Control
```
1. В первой строке объявляется переменная myControls, которая будет ссылаться на одномерный массив ссылок типа Control. Вначале ей присваивается значение null, так как память под массив пока не выделена.
2. Во второй строке выделяется память под 50 ссылок на Control, и все они **инициализируются значением null**. Поскольку Control относится к ссылочным типам, массив формируется путем **создания ссылок**, а не каких-либо реальных объектов.
3. Помимо элементов массива в этом блоке размещается **указатель на объект-тип**, **индекс блока синхронизаци**и, а также некоторые **дополнительные члены** -  сведения о размерности массива, нижних границах всех его измерений (почти всегда 0) и количестве элементов в каждом измерении, тип элементов массива.
4. Возвращенный адрес блока памяти заносится в переменную myControls.

На рисунке показано, как выглядят массивы значимого и ссылочного типов в управляемой куче. На этом рисунке показан массив Controls после выполнения следующих инструкций:
```csharp
myControls[1] = new Button(); 
myControls[2] = new TextBox(); 
myControls[3] = myControls[2]; // Два элемента ссылаются на один объект  
myControls[46] = new DataGrid(); 
myControls[48] = new ComboBox(); 
myControls[49] = new Button();
```
![Pasted image 20230616181720.png](/img/user/Files/Image/Pasted%20image%2020230616181720.png)


По возможности нужно ограничиваться одномерными массивами с нулевым начальным индексом, которые называют иногда **SZ-массивами**, или **векторами**. Векторы обеспечивают **наилучшую производительность**, поскольку для операций с ними используются команды промежуточного языка (Intermediate Language, IL), например newarr, ldelem, ldelema, ldlen и stelem.

CLR поддерживает также **нерегулярные (jagged) массивы** — то есть «массивы массивов». 
Производительность одномерных **нерегулярных массивов** с нулевым начальным индексом **такая же, как у обычных векторов**. Однако обращение к элементу нерегулярного массива означает обращение к двум или больше массивам одновременно.

```csharp

// Создание одномерного массива из массивов типа Point
Point[][] myPolygons = new Point[3][];
// myPolygons[0] ссылается на массив из 10 экземпляров типа Point
myPolygons[0] = new Point[10];
// myPolygons[1] ссылается на массив из 20 экземпляров типа Point
myPolygons[1] = new Point[20];
```

#### Инициализация элементов массива

Использование инициализатора массива:
Набор разделенных запятой символов в фигурных скобках называется инициализатором массива (array initializer)
```csharp
String[] names = new String[] { "Aidan", "Grant" };
```

Использование локальной переменной неявного типа: 
```csharp
var names = new String[] { "Aidan", "Grant" };
```
В результате **компилятор делает вывод** о том, что локальная переменная names относится к типу `String[]`, так как именно к этому типу принадлежит выражение, расположенное **справа от оператора присваивания (=)**. 
Используя неявную типизацию массивов C#, вы поручаете компилятору определить тип элементов массива

Инициализация массива неявно заданного типа(без явно указанного типа): 
```csharp
var names = new[] { "Aidan", "Grant", null };
string[] names=new[] { "Aidan", "Grant", null };
```
```ad-note
title:Примечание
collapse:
Компилятор определяет тип выражений, используемых для инициализации элементов массива, и по результатам выбирает **базовый класс, который лучше всего описывает все элементы**. В показанном примере компилятор обнаруживает два элемента типа String и значение null. Но так как последнее может быть неявно преобразовано в любой ссылочный тип, выбор делается в пользу создания и инициализации массива ссылок типа String.
```

Самая простая инициализация массива:
```csharp
String[] names = { "Aidan", "Grant" };
```
Инициализация массива неявно заданного типа массива в случае анонимных типов и локальных переменных неявного типа
```csharp
// Применение переменных и массивов неявно заданного типа, 
// а также анонимного типа: 
var kids = new[] {new { Name="Aidan" }, new { Name="Grant" }};
```
```ad-info
title:Пояснение
collapse:
В этом примере для присваивания начальных значений элементам массива используются два выражения, каждое из которых представляет собой анонимный тип (ведь после оператора new ни в одном из случаев не фигурирует имя типа). Благодаря идентичной структуре этих выражений (поле Name типа String) компилятор относит оба объекта к одному типу. Теперь мы можем воспользоваться возможностью **неявного задания типа массива** (когда между оператором new и квадратными скобками отсутствует имя типа). В результате компилятор самостоятельно определит тип, сконструирует массив и инициализирует его элементы как ссылки на два экземпляра одного и того же анонимного типа. В итоге ссылка на этот объект присваивается локальной переменной kids, тип которой определит компилятор.
```


#### Приведение типов в массивах

В CLR для массивов с элементами **ссылочного типа допустимо приведение**.
В рамках решения этой задачи оба типа массивов должны иметь:
- одинаковую размерность; 
- должно иметь место неявное или явное преобразование из типа элементов исходного массива в целевой тип. 
CLR не поддерживает преобразование массивов с элементами **значимых типов** в другие типы.

```csharp
// Создание двухмерного массива FileStream
FileStream[,] fs2dim = new FileStream[5, 10];

// Неявное приведение к массиву типа Object
Object[,] o2dim = fs2dim;

// Явное приведение к двухмерному массиву 
Stream Stream[,] s2dim = (Stream[,]) o2dim;

// Явное приведение к массиву String 
// Компилируется, но во время выполнения 
// возникает исключение InvalidCastException
Object[] o3dim = new Object[2] { "BMW", "Mercedes" };
String[] st2dim = new String[2];
st2dim = (String[])o3dim;


// Создание нового массива и приведение элементов к нужному типу
// при помощи метода Array.Copy
// Создаем массив ссылок на упакованные элементы типа Int32
Object[] ob1dim = new Object[i1dim.Length];
Array.Copy(i1dim, ob1dim, i1dim.Length);
```

```ad-question
title:Почему так?
collapse:
Странно, почему нельзя привести массив типа Object к типу String. Если тип object без проблем можно привести к типу string
```csharp
object o = "BMW";
string st = (string)o;
```

Метод `Array.Copy` не просто копирует элементы одного массива в другой. Он действует как функция `memmove` языка C, но при этом правильно обрабатывает перекрывающиеся области памяти. Он также способен при необходимости преобразовывать элементы массива в процессе их копирования. 

Метод Copy выполняет следующие действия:
- **Упаковка** элементов значимого типа в элементы ссылочного типа, например копирование Int32[] в Object[]. 
- **Распаковка** элементов ссылочного типа в элементы значимого типа, например копирование Object[] в Int32[]. 
- Расширение (widening) примитивных значимых типов, например копирование Int32[] в Double[]. 
- Понижающее приведение в случаях, когда совместимость массивов невозможно определить по их типам. Сюда относится, к примеру, приведение массива типа Object[] в массив типа IFormattable[]. Если все объекты в массиве Object[] реализуют интерфейс IFormattable[], приведение пройдет успешно

##### Ковариация массива(array covariance)

Бывают ситуации, когда полезно изменить тип массива, то есть выполнить его ковариацию (array covariance). Однако следует помнить, что эта операция сказывается на производительности.

```csharp
String[] sa = new String[100];
Object[] oa = sa; // oa ссылается на массив элементов типа String
oa[5] = "Jeff";	  // CLR проверяет принадлежность oa к типу String;
				  // Проверка проходит успешно
oa[3] = 5;		  // CLR проверяет принадлежность oa к типу Int32;
				  // Генерируется исключение ArrayTypeMismatchException
```

В этом коде переменная oa, тип которой определен как Object[], ссылается на массив типа String[]. 
Затем вы пытаетесь присвоить одному из элементов этого массива значение 5, относящееся к типу Int32, производному от типа Object. Естественно, CLR проверяет корректность такого присваивания, то есть в процессе выполнения контролирует наличие в массиве элементов типа Int32. В данном случае такие элементы отсутствуют, что и становится причиной исключения ArrayTypeMismatchException.

#### Базовый класс System.Array

Рассмотрим объявление переменной массива: 
```csharp
FileStream[] fsArray;
```
Объявление переменной массива подобным образом приводит к автоматическому созданию типа FileStream[] для домена приложений. Тип FileStream[] **является производным от System.Array** и соответственно наследует оттуда все методы и свойства. 

Для их вызова служит переменная fsArray. Это упрощает работу с массивами, ведь в классе System.Array есть множество полезных методов и свойств, в том числе Clone, CopyTo, GetLength, GetLongLength, GetLowerBound, GetUpperBound, Length и Rank.

#### Реализация интерфейсов IEnumerable, ICollection и IList

Многие методы работают с коллекциями, поскольку они объявлены с такими параметрами, как интерфейсы `IEnumerable`, `ICollection` и `IList`. Им можно передавать и массивы, так как эти три необобщенных интерфейса реализованы в классе `System.Array`. 

Данная реализация обусловлена тем, что эти интерфейсы интерпретируют любой элемент как экземпляр `System.Object`. Однако хотелось бы также, чтобы класс `System.Array` реализовывал **обобщенные эквиваленты этих интерфейсов**, обеспечивая лучший **контроль типов** во время компиляции и **повышенную производительность**.

Команда разработчиков CLR решила, что не стоит осуществлять реализацию интерфейсов `IEnumerable<T>`, `ICollection<T>` и `IList<T>` классом System.Array, так как в этом случае возникают проблемы с многомерными массивами, а также с массивами, в которых нумерация не начинается с нуля. Ведь определение этих интерфейсов в указанном классе означает необходимость поддержки массивов всех типов. 

Вместо этого разработчики пошли на хитрость: при создании одномерного массива с начинающейся с нуля индексацией CLR автоматически реализует интерфейсы `IEnumerable<T>`, `ICollection<T>` и `IList<T>` (здесь T — тип элементов массива) **во время выполнения**, а также три интерфейса для всех базовых типов массива **<u>при условии, что эти типы являются ссылочными</u>**.

Пример: 
```csharp
FileStream[] fsArray;
``` 
В этом случае при создании типа `FileStream[]` CLR автоматически реализует в нем интерфейсы `IEnumerable<FileStream>`, `ICollection<FileStream>` и `IList<FileStream>`. Более того, тип FileStream[] будет реализовывать интерфейсы базовых классов `IEnumerable<Stream>`, `IEnumerable<Object>`,` ICollection<Stream>`, `ICollection<Object>`, `IList<Stream>` и `IList<Object>`.

Так как все эти интерфейсы реализуются средой CLR автоматически, переменная fsArray может применяться во всех случаях использования этих интерфейсов. Например, ее можно передавать в методы с такими прототипами:

```csharp
void M1(IList<FileStream> fsList) { ... } 
void M2(ICollection<Stream> sCollection) { ... } 
void M3(IEnumerable<Object> oEnumerable) { ... }
```

Обратите внимание, что если массив содержит **<u>элементы значимого типа</u>**, класс, которому он принадлежит, не будет реализовывать интерфейсы базовых классов элемента. 
Например:
```csharp
DateTime[] dtArray; // Массив элементов значимого типа
```

В данном случае тип `DateTime[]` будет реализовывать только интерфейсы `IEnumerable<DateTime>`, `ICollection<DateTime>` и `IList<DateTime>`. Несмотря на то, что для него неявно являются базовыми классы `System.ValueType` и `System.Object`. Но т.к. `DateTime` является структурой, а структуры относятся к значимым типам, то
версии этих интерфейсов, общие для классов `System.ValueType` или `System.Object`, реализованы не будут. 

А это значит, что переменную dtArray нельзя передать показанному ранее методу `M3` в качестве аргумента. Ведь массивы значимых и ссылочных типов располагаются в памяти по-разному.

```ad-info
title: Из документации Microsoft
collapse:
Начиная с .NET Framework 2.0 класс Array реализует универсальные интерфейсы `System.Collections.Generic.IList<T>`, 
`System.Collections.Generic.ICollection<T>`и `System.Collections.Generic.IEnumerable<T>`. **Реализации предоставляются массивам во время выполнения, и в результате универсальные интерфейсы не отображаются в синтаксисе объявления для класса Array.** Кроме того, нет справочных разделов для членов интерфейса, которые доступны только путем приведения массива к общему типу интерфейса (явные реализации интерфейса). **Главное, о чем следует помнить при приведении массива к одному из этих интерфейсов, это то, что члены, которые добавляют, вставляют или удаляют элементы, вызывают исключение NotSupportedException.**
Источники:
[StackOverflow](https://stackoverflow.com/questions/35653973/array-doesnt-implement-icollectiont-but-is-assignable)
[StackOverflow](https://stackoverflow.com/questions/4482557/what-interfaces-do-all-arrays-implement-in-c)
[Array Class](https://learn.microsoft.com/ru-ru/dotnet/api/system.array?view=net-7.0)
```