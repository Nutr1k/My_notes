Перечислимым (enumerated type) называют значимый тип, в котором описан набор пар, состоящих из символьных имен и значений. Базовый тип перечислений это целые числа (int), которые находятся на стеке.

Значение перечисления определяется автоматически, посредством присваивания константе значение предыдущей константы +1

Далее приведен тип Color, определяющий совокупность идентификаторов, каждый из которых обозначает определенный цвет:

```csharp
internal enum Color
{
	White, // Присваивается значение 0
	Red, // Присваивается значение 1
	Green, // Присваивается значение 2
	Blue, // Присваивается значение 3
	Orange // Присваивается значение 4
}
```

Базовый тип перечислений можно изменить на `byte`, `sbyte`, `short`, `ushort`, `int`, `uint`, `long`и `ulong`

```csharp
public enum Color : byte
{
}
```

Перечисления могут быть также типа char
```csharp
internal enum Color
{
	White='w',
	Red='r',
}
```

При компиляции перечислимого типа компилятор C# превращает каждый идентификатор в константное поле типа. Например, предыдущее перечисление Color компилятор видит примерно так:
![Pasted image 20230613180333.png](/img/user/Files/Image/Pasted%20image%2020230613180333.png)

Это практически равно этому:

```csharp
internal struct Color : System.Enum
{
	// Далее перечислены открытые константы,
	// определяющие символьные имена и значения
	public const Color White = (Color)0;
	public const Color Red = (Color)1;
	public const Color Green = (Color)2;
	public const Color Blue = (Color)3;
	public const Color Orange = (Color)4;
	// Далее находится открытое поле экземпляра со значением переменной Color
	// Код с прямой ссылкой на этот экземпляр невозможен
	public Int32 value__;
}
```


В общем-то, перечислимый тип — это **обычная структура**, внутри которой описан **набор константных полей** и одно экземплярное поле. Константные поля попадают в метаданные сборки, откуда их можно извлечь с помощью механизма отражения.

#### Подробнее про экземплярное поле `value__`
Когда мы хотим получить значение перечисление вот таким образом:
```csharp
var a=(Color)0;
```
То у нас происходит Casting ((Приведение типов), причём с оператором `unchecked`(он игнорирует переполнение и усекает значение)), к типу поля.

Приведённый выше код транслируется в:
```csharp
var a=(Color)unchecked((Int32)0);
```

То есть когда мы хотим получить значение элемента перечисления, то наше числовое значение каститься и присваивается полю `__value,` а потом по нему ищется уже конкретное значение элемента перечисления.

Доказательство:
Тип поля `__value` был вручную изменён на uint8
![Pasted image 20241110061418.png](/img/user/Files/Image/Pasted%20image%2020241110061418.png)



Но есть ещё одно очень важное замечание(не понимаю почему так работает)
Если числовое значение в вызывающем коде совпадает с конкретным значением элемента перечисления, то кастинга не происходит.
![Pasted image 20241110061700.png](/img/user/Files/Image/Pasted%20image%2020241110061700.png)

```ad-important
title:Важно
collapse:

Описанные перечислимым типом символы являются константами. Встречая в коде символическое имя перечислимого типа, компилятор заменяет его числовым значением. В результате определяющая перечислимый тип сборка может оказаться ненужной во время выполнения. Но если в коде присутствует ссылка не на определенные перечислимым типом символические имена, а на сам тип, присутствие сборки на стадии выполнения будет обязательным. То есть возникает проблема версий, связанная с тем, что символы перечислимого типа являются константами, а не значениями, предназначенными только для чтения
```

#### Методы

```csharp
public static Type GetUnderlyingType(Type enumType);// Определен 
													// в типе System.Enum
public Type GetEnumUnderlyingType(); // Определен в типе System.Type
```
Оба этих метода возвращают базовый тип, используемый для хранения значения перечислимого типа

```csharp
public static void Main()
{
	Console.WriteLine(Enum.GetUnderlyingType(typeof(Color)));//System.Int32
	Console.WriteLine(typeof(Color).GetEnumUnderlyingType());//System.Int32
}
```

Компилятор C# считает перечислимые типы примитивными, поэтому для операций с их экземплярами применяются уже знакомые нам операторы (`==, !=, <, >, <=, >=, +, –, ^, &, |, ~, ++ и ––`). Все они применяются к полю `value__` экземпляра перечисления

##### Формат перечислений

```csharp
Color c = Color.Blue;
Console.WriteLine(c); // "Blue" (Общий формат)
Console.WriteLine(c.ToString()); // "Blue" (Общий формат)
Console.WriteLine(c.ToString("G")); // "Blue" (Общий формат)
Console.WriteLine(c.ToString("D")); // "3" (Десятичный формат)
Console.WriteLine(c.ToString("X")); // "00000003" (Шестнадцатеричный формат)

Console.WriteLine(Enum.Format(typeof(Color), 3, "G")); //"Blue"
```

```csharp
internal enum Color
{
	White, // Присваивается значение 0
	Red=0, // Присваивается значение 0
}
```

##### Удобный вывод перечислений
```csharp
public static Array GetValues(Type enumType)// Определен в типе System.Enum
public Array GetEnumValues()// Определен в типе System.Type
```
Пример:
```csharp
Color[] colors = (Color[])Enum.GetValues(typeof(Color).GetEnumValues);
Console.WriteLine("Number of symbols defined: " + colors.Length);
Console.WriteLine("Value\tSymbol\n-----\t------");
foreach (Color c in colors)
{
	// Выводим каждый идентификатор в десятичном и общем форматах
	Console.WriteLine("{0,5:D}\t{0:G}", c);
}
```

```ad-note
title:Одинаковое числовое значение у разных идентификаторов
collapse:
Можно объявить перечисление, различные идентификаторы которого имеют одинаковое числовое значение. В процессе преобразования числового значения в символ посредством общего форматирования методы типа вернут один из символов, правда, неизвестно какой. Если соответствия не обнаруживается, возвращается строка с числовым значением.
```csharp
internal enum Color
{
	White,
	Black = 0,
	Blue = 3,
	Green = 2,
	Red
}
public static void Main()
{
	Console.WriteLine((Color)0);  //Black
	Console.WriteLine((Color)3);  //Blue
}
```

#### Битовые флаги

Перечисления можно использовать для хранения битовых флагов, благодаря этому экземпляр enum может содержать в себе комбинацию значений констант, определенных в списке.

В FCL тип FileAttributes описан следующим образом:
```csharp
[Flags, Serializable]
public enum FileAttributes
{
	ReadOnly = 0x0001,
	Hidden = 0x0002,
	System = 0x0004,
	Directory = 0x0010,
	Archive = 0x0020,
	Device = 0x0040,
	Normal = 0x0080,
	Temporary = 0x0100,
	SparseFile = 0x0200,
	ReparsePoint = 0x0400,
	Compressed = 0x0800,
	Offline = 0x1000,
	NotContentIndexed = 0x2000,
	Encrypted = 0x4000
}
```

Следующий фрагмент проверяет, является ли файл скрытым:
```csharp
String file = Assembly.GetEntryAssembly().Location;
FileAttributes attributes = File.GetAttributes(file);
Console.WriteLine("Is {0} hidden? {1}", file, (
			attributes & FileAttributes.Hidden) != 0);
```
```ad-note
title:Примечание
В классе Enum имеется метод HasFlag, однако я не рекомендую использовать метод HasFlag. Дело в том, что он принимает параметры типа Enum, а значит, передаваемые ему значения должны быть упакованы, что требует дополнительных затрат памяти.
```

Пример демонстрирует, как изменить файлу атрибуты «только для чтения» и «скрытый»:
```csharp
File.SetAttributes(file, FileAttributes.ReadOnly | FileAttributes.Hidden);
```

Для создания перечисления с битовыми флагами, используется атрибут **Flags** или **FlagsAttribute**

Каждый битовый флаг у нас пронумерован согласно степени двойки и увеличивается в два раза для каждого последующего элемента.
```csharp
[Flags] // Компилятор C# допускает значение "Flags" или "FlagsAttribute"
internal enum Actions
{
	None =	 0b00000,//0 в десятичной системе
	Read =	 0b00001,//1
	Write =	 0b00010,//2
	Delete = 0b00100,//4
	Query =  0b01000,//8
	Sync =   0b10000 //16
}
```
`0x` в начале означает что число записано в шестнадцатеричной системе
`0b` в начале означает что число записано двоичной системе

Битовые флаги используют степени двойки т.к. с их помощью можно составить любые другие промежуточные комбинации.

Единственный вариант использовать не только степени двойки нужен тогда, когда у нас есть логического значения, которое на самом деле **является комбинацией двух других**.

```csharp
[Flags]
internal enum Actions
{
	None =	    0b00000,//0 в десятичной системе
	Read =	    0b00001,//1
	Write =	    0b00010,//2
	ReadWrite = 0b00011,//3
	Delete =    0b00100,//4
	Query =     0b01000,//8
	Sync =      0b10000 //16
}
```
`ReadWrite` - является комбинацией двух битовых флагов `Read` и `Write`. 
Флаг `ReadWrite` можно записать также как: `ReadWrite = Actions.Read | Actions.Write`.
Данный флаг имеет смысл записывать отдельно т.к. он часто используемый.

Если битовые флаги не являются степенями двойки, а также не является комбинацией двух других в логическом смысле, то возникает неопределённость при их комбинации и проверке. 
Другими словами, `2|3 == 1|3 == 1|2 == 3`. Таким образом, если у вас есть значение с binary `00000011`и ваши флаги включают значения `1`, `2`и `3`, то вы не будете знать, представляет ли это значение `1 and 3`, `2 and 3`, `1 and 2`или `только 3`

Пример:

Битовый флаг `Delete` не является комбинацией двух других(`Read` и `Write`) в логическом смысле т.к. `Delete` не объединяет в себе понятия `Read` и `Write`. Но при этом он является логическим сложение в булевых операциях(`V, | или +`) т.к. 

`Read` = 00001
`Write`=<u>00010</u>
⠀⠀⠀⠀⠀ 00011

Следовательно, если у нас битовый флаг `00011` то невозможно однозначно идентифицировать к чему относиться этот флаг, к `Read` и `Write` или только к `Delete`.
```csharp
[Flags]
internal enum Actions
{
	None =   0b00000, //0 в десятичной системе
	Read =   0b00001, //1
	Write =  0b00010, //2
	Delete = 0b00011, //3
}
```
```csharp
Actions actions = Actions.Read | Actions.Write;
Console.WriteLine(actions.ToString());//Delete

int bitFlag = 0b00011;
int number = Convert.ToInt32(bitFlag);
var act2 = (Actions)Enum.Parse(typeof(Actions), number.ToString(), false);
Console.WriteLine(act2.ToString());//Delete
```

Во второй строке выводиться `Delete`, хотя были заданы флаги `Read` и `Write`
Во второй строке выводиться `Delete`, хотя значение 0b00011 соответствует  `Read` и `Write`, но так же оно соответствует `Delete`.

Если мы бы даже решили использовать не только степени двойка, а и другие числа, то у нас не было бы проблем если бы под значением 00011(3) вместо `Delete` у нас был бы флаг `ReadWrite`. Т.к. `ReadWrite` объединяет в себе понятия `Read` и `Write`.

Таким образом, если у нас есть значение с binary `00000011`и наши флаги включают значения `Read`, `Write`и `ReadWrite`, то нет разницы, представляет ли это значение `Read and Write` или только `ReadWrite`.

Т.к. что комбинация `Actions.Read | Actions.Write`что и `ReadWrite` несут одинаковый логический смысл.

Так же с помощью 4 битовых флагов можно представить $2^{(4-1)}=8$ комбинаций, это намного легче чем записывать их все
```csharp
public enum Permissions 
{   
    DeleteNoWriteNoReadNo = 0,   // None
    DeleteNoWriteNoReadYes = 1,  // Read
    DeleteNoWriteYesReadNo = 2,  // Write
    DeleteNoWriteYesReadYes = 3, // Read + Write
    DeleteYesWriteNoReadNo = 4,   // Delete
    DeleteYesWriteNoReadYes = 5,  // Read + Delete
    DeleteYesWriteYesReadNo = 6,  // Write + Delete
    DeleteYesWriteYesReadYes = 7, // Read + Write + Delete
} 
```

##### Методы для работы с битовыми флагами

Метод **ToString** пытается преобразовать числовое значение в его символьный эквивалент.

```csharp
[Flags]
internal enum Actions
{
	None =	    0b00000,//0 в десятичной системе
	Read =	    0b00001,//1
	Write =	    0b00010,//2
	ReadWrite = 0b00011,//3
	Delete =    0b00100,//4
	Query =     0b01000,//8
	Sync =      0b10000 //16
}
```


```csharp
Actions actions = Actions.Read | Actions.Delete; // 00101
Console.WriteLine(actions.ToString()); // "Read, Delete"
```
У числового значения `00101` нет символьного эквивалента. Однако обнаружив у типа Actions атрибут `Flags`, метод `ToString` рассматривает числовое значение уже как набор битовых флагов. Так как биты 00001 и 00100 при логическом сложении равны `00101` то, метод ToString формирует строку "Read, Delete". Если в описании типа Actions убрать атрибут `Flags`, метод отыскивает и возвращает идентификатор, соответствующий данному числовому значению и возвращает его, в нашем случае метод вернул бы "5".

ToString действует по следующему алгоритму:
1. Получает набор числовых значений, определенных в перечислении, и сортирует их в нисходящем порядке. 
2. Для каждого значения выполняется операция конъюнкции (AND) с экземпляром перечисления. В случае равенства результата числовому значению связанная с ним строка добавляется в итоговую строку, соответствующие же биты считаются учтенными и сбрасываются. Операция повторяется до завершения проверки всех числовых значений или до сброса все битов экземпляров перечисления. 
3. Если после проверки всех числовых значений экземпляр перечисления все еще не равен нулю, это означает наличие несброшенных битов, которым не сопоставлены идентификаторы. В этом случае метод возвращает исходное число экземпляра перечисления в виде строки. 
4. Если исходное значение экземпляра перечисления не равно нулю, метод возвращает набор символов, разделенных запятой. 
5. Если исходным значением экземпляра перечисления был ноль, а в перечислимом типе есть идентификатор с таким значением, метод возвращает этот идентификатор. 
6. Если алгоритм доходит до данного шага, возвращается 0

Методы **Parse** и **TryParse** типа Enum получают числовое значение строки, содержащей разделенные запятой идентификаторы.

```csharp
// Так как Query определяется как 8, 'a' получает начальное значение 8
Actions a = (Actions)Enum.Parse(typeof(Actions), "Query", true);
Console.WriteLine(a.ToString()); // "Query"

// Так как у нас определены и Query, и Read, 'a' получает
// начальное значение 9
Enum.TryParse<Actions>("Query, Read", false, out a);
Console.WriteLine(a.ToString()); // "Read, Query"

// Создаем экземпляр перечисления Actions enum со значением 28
a = (Actions)Enum.Parse(typeof(Actions), "28", false);
Console.WriteLine(a.ToString()); // "Delete, Query, Sync"
```

При вызове методов Parse и TryParse выполняются следующие действия:
1. Удаляются все пробелы в начале и конце строки. 
2. Если первым символом в строке является цифра, знак «плюс» (+) или знак «минус» (–), строка считается числом и возвращается экземпляр перечисления, числовое значение которого совпадает с числом, полученным в результате преобразования строки. 
3. Переданная строка разбивается на разделенные запятыми лексемы, и у каждой лексемы удаляются все пробелы в начале и конце. 
4. Выполняется поиск каждой строки лексемы среди идентификаторов перечисления. Если символ найти не удается, метод Parse генерирует исключение System. ArgumentException, а метод TryParse возвращает значение false. При обнаружении символа его числовое значение путем дизъюнкции (OR) присоединяется к результирующему значению, и метод переходит к анализу следующего символа. 
5. После обнаружения и проверки всех лексем результат возвращается программе.


[Битовые поля(Flags) vs Enum(без атрибута Flags)](http://microsin.net/programming/pc/working-with-bitfields-in-c-sharp.html)

  
#### Ковариация массива

Бывают ситуации, когда полезно изменить тип массива, то есть выполнить его ковариацию (array covariance). Однако следует помнить, что эта операция сказывается на производительности.

```csharp
String[] sa = new String[100];
Object[] oa = sa; // oa ссылается на массив элементов типа String
oa[5] = "Jeff";   // CLR проверяет принадлежность oa к типу String;
				  // Проверка проходит успешно
oa[3] = 5; // CLR проверяет принадлежность oa к типу Int32;
		   // Генерируется исключение ArrayTypeMismatchException
```
В этом коде переменная oa, тип которой определен как Object[], ссылается на массив типа String[]. Затем вы пытаетесь присвоить одному из элементов этого массива значение 5, относящееся к типу Int32, производному от типа Object. Естественно, CLR проверяет корректность такого присваивания, то есть в **процессе выполнения контролирует наличие в массиве элементов типа Int32**. В данном случае такие элементы отсутствуют, что и становится причиной исключения ArrayTypeMismatchException.