---
{"dg-publish":true,"permalink":"/base/clr-via-c-sharp/osnovnye-tipy-dannyh/delegaty/"}
---


В Microsoft .NET Framework методы(функции) обратного вызова поддерживаются при помощи делегатов.
Делегат - всего лишь адрес метода обеспечивающий безопасность типов
Делегаты представляют собой некую оболочку для экземплярных и статических методов.  
Делегат — это всего лишь обертка для метода и обрабатываемого этим методом объекта. 
Один делегат(или его множество экземпляров) может использоваться для бесконечного множества методов сигнатуры которых просто совпадают с сигнатурой делегата.

Следует помнить, что делегаты можно определять как внутри класса (вложенные в другой класс), так и в глобальной области видимости. По сути, так как делегаты являются классами, их можно определить в любом месте, где может быть определен класс.

```csharp
delegate тип_возвращаемого_значения имя_делегата(тип параметра1,)
```

Способы присваивания адреса метода делегату.
```csharp
class Program
{
	delegate void Message(string text);
	public static void Main()
	{
		//Сокращённый синтаксис
		Message mes;            // 2. Создаем переменную делегата
		mes = Hello;            // 3. Присваиваем этой переменной адрес метода

		//Посредством оператора new
		Message mes2 = new Message(Hello); 
	}
	public static void Hello(string text) => Console.WriteLine(text);
}
```

#### Реализация делегатов CLR

Данная строка кода:
```csharp
internal delegate void Message(string text);
```

Заставляет компилятор создать полное определение класса, которое выглядит примерно так:
```csharp
internal class Message : System.MulticastDelegate
{
	// Конструктор
	public Message(Object object, IntPtr method);
	
	// Метод, прототип которого задан в исходном тексте
	public virtual void Invoke(string value);
	// Методы, обеспечивающие асинхронный обратный вызов
	
	public virtual IAsyncResult BeginInvoke(string value,
	AsyncCallback callback, Object object);
	public virtual void EndInvoke(IAsyncResult result);
}
```
Данный класс содержит:
1.Конструктор:
- Принимает ссылка на объект с которым будет работать
- Внутреннее целочисленное значение, используемое CLR для однозначной идентификации метода обратного вызова.
2. Метод `Invok`
Метод сигнатура которого определяется(совпадает) по сигнатуре определённого делегата
3. `BeginInvoke`- для модели асинхронного программирования(устарело)
4. `EndInvoke`- для модели асинхронного программирования(устарело)



![Pasted image 20241114153547.png](/img/user/Files/Image/Pasted%20image%2020241114153547.png)

Любые типы делегатов — это потомки класса MulticastDelegate, от которого они наследуют все поля, свойства и методы. Три самых важных поля:

| Поле            | Тип           | Описание |
| --------------- | ------------- | -------- |
| _target         | System.Object | Если делегат является оболочкой статического метода, это поле содержит значение null. Если делегат является оболочкой экземплярного метода, поле ссылается на объект, с которым будет работать метод обратного вызова. Другими словами, поле указывает на значение, которое следует передать параметру this экземплярного метода         |
| _methodPtr      | System.IntPtr | Внутреннее целочисленное значение, используемое CLR для идентификации метода обратного вызова         |
| _invocationList | System.Object |  Это поле обычно имеет значение null. Оно может ссылаться на массив делегатов при построении из них цепочки (об этом мы поговорим чуть позже)        |

#### Синтаксический сахар
Конструктор всех делегатов принимает два параметра: ссылку на объект и целое число, ссылающееся на метод обратного вызова. 
Но в коде достаточно указывать только метод:
```csharp
Message mes2 = new Message(Hello); 
```
Т.к. компилятор знает о том, что создается делегат, и, проанализировав код, определяет объект и метод, на которые мы ссылаемся. 

Ссылка на объект передается в параметре object конструктора. 
Специальное значение IntPtr (получаемое из маркеров метаданных MethodDef или MemberRef), идентифицирующее метод, передается в параметре method. 

В случае статических методов параметр object передает значение null. Внутри конструктора значения этих двух аргументов сохранятся в закрытых полях _target и _methodPtr соответственно.

Приведённая ниже строка:
```csharp
mes("Hello");
```
Компилируется в:
```csharp
mes.Invoke("Hello");
```

Компилятор определяет метод Invoke при определении класса Message. Вызывая этот метод, он использует закрытые поля _target и _methodPtr для вызова желаемого метода на заданном объекте. Обратите внимание, что сигнатура метода Invoke совпадает с сигнатурой делегата, ведь и делегат Message, и метод Invoke принимают один параметр типа String и возвращают значение void



#### Визуализация делегатов
Верхняя переменная ссылается на делегата статического метода,. нижняя — на делегата экземплярного метода
![Pasted image 20241114161651.png](/img/user/Files/Image/Pasted%20image%2020241114161651.png)


#### Упрощенный синтаксис работы с делегатами

Данная строка кода:
```csharp
button1.Click += button1_Click;
```
транслируется в:
```csharp
button1.Click += new EventHandler(button1_Click);
```

`EventHandler` - это предопределённый делегат
```csharp
public delegate void EventHandler(object? sender, EventArgs e);
```