Символы в .NET Framework всегда представлены **16-разрядными кодами** стандарта Юникод.
Символ представляется экземпляром структуры System.Char (**значимый тип**).

Предпочтительные способы преобразования различных числовых типов в экземпляры типа Char.

1. **Приведение типа.** Самый эффективный способ, так как компилятор генерирует IL-команды преобразования без вызовов каких-либо методов. Для преобразования типа Char в числовое значение, такое как Int32, приведение подходит лучше всего. Допускается указывать, какой код должен использоваться при выполнении преобразования: проверяемый или непроверяемый
```csharp
	Char c; Int32 n;
	// Преобразование "число - символ" посредством приведения типов C#
	c = (Char)65;
	Console.WriteLine(c); // Выводится "A"
	n = (Int32)c;
	Console.WriteLine(n); // Выводится "65"
	c = unchecked((Char)(65536 + 65));
	Console.WriteLine(c); // Выводится "A"
```
2. **Использование типа Convert**. У типа System.Convert есть несколько статических методов, корректно преобразующих Char в числовой тип и обратно. Все эти методы выполняют преобразование как проверяемую операцию, чтобы в случае потери данных при преобразовании возникало исключение OverflowException.
```csharp
	Char c; Int32 n;
	c = Convert.ToChar(65);
	Console.WriteLine(c); // Выводится "A"
	n = Convert.ToInt32(c);
	Console.WriteLine(n); // Выводится "65"
						  // Демонстрация проверки диапазона для Convert
	try
	{
		c = Convert.ToChar(70000); // Слишком много для 16 разрядов
		Console.WriteLine(c); // Этот вызов выполняться НЕ будет
	}
	catch (OverflowException)
	{
		Console.WriteLine("Can't convert 70000 to a Char.");
	}
```
3. **Использование интерфейса IConvertible**.  Этот способ наименее эффективен, так как вызов интерфейсных методов для числовых типов приводит **к упаковке экземпляра**: Char и все числовые типы являются значимыми типами. Методы IConvertible генерируют исключение System. InvalidCastException, если преобразование невозможно (например, преобразование типа Char в Boolean) или грозит потерей данных. Во многих типах (в том числе Char и числовых типах FCL) используются EIMI-реализации методов IConvertible, а значит, перед вызовом какого-либо метода этого интерфейса нужно выполнить явное приведение экземпляра к IConvertible
```csharp
	Char c; Int32 n;
	// Преобразование "число - символ" с помощью интерфейса IConvertible
	c = ((IConvertible)65).ToChar(null);
	Console.WriteLine(c); // Выводится "A"
	n = ((IConvertible)c).ToInt32(null);
	Console.WriteLine(n); // Выводится "65"
```

#### Создание строк
System.String, — представляет неизменяемый упорядоченный набор символов. Будучи прямым потомком Object, он является ссылочным типом, по этой причине **строки всегда размещаются в куче и никогда в стеке потока**.

~~Во многих языках (включая C#) String относится к примитивным типам~~, то есть компилятор разрешает вставлять литеральные строки непосредственно в исходный код.

Является ли строка примитивным типом или нет зависит от определения примитива, **которое не определено однозначно** [Эрик Липперт](https://stackoverflow.com/questions/2066035/in-c-are-the-terms-primitive-and-literal-interchangeable/2135136#2135136)

1. Строки считают примитивными типами данных т.к. синтаксис создания новой строки аналогичен созданию типов значений.

```csharp
System.Int32 a = new System.Int32(5);
System.Int32 a = 5;
int a = 5;
```

Точно так же, как при создании строки ссылочного типа:

```csharp
System.String s = new System.String(new char[]{'h', 'e', 'l', 'l', 'o'});
System.String s = "hello";
string s = "hello";
```

2. Также мы можем сравнивать строки по значению, даже если они являются ссылочными типами:
```csharp
string s = "hello";
bool b = (s == "hello"); //true
```

3. Также есть поддержка объединения строк с помощью `+`оператора, который компилятор превращает в вызов метода `String.Concat`.

4. Строки являются неизменяемыми, что означает, что в большинстве ситуаций они имеют семантику **значимых типов**, как и **примитивные типы**.

`System.String`сопоставляется с "`string`", который является примитивным типом в CLI. _Но на самом деле типы значений — это те, которые находятся в стеке, а не в куче._


##### Задание специальных символов
```csharp
// String содержит символы конца строки и перевода каретки 
String s = "Hi\r\nthere.";
```
> [!warning] 
> Задавать в коде последовательность символов конца строки и перевода каретки напрямую, как это сделано в представленном примере, не рекомендуется. 

Рекомендуется использовать свойство `NewLine` зависит от платформы и возвращает ту строку, которая обеспечивает создание разрыва строк на конкретной платформе

```csharp
String s = "Hi" + Environment.NewLine + "there.";
```


#### Конкатенация строк

Конкатенация литеральных строк выполняется на этапе компиляции.
![Pasted image 20230605181030.png](/img/user/Files/Image/Pasted%20image%2020230605181030.png)

Переменная с присвоенным литералом не будет являться литералом
![Pasted image 20230605181833.png](/img/user/Files/Image/Pasted%20image%2020230605181833.png)

Конкатенация нелитеральных строк с помощью оператора + происходит на этапе выполнения
![Pasted image 20230605181811.png](/img/user/Files/Image/Pasted%20image%2020230605181811.png)


Для конкатенации нескольких строк на этапе выполнения оператор + применять нежелательно, так как он создает в куче несколько строковых объектов. Вместо него рекомендуется использовать тип System.Text. StringBuilder

#### Буквальные строки (verbatim strings)
Буквальная строка - особый вариант объявления строки, в которой все символы между кавычками трактуются как часть строки.

```csharp
// Задание пути к приложению
String file = "C:\\Windows\\System32\\Notepad.exe";
// Задание пути к приложению с помощью буквальной строки
String file = @"C:\Windows\System32\Notepad.exe";
```

Оба фрагмента кода дают одинаковый результат. Однако символ **@** перед строкой во втором случае сообщает компилятору, что перед ним буквальная строка и он должен рассматривать символ обратной косой черты (`\`) буквально, а не как префикс управляющей последовательности(`\r \n`), благодаря чему путь в коде выглядит более привычно.

#### Неизменяемые строки(immutable string)

Самое важное, что нужно помнить об объекте String — то, что он **неизменяем**; то есть созданную однажды строку нельзя сделать длиннее или короче, в ней нельзя изменить ни одного символа.

```csharp
if (s.ToUpperInvariant().Substring(10, 21).EndsWith("EXE")) 
{ ... }
```
1. Здесь ToUpperInvariant возвращает новую строку; символы в строке s не изменяются. 
2. SubString обрабатывает строку, возвращенную ToUpperInvariant, и тоже возвращает новую строку.
3. которая затем передается методу EndsWith.

В программном коде приложения **нет ссылок на две временные строки**, созданные ToUpperInvariant и SubString, поэтому занятая ими память **освободится при очередной уборке мусора**. 

Если выполняется много операций со строками, в куче создается **много объектов String** — это заставляет чаще прибегать к помощи **уборщика мусора**, что отрицательно сказывается на **производительности** приложения.


В CLR несколько ссылок String могут указывать на один, а не **на несколько разных строковых объектов, если строки идентичны**. А значит, можно сократить количество строк в системе и уменьшить расход памяти — это именно то, что непосредственно относится к интернированию строк (string interning), о котором речь пойдет дальше.

#### Сравнение строк

Сравнение строк с помощью оператора `==`:
![Pasted image 20241019221420.png](/img/user/Files/Image/Pasted%20image%2020241019221420.png)
![Pasted image 20241019221455.png](/img/user/Files/Image/Pasted%20image%2020241019221455.png)

То есть касательно строк сначала происходит сравнение по ссылке и если результат ложный, то происходит сравнение по значение(побитовое сравнение) с помощью метода `EqualsHelper`. То есть для `string` оператор `==` просто вызывает метод `Equals`.

Вообщем смысле оператор `Equals` задумывался для сравнения по значению, а оператор `==` по ссылке

Оператора `==` для `Object` реализуется путём простого сравнения ссылок. У него нету такого же кода как у оператора `==` для строк.

Оператора `==` для `Object` транслируется в il код так:
![Pasted image 20241019235059.png](/img/user/Files/Image/Pasted%20image%2020241019235059.png)



Предпочтительные методы сравнения строк
```csharp
string s1 = "Hi there";
string s2 = "Artem";
```

|                       |                                                     |                                                                                                                                                                                                                  |
| --------------------- | --------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Boolean Equals        | `s1.Equals(s2, StringComparison.OrdinalIgnoreCase)` | Определяет, равны ли вызывающий объект передаваемому объекту.                                                                                                                                                     |
| static Boolean Equals | `string.Equals(s1,s2,StringComparison.Ordinal)`     | Определяет, равны ли два экземпляра объекта.                                                                                                                                                                     |
| static Int32 Compare  | `string.Compare(s1, s2, StringComparison.Ordinal`   | Сравнивает два указанных объекта [String](https://learn.microsoft.com/ru-ru/dotnet/api/system.string?view=net-7.0) и возвращает целое число, которое показывает их относительное положение в порядке сортировки. |
| Boolean StartsWith    | `s1.StartsWith(s2)`                                 | Определяет, совпадает ли начало данного экземпляра строки с указанной строкой                                                                                                                                    |
| Boolean EndsWith      | `s1.EndsWith(s2)`                                   | Определяет, совпадает ли конец данного экземпляра строки с указанной строкой                                                                                                                                     |


В аргументе comparisonType передается одно из значений, определенных в перечислимом типе `enum StringComparison`, который определен следующим образом:



```ad-info 
title:Описание
collapse:
|                            |     |                                                                                                                |
| -------------------------- | --- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| CurrentCulture             | 0   | Сравнивать строки, используя правила сортировки с учетом языка и региональных параметров и текущий язык и региональные параметры.                                                                                      |
| CurrentCultureIgnoreCase   | 1   | Сравнивать строки, используя правила сортировки с учетом языка и региональных параметров и текущий язык и региональные параметры без учета регистра сравниваемых строк.                                                |
| InvariantCulture           | 2   | Сравнивать строки, используя правила сортировки с учетом языка и региональных параметров и инвариантный язык и региональные параметры.                                                                                 |
| InvariantCultureIgnoreCase | 3   | Сравнивать строки, используя правила сортировки с учетом языка и региональных параметров и инвариантный язык и региональные параметры без учета регистра сравниваемых строк.                                           |
| Ordinal                    | 4   | Сравнение строк производится с использованием порядковых значений символов в строке. При этом лексикографический порядок может нарушиться, а условные обозначения, принятые в отдельной культурной среде, игнорируются |
| OrdinalIgnoreCase          | 5   | Сравнение строк производится с использованием порядковых значений символов в строке, но без учета регистра|

```



Свойство InvariantCulture получает экземпляр инвариантного языка и региональных параметров. Он связан с английским языком, но не связан ни с какой страной или регионом. Это означает что функции работающие с локалью забивают на локаль системы, и парсят всё из дефолтных настроек английского языка. 
Пример:
Если указать дату в японском формате он не поймёт, и будет её парсить как английскую.

Аргумент options является одним из значений, определенных перечислимым типом CompareOptions:
```ad-info 
title:Описание
collapse:
|                   |            |                                                                                                                                                 |
| ----------------- | ---------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| IgnoreCase        | 1          | Указывает, что сравнение строк не должно учитывать регистр.       |
| IgnoreKanaType    | 8          | Указывает, что при сравнении строк необходимо игнорировать тип "Кана". Типы японской азбуки Каны обозначают символы хираганы и катаканы, представляющие звуки японского языка.                                                                                                                 |
| IgnoreNonSpace    | 2          | Указывает, что при сравнении строк необходимо игнорировать не занимающие место несамостоятельные знаки, например, диакритические. В [стандарте Юникода](https://go.microsoft.com/fwlink/?linkid=37123) комбинированные символы определяются как символы, объединяемые с базовыми символами для получения нового символа. Непробельные составные символы в своем представлении не требуют дополнительного пространства.                                         |
| IgnoreSymbols     | 4          | Указывает, что при сравнении строк необходимо игнорировать такие символы, как разделители, знаки препинания, знаки денежных единиц, знак процента, математические символы, амперсанд и т. д.                                                                                                                                                                                                                                 |
| IgnoreWidth       | 16         | Указывает, что при сравнении строк необходимо игнорировать ширину символа. Например, символы японской катаканы могут быть написаны в полную ширину или в половину ширины. Если выбрано это значение, знаки катаканы, написанные в полную ширину, считаются равными тем же знакам, написанным в половину ширины.                                                                                                                  |
| None              | 0          | Указывает настройки параметров по умолчанию для сравнения строк.                                                                                                  |
| Ordinal           | 1073741824 | Указывает, что при сравнении строк должны использоваться последовательные значения строки в кодировке Юникода UTF-16 (последовательное сравнение единиц кода). Это позволяет быстро выполнить сравнение, которое, однако, не учитывает особенностей, связанных с языком и региональными параметрами. Строка, начинающаяся с единицы кода XXXX16, отображается перед строкой, начинающейся с YYYY16, если XXXX16 меньше YYYY16. Это значение не может быть объединено с другими значениями [CompareOptions](https://learn.microsoft.com/ru-ru/dotnet/api/system.globalization.compareoptions?view=net-8.0) и должно использоваться обособленно. |
| OrdinalIgnoreCase | 268435456  | При сравнении строк не должен учитываться регистр. После этого выполняется обычное сравнение. Этот способ аналогичен преобразованию строки в верхний регистр с помощью инвариантного языка и региональных параметров и выполнению порядкового сравнения результатов.                                                                                                                                      |
| StringSort        | 536870912  | Указывает, что при сравнении строк следует использовать алгоритм сортировки строк. В строке сортировки дефис, апостроф, а также другие знаки, не являющиеся буквенно-цифровыми, предшествуют буквенно-цифровым знакам.                                                    |
```


Рекомендации:
1. Для сравнения** внутренних строк**(представления имен путей и файлов, URL-адресов, параметров и разделов реестра, переменных окружения, отражения, XML-тегов, XML-атрибутов) следует всегда использовать флаг **StringComparison.Ordinal** или **StringComparison.OrdinalIgnoreCase**. Это самый быстрый способ сравнения, так как он игнорирует лингвистические особенности и региональные стандарты.
2. Если требуется корректно сравнить строки с точки зрения **лингвистических особенностей** (обычно перед выводом их на экран для пользователя), следует использовать флаг **StringComparison.CurrentCulture** или **StringComparison.CurrentCultureIgnoreCase**.
3. Если вы хотите изменить **регистр символов** строки перед выполнением простого сравнения, следует использовать метод **ToUpperInvariant**, а не ToLowerInvariant из-за того, что в Microsoft сравнение строк** в верхнем регистре оптимизировано**. На самом деле, в FCL перед не зависящим от регистра сравнением строки нормализуют путем приведения их к верхнему регистру

#### Региональные свойства потока

В CLR у каждого потока есть два свойства, ссылающиеся на объект CultureInfo.

- CurrentUICulture служит для получения ресурсов, видимых конечному пользователю. Это свойство наиболее полезно для графического интерфейса пользователя или приложений Web Forms, так как оно обозначает язык, который следует выбрать для вывода элементов пользовательского интерфейса, таких как надписи и кнопки.
```csharp
Thread.CurrentThread.CurrentUICulture= new CultureInfo("en-US", false)
```
- CurrentCulture используется во всех случаях, в которых не используется свойство CurrentUICulture, в том числе для форматирования чисел и дат, приведения и сравнения строк.
```csharp
Thread.CurrentThread.CurrentCulture= new CultureInfo("fr-FR", false);
```


```ad-tip
title:Изменение в глобализации
.NET 5 и более поздние версии используют библиотеки международных компонентов для Unicode (ICU) для функций глобализации при работе в Windows 10 May 2019 Update или более поздней версии. вместо библиоти локализации NLS
[Изменения](https://learn.microsoft.com/ru-ru/dotnet/core/extensions/globalization-icu)

[Изменения](https://learn.microsoft.com/en-us/dotnet/core/compatibility/globalization/5.0/icu-globalization-api)
```

#### Использование NLS вместо ICU
```json
<ItemGroup>
  <RuntimeHostConfigurationOption Include="System.Globalization.UseNls" Value="true" />
</ItemGroup>
```

```csharp
public static void Main()
{
	Console.OutputEncoding = Encoding.UTF8;
	String s1 = "ss";
	String s2 = "ß";
	Boolean eq;
	// CompareOrdinal возвращает ненулевое значение
	eq = String.Compare(s1, s2, StringComparison.Ordinal) == 0;
	Console.WriteLine("Ordinal comparison: '{0}' {2} '{1}'", s1, s2,
	eq ? "==" : "!=");

	// Сортировка строк для немецкого языка (de) в Германии (DE)
	CultureInfo ci = new CultureInfo("de-DE",false);
	// Compare возвращает нуль
	eq = String.Compare(s1, s2, ci, CompareOptions.IgnoreNonSpace) == 0;
	Console.WriteLine("Cultural comparison: '{0}' {2} '{1}'", s1, s2,
	eq ? "==" : "!=");

	bool equals = String.Equals("strasse", "straße"); // true
	equals = String.Equals("strasse", "straße");  // true

	//Ordinal comparison: 'Strasse' != 'Straße'
	//Cultural comparison: 'Strasse' == 'Straße'
}
```
Если метод Compare не выполняет простое сравнение, то он производит **расширение символов** (character expansions), то есть **разбивает сложные символы на несколько символов**, игнорируя региональные стандарты. В предыдущем случае немецкий символ **ß** всегда расширяется до **ss**. Аналогично лигатурный символ **Æ** всегда расширяется до **AE**. Поэтому в приведенном примере вызов Compare будет всегда возвращать 0 независимо от выбранных региональных стандартов.


При вызове метода Compare класса String используются указанные вызывающим потоком региональные стандарты. Если региональные стандарты не указаны, используются значения свойства CurrentCulture вызывающего потока.

#### Интернирование строк
Сравнение строк используется во многих приложениях, однако эта операция может ощутимо сказаться на производительности

1. При порядковом сравнении (ordinal comparison) CLR быстро проверяет, **равно ли количество символов в строках**. При отрицательном результате строки **точно не равны**, но если длина одинакова, приходится сравнивать их символ за символом.
2. При сравнении с учетом региональных стандартов среде CLR тоже приходится посимвольно сравнить строки, потому что две строки разной длины могут оказаться равными

Хранение в памяти нескольких экземпляров одной строки приводит к непроизводительным затратам памяти — ведь строки неизменяемы. 

Эффективного использования памяти можно добиться, если держать в ней одну строку, на которую будут указывать соответствующие ссылки.

Для этого надо применить поддерживаемый CLR механизм интернирования строк (string interning). 

При инициализации CLR создает внутреннюю хеш-таблицу, в которой **ключами являются строки**, а **значениями ссылки** на строковые объекты в управляемой куче. Вначале таблица, разумеется, пуста. В классе String есть два метода, предоставляющие доступ к внутренней хеш-таблице:

```csharp
public static String Intern(String str);
public static String IsInterned(String str);
```
Первый из них, **Intern**, ищет String во внутренней хеш-таблице. Если строка обнаруживается, возвращается ссылка на соответствующий объект String. Иначе создается копия строки, она **добавляется** во внутреннюю хеш-таблицу, и возвращается ссылка на копию. 

```csharp
string a = "aaa"; 
string b = "aa"; 
b+="a"; 
bool c = (object)a == (object) b; // И получаем false
```


```csharp
string a = "aaa";
string b = "aa";
b += "a";
b = string.Intern(b);
bool c = (object)a == (object)b; // True
```

> По дефолту интернируются только **литералы**, строки, которые образовались иным способом, нужно добавлять вручную

Если приложение больше не удерживает ссылку на исходный объект String, уборщик мусора вправе освободить память, занимаемую этой строкой. Обратите внимание, что уборщик мусора не вправе освободить строки, на которые ссылается внутренняя хеш-таблица, поскольку в ней самой есть ссылки на эти String. Объекты String, на которые ссылается внутренняя хеш-таблица, нельзя освободить, пока не выгружен соответствующий домен приложения или не закрыт поток. 

**IsInterned** как и Intern получает параметр String и ищет его во внутренней хеш-таблице. Если поиск удачен, IsInterned возвращает ссылку на интернированную строку. В противном случае он возвращает null, а саму строку **не вставляет** в хеш-таблицу.


По умолчанию при загрузке сборки CLR интернирует все литеральные строки, описанные в метаданных сборки
Выяснилось, что интернирование строк отрицательно сказывается на производительности из-за необходимости дополнительного поиска в хеш-таблица, поэтому Microsoft теперь позволяет отключить эту «функцию» с помощью аттрибута
```csharp
[System.Runtime.CompilerServices.CompilationRelaxationsAttribute(System.Runtime.CompilerServices.
CompilationRelaxations.NoStringInterning)]
//или
using System.Runtime.CompilerServices;
[assembly: CompilationRelaxationsAttribute(CompilationRelaxations.NoStringInterning)]
```
В целях повышения производительности работы приложения компилятор C# всегда при компиляции сборки отключает интернирование строк.

> [!warning] 
> Даже если в сборке определен атрибут отключающий интернирование строк, CLR может предпочесть интернировать строки, но на это не стоит рассчитывать. 


Следующий код демонстрирует интернирование строк:
```csharp
	String s1 = "Hello";
	String s2 = "Hello";
	Console.WriteLine(Object.ReferenceEquals(s1, s2)); // Должно быть 'False'
	s1 = String.Intern(s1);
	s2 = String.Intern(s2);
	Console.WriteLine(Object.ReferenceEquals(s1, s2)); // 'True'
```
Однако если выполнить этот код в CLR версии 4.5, будет выведено значение True. Дело в том, что эта версия CLR игнорирует атрибут/флаг, созданный компилятором C#
На .NET 6 не удалось отключить интернирование строк, приведённый выше код всегда выдаёт True, с любыми атрибутами.


#### Эффективное создание строк
`StringBuilder` не считается примитивным типом. Объект StringBuilder создается так же, как любой объект непримитивного типа:

```csharp
StringBuilder sb = new StringBuilder();
```

При увеличении строки, представляющей ранее выделенный массив символов, `StringBuilder` **автоматически выделит память** для нового, большего по размеру массива, **скопирует символы** и приступит к работе с новым массивом. А прежний массив попадет **в сферу действия уборщика мусора**.

Конструкторы `StringBuilder`:
- Максимальная емкость (maximum capacity) - поле, которое задает максимальное число символов, размещаемых в строке
- **Емкость (capacity)** — поле, показывающее размер массива символов StringBuilder. По умолчанию оно равно 16. При добавлении символов StringBuilder определяет, не выходит ли новый размер массива за установленный предел. Если да, то StringBuilder автоматически удваивает емкость, и исходя из этого значения, выделяет память под новый массив, а затем копирует символы из исходного массива в новый. Исходный массив в дальнейшем утилизируется сборщиком мусора. Динамическое увеличение массива **снижает производительность**, поэтому его следует избегать, задавая подходящую емкость в начале работы с объектом.


Если нужно форматировать строку, скажем, для Вьетнама, следует создать объект CultureInfo и передать его ToString как параметр formatProvider. Вот как формируют строковое представление числа Decimal во вьетнамском формате денежной величины(C):

```csharp
Decimal price = 123.54M; 
String s = price.ToString("C", new CultureInfo("vi-VN")); 
MessageBox.Show(s);
```


#### Защищенные строки

Часто объекты String применяют для хранения конфиденциальных данных, таких как пароли или информация кредитной карты. К сожалению, объекты String **хранят массив символов в памяти**, и если разрешить выполнение небезопасного или неуправляемого кода, он может просмотреть адресное пространство кода, найти строку с конфиденциальной информацией и использовать ее в своих неблаговидных целях.

Для решения таких задач специалисты Microsoft добавили в FCL безопасный строковый класс` System. Security.SecureString`. При создании объекта SecureString его код **выделяет блок неуправляемой памяти**, которая содержит массив символов. Уборщику мусора об этой неуправляемой памяти ничего не известно. **Символы строки шифруются** для защиты конфиденциальной информации от любого потенциально опасного или неуправляемого кода.

Класс SecureString реализует интерфейс IDisposable, служащий для надежного уничтожения конфиденциальной информации, хранимой в строке. 

Когда приложению больше не нужно хранить конфиденциальную строковую информацию, достаточно **вызвать метод Dispose** типа SecureString или использовать **экземпляр SecureString в конструкции using**. Внутренняя реализация Dispose обнуляет содержимое буфера памяти, чтобы предотвратить доступ постороннего кода, и только после этого буфер освобождается. Объект SecureString содержит внутренний объект класса, производного от SafeBuffer, в котором хранится сама строка.

В версии 4 инфраструктуры .NET Framework передать SecureString в качестве пароля можно: 
- при работе с криптографическим провайдером (Cryptographic Service Provider, CSP) см. класс System.Security.Cryptography.CspParameters; 
- при создании, импорте или экспорте сертификата в формате X.509 см. классы System.Security.Cryptography.X509Certificates.X509Certificate и System. Security.Cryptography.X509Certificates.X509Certificate2;  при запуске нового процесса под определенной учетной записью пользователя см. классы System.Diagnostics.Process и System.Diagnostics.ProcessStartInfo; Защищенные строки 401 
- при организации нового сеанса записи журнала событий см. класс System. Diagnostics.Eventing.Reader.EventLogSession; 
- при использовании элемента управления System.Windows.Controls.PasswordBox см. класс свойства SecurePassword.


Наконец, вы можете создавать собственные методы, принимающие в качестве аргумента объект SecureString.

В методе надо задействовать **объект SecureString** для создания **буфера** неуправляемой памяти, хранящего расшифрованные символы, **до использования этого буфера в методе**. Чтобы сократить до минимума временное «окно» доступа к конфиденциальным данным, ваш код должен обращаться к расшифрованной строке минимально возможное время. После использования строки следует как можно скорее обнулить буфер и освободить его.

```csharp
public static void Main()
{
	using (SecureString ss = new SecureString())
	{
		Console.Write("Please enter password: ");
		while (true)
		{
			ConsoleKeyInfo cki = Console.ReadKey(true);
			if (cki.Key == ConsoleKey.Enter) break;
			// Присоединить символы пароля в конец SecureString
			
			if (cki.Key == ConsoleKey.Backspace)
			{
				if (ss.Length >= 1)
				{
					Console.Write("\b \b");
					ss.RemoveAt(ss.Length - 1);
				}
				continue;
			}
			ss.AppendChar(cki.KeyChar);
			Console.Write("*");
		}
		Console.WriteLine();
		// Пароль введен, отобразим его для демонстрационных целей
		DisplaySecureString(ss);
		Console.ReadLine();
	}
	// После 'using' SecureString обрабатывается методом Disposed,
	// поэтому никаких конфиденциальных данных в памяти нет
}

// Этот метод небезопасен, потому что обращается к неуправляемой памяти
private unsafe static void DisplaySecureString(SecureString ss)
{
	Char* pc = null;
	try
	{
		// Дешифрование SecureString в буфер неуправляемой памяти
		pc = (Char*)Marshal.SecureStringToCoTaskMemUnicode(ss);
		// Доступ к буферу неуправляемой памяти,
		// который хранит дешифрованную версию SecureString
		for (Int32 index = 0; pc[index] != 0; index++)
			Console.Write(pc[index]);
	}
	finally
	{
		// Обеспечиваем обнуление и освобождение буфера неуправляемой памяти,
		// который хранит расшифрованные символы SecureString
		if (pc != null)
			Marshal.ZeroFreeCoTaskMemUnicode((IntPtr)pc);
	}
}
```

Класс System.Runtime.InteropServices.Marshal предоставляет 5 методов, которые служат для расшифровки символов SecureString в буфер неуправляемой памяти. Все методы, за исключением аргумента SecureString, статические и возвращают IntPtr. У каждого **метода** есть связанный метод, который нужно обязательно вызывать для обнуления и **освобождения внутреннего буфера**. 

В таблице приведены методы класса System.Runtime.InteropServices.Marshal, используемые для расшифровки SecureString в буфер неуправляемой памяти, а также связанные методы для обнуления и освобождения буфера.

| Метод расшифровки SecureString в буфер | Метод обнуления и освобождения буфера |
| -------------------------------------- | ------------------------------------- |
| SecureStringToBSTR                     | ZeroFreeBSTR                          |
| SecureStringToCoTaskMemAnsi            | ZeroFreeCoTaskMemAnsi                 |
| SecureStringToCoTaskMemUnicode         | ZeroFreeCoTaskMemUnicode              |
| SecureStringToGlobalAllocAnsi          | ZeroFreeGlobalAllocAnsi               |
| SecureStringToGlobalAllocUnicode       | ZeroFreeGlobalAllocUnicode            |



